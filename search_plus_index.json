{"./":{"url":"./","title":"Introduction","keywords":"","body":"Java Cloud With Dubbo 鲁斯菲尔精品课系列：微服务架构从开发到部署-构建 Java 原生云服务-Dubbo 篇 讲师：李卫民 在线文档 https://topsale.gitbooks.io/java-cloud-dubbo/content/ 本书代码 https://github.com/topsale/code-java-cloud-dubbo.git 本书文档 https://github.com/topsale/book-java-cloud-dubbo.git Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter01/构建单体应用模型.html":{"url":"chapter01/构建单体应用模型.html","title":"构建单体应用模型","keywords":"","body":"构建单体应用模型 我们假设，您开始开发一个打车应用，打算与 Uber 和 Hailo 竞争。经过初步交流和需求收集，您开始手动或者使用类似 Rails、Spring Boot、Play 或者 Maven 等平台来生成一个新项目。 该新应用是一个模块化的六边形架构，如下图（一个简单的打车应用）所示： 该应用的核心是由模块实现的业务逻辑，它定义了服务、领域对象和事件。围绕核心的是与外部世界接口对接的适配器。适配器示例包括数据库访问组件、生产和消费消息的消息组件和暴露了 API 或实现了一个 UI 的 web 组件。 尽管有一个逻辑模块化架构，但应用程序被作为一个单体进行打包和部署。实际格式取决于应用程序的语言和框架。例如，许多 Java 应用程序被打包成 WAR 文件部署在如 Tomcat 或者 Jetty 之类的应用服务器上。其他 Java 应用程序被打包成自包含 (self-contained) 的可执行 JAR。类似地， Rails 和 Node.js 应用程序被打包为有目录层次的结构 以这种风格编写的应用是很常见的。他们很容易开发，因为我们的 IDE 和其他工具就是专注于构建单体应用。这些应用程序也很容易测试， 您可以通过简单地启动并使用如 Selenium 测试包来测试 UI 以轻松地实现端到端 (end-to-end) 测试。单体应用同样易于部署。您只需拷贝打包好的应用程序到服务器上。您还可以通过运行多个副本和结合负载均衡器来扩展应用。在项目的早期阶段，它可以良好运作。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter01/走向单体地狱.html":{"url":"chapter01/走向单体地狱.html","title":"走向单体地狱","keywords":"","body":"走向单体地狱 不幸的是，这种简单的方法有很大的局限性。成功的应用有一个趋势，随着时间推移而变得越来越臃肿。您的开发团队在每个冲刺阶段都要实现更多的用户需求，这意味着需要添加了许多行代码。几年之后，小而简单的应用将会逐渐成长成一个庞大的单体。为了给出一个极端示例，我最近和一位开发者做了交谈，他正在编写一个工具，该工具用于从他们的数百万行代码 (lines of code， LOC) 应用中分析出数千个 JAR 之间的依赖。我相信这是大量开发者在多年齐心协力下创造出了这样的野兽。 一旦您的应用程序成为了一个庞大、复杂的单体，您的开发组织可能会陷入了一个痛苦的境地，敏捷开发和交付的任何一次尝试都将原地徘徊。一个主要问题是应用程序实在非常复杂。对于任何一个开发人员来说显得过于庞大，这是可以理解的。最终，正确修复 bug 和实现新功能变得非常困难而耗时。此外， 这种趋势就像是往下的螺旋。如果基本代码都令人难以理解，那么改变也不会变得正确，您最终得到的将是一个巨大且不可思议的大泥球。 应用程序的规模也将减缓发展。应用程序越大，启动时间越长。我调查过开发者们的单体应用的大小和性能，一些报告的启动时间为 12 分钟。我也听说过应用程序启动需要 40 分钟以上的怪事。如果开发人员经常要重启应用服务器，那么很大一部分时间都是在等待中度过，他们的生产力将受到限制。 另一个大问题是，复杂的单体应用本身就是持续部署的障碍。如今， SaaS 应用发展到了可以每天多次将变更推送到生产环境中。这对于复杂的单体来说非常困难，因为您需要重新部署整个应用程序才能更新其中任何一部分。 联想到我之前提到的漫长启动时间，这也不会是什么好事。此外，因变更所产生的影响通常不是很明确，您很可能需要做大量的手工测试。因此，持续部署是不可能做到的。 当不同模块存在资源需求冲突时，单体应用可能难以扩展。例如，一个模块可能会执行 CPU 密集型图像处理逻辑，理想情况下是部署在 Amazon EC2 Compute Optimized 实例中。另一个模块可能是一个内存数据库，最适合部署到 EC2 Memory-optimized 实例。然而， 由于这些模块被部署在一起，您必须在硬件选择上做出妥协。 单体应用的另一个问题是可靠性。因为所有模块都运行在同一进程中。任何模块的一个 bug，比如内存泄漏，可能会拖垮整个进程。此外，由于应用程序的所有实例都是相同的，该错误将影响到整个应用的可用性。 最后但同样重要，单体应用使得采用新框架和语言变得非常困难。例如，我们假设您有 200 万行代码使用了 XYZ 框架编写。如果使用较新的 ABC 框架来重写整个应用，这将非常昂贵（在时间和成本方面），即使框架非常好。因此，这对于采用新技术是一个非常大的障碍。在项目开始时， 您无论选择何种新技术都会感到困扰。 总结一下：您有一个成功的关键业务应用程序，它已经发展成为一个只有少数开发人员（如果有的话）能够理解的巨大单体。它使用了过时、非生产性技术编写，这使得招聘优秀开发人员变得非常困难。应用程序变得难以扩展，不可靠。因此敏捷开发和应用交付是不可能的。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter01/微服务-解决复杂问题.html":{"url":"chapter01/微服务-解决复杂问题.html","title":"微服务-解决复杂问题","keywords":"","body":"微服务-解决复杂问题 许多如 Amazon、 eBay 和 Netflix 这样的组织，已经采用现在所谓的微服务架构模式解决了这个问题，而不是构建一个臃肿的单体应用。它的思路是将应用程序分解成一套较小的互连服务。一个服务通常实现了一组不同的特性或功能，例如订单管理、客户管理等。每一个微服务都是一个迷你应用，它自己的六边形架构包括了业务逻辑以及多个适配器。 一些微服务会暴露一个供其他微服务或应用客户端消费的 API。其他微服务可能实现了一个 web UI。在运行时，每个实例通常是一个云虚拟机 (virtual machine， VM) 或者一个 Docker 容器。 例如，前面描述的系统可能分解成如下图（一个单体应用分解成微服务) 所示： 应用程序的每个功能区域现在都由自己的微服务实现。此外，Web 应用程序被划分为一组更简单的 Web 应用程序。例如，以我们的出租车为例，一个是乘客的应用，一个是司机的应用。这使得它更容易地为特定的用户、司机、设备或者专门的用例部署不同的场景。每个后端服务暴露一个 REST API，大部分服务消费的 API 由其他服务提供。例如， Driver Management 使用了 Notification 服务器来通知一个可用司机一个可选路程。UI 服务调用了其他服务来渲染页面。服务也可以使用异步、基于消息的通信。 一些 REST API 也暴露给移动端应用以供司机和乘客使用。然而，应用不能直接访问后端服务。相反，他们之间的通信是由一个称为 API 网关 (API Gateway) 的中介负责。 API 网关负责负载均衡、缓存、访问控制、 API 计量和监控， 可以通过使用 NGINX 来实现。 开发和交付中的伸缩立方： 微服务架构模式相当于此伸缩立方的 Y 轴坐标，此立方是一个来自《架构即未来》 的三维伸缩模型。另外两个坐标轴是由运行多个相同应用程序副本的负载均衡器组成的X 轴坐标和 Z 轴坐标（或数据分区) ，其中请求的属性（例如，一行记录的主键或者客户标识) 用于将请求路由到特定的服务器。 在运行时，X 坐标轴上运行着服务的多个实例，每个服务配合负载均衡器以满足吞吐量和可用性。某些应用程序也有可能使用 Z 坐标轴来进行分区服务。下图展示了如何用 Docker 将 Trip Management 服务部署到 Amazon EC2 上运行。 使用 Docker 部署 Trip Management 服务： 在运行时，Trip Management 服务由多个服务实例组成，每个服务实例是一个 Docker容器。为了实现高可用，容器是在多个云虚拟机上运行的。服务实例的之前是一个类似 NGINX 的负载均衡器，用于跨实例分发请求。负载均衡器也可以处理其他问题，如缓存、访问控制、API 度量和监控。 微服务架构模式明显影响到了应用程序与数据库之间的关系。与其他共享单个数据库模式 (schema) 服务有所不同， 其每一个服务都有自己的数据库模式。一方面，这种做法与企业级数据库数据模型的想法相背，此外，它经常导致部分数据冗余。然而，如果您想从微服务中受益，每一个服务都应该有自己的数据库模式。因为它能实现松耦合。下图展示了数据库架构示例应用程序。 每个服务都拥有各自的数据库。而且，服务可以使用一种最适合其需求、号称多语言持久架构 （polyglot persistence architecture ) 的数据库。例如，DriverManagement，要找到与潜在乘客接近的司机，就必须使用支持高效地理查询的数据库。 打车应用的数据库架构： 从表面上看，微服务架构模式类似于 SOA。微服务是由一组服务组成。然而，换另一种方式去思考微服务架构模式，它是没有商业化的 SOA，没有集成 Web 服务规范 (WS-*) 和企业服务总线 (Enterprise Service Bus， ESB) 。基于微服务的应用支持更简单、轻量级的协议，例如，REST，而不是 WS-*。他们也尽量避免使用 ESB，而是实现微服务本身具有类似 ESB 的功能。微服务架构也拒绝了 SOA 的其他部分，例如，数据访问规范模式概念。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter01/微服务的优点.html":{"url":"chapter01/微服务的优点.html","title":"微服务的优点","keywords":"","body":"微服务的优点 微服务架构模式有许多非常好的地方。 第一，它解决了复杂问题。它把可能会变得庞大的单体应用程序分解成一套服务。虽然功能数量不变，但是应用程序已经被分解成可管理的块或者服务。每个服务都有一个明确定义边界的方式，如远程过程调用（RPC）驱动或消息驱动 API。微服务架构模式强制一定程度的模块化，实际上，使用单体代码来实现是极其困难的。因此，使用微服务架构模式，个体服务能被更快地开发，并更容易理解与维护。 第二，这种架构使得每个服务都可以由一个团队独立专注开发。开发者可以自由选择任何符合服务 API 契约的技术。当然，更多的组织是希望通过技术选型限制来避免完全混乱的状态。然而，这种自由意味着开发人员不再有可能在这种自由的新项目开始时使用过时的技术。当编写一个新服务时，他们可以选择当前的技术。此外，由于服务较小，使用当前技术重写旧服务将变得更加可行。 第三，微服务架构模式可以实现每个微服务独立部署。开发人员根本不需要去协调部署本地变更到服务。这些变更一经测试即可立即部署。比如，UI 团队可以执行 A|B 测试，并快速迭代 UI 变更。微服务架构模式使得持续部署成为可能。 最后，微服务架构模式使得每个服务能够独立扩展。您可以仅部署满足每个服务的容量和可用性约束的实例数目。此外，您可以使用与服务资源要求最匹配的硬件。例如，您可以在 EC2 Compute Optimized 实例上部署一个 CPU 密集型图像处理服务，并且在 EC2 Memory-optimized 实例上部署一个内存数据库服务。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter01/微服务的缺点.html":{"url":"chapter01/微服务的缺点.html","title":"微服务的缺点","keywords":"","body":"微服务的缺点 就像 Fred Brooks 大约在 30 年前写的《人月神话》中说的，没有银弹。与其他技术一样，微服务架构模式也存在着缺点。其中一个缺点就是名称本身。微服务这个术语的重点过多偏向于服务的规模。事实上，有些开发者主张构建极细粒度的 10 至 100 LOC（代码行） 服务，虽然这对于小型服务可能比较好，但重要的是要记住，小型服务只是一种手段，而不是主要目标。微服务的目标在于充分分解应用程序以方便应用敏捷开发和部署。 微服务另一个主要缺点是由于微服务是一个分布式系统，其使得整体变得复杂。开发者需要选择和实现基于消息或者 RPC 的进程间通信机制。此外，由于目标请求可能很慢或者不可用，他们必须要编写代码来处理局部故障。虽然这些并不是很复杂、高深，但模块间通过语言级方法/过程调用相互调用，这比单体应用要复杂得多。 微服务的另一个挑战是分区数据库架构。更新多个业务实体的业务事务是相当普遍的。这些事务在单体应用中的实现显得微不足道，因为单体只存在一个单独的数据库。在基于微服务的应用程序中，您需要更新不同服务所用的数据库。通常不会选择分布式事务，不仅仅是因为 CAP 定理。他们根本不支持如今高度可扩展的 NoSQL 数据库和消息代理。您最后不得不使用基于最终一致性的方法，这对于开发人员来说更具挑战性。 测试微服务应用程序也很复杂。例如，使用现代框架如 Spring Boot，只需要编写一个测试类来启动一个单体 web 应用程序并测试其 REST API。相比之下，一个类似的测试类对于微服务来说需要启动该服务及其所依赖的所有服务，或者至少为这些服务配置存根。再次声明，虽然这不是一件高深的事情，但不要低估了这样做的复杂性。 微服务架构模式的另一个主要挑战是实现了跨越多服务变更。例如，我们假设您正在实现一个变更服务 A、服务 B 和 服务 C 的需求，其中 A 依赖于 B，且 B 依赖于 C。在单体应用程序中，您可以简单地修改相应的模块、整合变更并一次性部署他们。相反，在微服务中您需要仔细规划和协调出现的变更至每个服务。例如，您需要更新服务 C，然后更新服务 B，最后更新服务 A。幸运的是，大多数变更只会影响一个服务，需要协调的多服务变更相对较少。 部署基于微服务的应用程序也是相当复杂的。一个单体应用可以很容易地部署到基于传统负载均衡器的一组相同服务器上。每个应用程序实例都配置有基础设施服务的位置（主机和端口），比如数据库和消息代理。相比之下，微服务应用程序通常由大量的服务组成。例如，据 Adrian Cockcroft 了解到，Hailo 拥有 160 个不同的服务，Netflix 拥有的服务超过 600 个。 每个服务都有多个运行时实例。还有更多的移动部件需要配置、部署、扩展和监控。此外，您还需要实现服务发现机制，使得服务能够发现需要与之通信的任何其他服务的位置（主机和端口）。比较传统麻烦的基于票据（ticket-based）和手动的操作方式无法扩展到如此复杂程度。因此，要成功部署微服务应用程序，需要求开发人员能高度控制部署方式和高度自动化。 一种自动化方式是使用现成的平台即服务（PaaS），如 Cloud Foundry。PaaS 为开发人员提供了一种简单的方式来部署和管理他们的微服务。它让开发人员避开了诸如采购和配置 IT 资源等烦恼。同时，配置 PaaS 的系统人员和网络专业人员可以确保达到最佳实践以落实公司策略。 自动化微服务部署的另一个方式是开发自己的 PaaS。一个普遍的起点是使用集群方案，如 Kubernetes，与 Docker 等容器技术相结合。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux简介.html":{"url":"chapter02/Linux简介.html","title":"Linux 简介","keywords":"","body":"Linux 简介 Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 Linux 内核。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 Linux 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 Linux 操作系统。 Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。只要遵循 GNU 通用公共许可证,任何人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统 (也被称为 GNU/ Linux)。通常情况下，Linux 被打包成供桌上型电脑和服务器使用的 Linux 发行版本。一些流行的主流 Linux 发行版本，包括 Debian (及其衍生版本 Ubuntu)，Fedora 和 OpenSUSE 等。Kernel + Softwares + Tools 就是 Linux Distribution 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux与Windows比较.html":{"url":"chapter02/Linux与Windows比较.html","title":"Linux 与 Windows 比较","keywords":"","body":"Linux 与 Windows 比较 目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下 比较 Windows Linux 界面 界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同 图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。 驱动程序 驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。 由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在 Windows 下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。 使用 使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。 图形界面使用简单，容易入门。文字界面，需要学习才能掌握。 学习 系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。 系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。 软件 每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。 大部分软件都可以自由获取，同样功能的软件选择较少。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux安装.html":{"url":"chapter02/Linux安装.html","title":"Linux 安装","keywords":"","body":"Linux 安装 原生云应用基本都是基于云服务器部署，本地化的 Linux 操作基本也都是在虚拟机中进行模拟操作。故我们只需要安装虚拟机并在虚拟机上安装对应的 Linux 操作系统即可。 安装 VMware 不提供具体的安装说明，请自行查阅相关资料 安装 Ubuntu Server 16.04 X64 不提供具体的安装说明，请根据视频教程安装 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux远程控制管理.html":{"url":"chapter02/Linux远程控制管理.html","title":"Linux 远程控制管理","keywords":"","body":"Linux 远程控制管理 传统的网络服务程序，FTP、POP、telnet 本质上都是不安全的，因为它们在网络上通过明文传送口令和数据，这些数据非常容易被截获。SSH 叫做 Secure Shell。通过 SSH，可以把传输数据进行加密，预防攻击，传输的数据进行了压缩，可以加快传输速度。 OpenSSH SSH 是芬兰一家公司开发。但是受到版权和加密算法限制，现在很多人都使用 OpenSSH。OpenSSH 是 SSH 的替代软件，免费。 OpenSSH 由客户端和服务端组成。 基于口令的安全验证：知道服务器的帐号密码即可远程登录，口令和数据在传输过程中都会被加密。 基于密钥的安全验证：此时需要在创建一对密钥，把公有密钥放到远程服务器上自己的宿主目录中，而私有密钥则由自己保存。 检查软件是否安装 apt-cache policy openssh-client openssh-server 安装服务端 apt-get install openssh-server 安装客户端 apt-get install openssh-client OpenSSH 服务器的主要配置文件为 /etc/ssh/sshd\\_config，几乎所有的配置信息都在此文件中。 XShell XShell 是一个强大的安全终端模拟软件，它支持 SSH1, SSH2, 以及 Microsoft Windows 平台的 TELNET 协议。XShell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。 XShell 可以在 Windows 界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。 效果图如下： Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux目录结构.html":{"url":"chapter02/Linux目录结构.html","title":"Linux 目录结构","keywords":"","body":"Linux 目录结构 目录 说明 bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有root才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux常用命令.html":{"url":"chapter02/Linux常用命令.html","title":"Linux 常用命令","keywords":"","body":"Linux 常用命令 操作文件目录 系统管理命令 开关机命令 压缩命令 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:02 "},"chapter02/Linux常用命令/操作文件目录.html":{"url":"chapter02/Linux常用命令/操作文件目录.html","title":"操作文件目录","keywords":"","body":"操作文件目录 命令 说明 语法 参数 参数说明 ls 显示文件和目录列表 ls [-alrtAFR] [name...] -l 列出文件的详细信息 -a 列出当前目录所有文件，包含隐藏文件 mkdir 创建目录 mkdir [-p] dirName -p 父目录不存在情况下先生成父目录 cd 切换目录 cd [dirName] touch 生成一个空文件 echo 生成一个带内容文件 echo abcd > 1.txt，echo 1234 >> 1.txt cat 显示文本文件内容 cat [-AbeEnstTuv] [--help] [--version] fileName cp 复制文件或目录 cp [options] source dest rm 删除文件 rm [options] name... -f 强制删除文件或目录 -r 同时删除该目录下的所有文件 mv 移动文件或目录 mv [options] source dest find 在文件系统中查找指定的文件 -name 文件名 grep 在指定的文本文件中查找指定的字符串 tree 用于以树状图列出目录的内容 pwd 显示当前工作目录 ln 建立软链接 more 分页显示文本文件内容 head 显示文件开头内容 tail 显示文件结尾内容 -f 跟踪输出 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux常用命令/系统管理命令.html":{"url":"chapter02/Linux常用命令/系统管理命令.html","title":"系统管理命令","keywords":"","body":"系统管理命令 命令 说明 stat 显示指定文件的相关信息,比ls命令显示内容更多 who 显示在线登录用户 hostname 显示主机名称 uname 显示系统信息 top 显示当前系统中耗费资源最多的进程 ps 显示瞬间的进程状态 du 显示指定的文件（目录）已使用的磁盘空间的总量 df 显示文件系统磁盘空间的使用情况 free 显示当前内存和交换空间的使用情况 ifconfig 显示网络接口信息 ping 测试网络的连通性 netstat 显示网络状态信息 clear 清屏 kill 杀死一个进程 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux常用命令/开关机命令.html":{"url":"chapter02/Linux常用命令/开关机命令.html","title":"开关机命令","keywords":"","body":"开关机命令 shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。 命令 语法 参数 参数说明 shutdown shutdown [-t seconds] [-rkhncfF] time [message] -t seconds 设定在几秒钟之后进行关机程序 -k 并不会真的关机，只是将警告讯息传送给所有只用者 -r 关机后重新开机（重启） -h 关机后停机 -n 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机 -c 取消目前已经进行中的关机动作 -f 关机时，不做 fcsk 动作(检查 Linux 档系统) -F 关机时，强迫进行 fsck 动作 time 设定关机的时间 message 传送给所有使用者的警告讯息 重启 reboot shutdown -r now 关机 shutdown -h now Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux常用命令/压缩命令.html":{"url":"chapter02/Linux常用命令/压缩命令.html","title":"压缩命令","keywords":"","body":"压缩命令 tar 命令 语法 参数 参数说明 tar tar [-cxzjvf] 压缩打包文档的名称 欲打包目录 -c 建立一个归档文件的参数指令 -x 解开一个归档文件的参数指令 -z 是否需要用 gzip 压缩 -j 是否需要用 bzip2 压缩 -v 压缩的过程中显示文件 -f 使用档名，在 f 之后要立即接档名 -tf 查看归档文件里面的文件 例子： 压缩文件夹：tar -zcvf test.tar.gz test\\ 解压文件夹：tar -zxvf test.tar.gz gzip 命令 语法 参数 参数说明 gzip gzip [选项] 压缩（解压缩）的文件名 -d 解压缩 -l 对每个压缩文件，显示压缩文件的大小，未压缩文件的大小，压缩比，未压缩文件的名字 -v 对每一个压缩和解压的文件，显示文件名和压缩比 -num 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6 说明：压缩文件后缀为 gz bzip2 命令 语法 参数 参数说明 bzip2 bzip2 [-cdz] -d 解压缩 -z 压缩参数 -num 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6 说明：压缩文件后缀为 bz2 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux编辑器.html":{"url":"chapter02/Linux编辑器.html","title":"Linux 编辑器","keywords":"","body":"Linux 编辑器 vim 运行模式 编辑模式：等待编辑命令输入 插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息 命令模式：在编辑模式下，输入 : 进行命令模式 命令 :q 直接退出vi :wq 保存后退出vi ，并可以新建文件 :q! 强制退出 :w file 将当前内容保存成某个文件 :set number 在编辑文件显示行号 :set nonumber 在编辑文件不显示行号 nano nano 是一个字符终端的文本编辑器，有点像 DOS 下的 editor 程序。它比 vi/vim 要简单得多，比较适合 Linux 初学者使用。某些 Linux 发行版的默认编辑器就是 nano。 命令 保存：ctrl + o 搜索：ctrl + w 上一页：ctrl + y 下一页：ctrl + v 退出：ctrl + x Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux软件包管理.html":{"url":"chapter02/Linux软件包管理.html","title":"Linux 软件包管理","keywords":"","body":"Linux 软件包管理 APT(Advanced Packaging Tool) 是 Debian/Ubuntu 类 Linux 系统中的软件包管理程序, 使用它可以找到想要的软件包, 而且安装、卸载、更新都很简便；也可以用来对 Ubuntu 进行升级; APT 的源文件为 /etc/apt/ 目录下的 sources.list 文件。 修改数据源 常用 APT 命令 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:01 "},"chapter02/Linux软件包管理/修改数据源.html":{"url":"chapter02/Linux软件包管理/修改数据源.html","title":"修改数据源","keywords":"","body":"修改数据源 由于国内的网络环境问题，我们需要将 Ubuntu 的数据源修改为国内数据源，操作步骤如下： 查看系统版本 lsb_release -a 输出结果为 No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 16.04 LTS Release: 16.04 Codename: xenial 注意： Codename 为 xenial，该名称为我们 Ubuntu 系统的名称，修改数据源需要用到该名称 编辑数据源 vi /etc/apt/sources.list 删除全部内容并修改为 deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse 更新数据源 apt-get update Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux软件包管理/常用APT命令.html":{"url":"chapter02/Linux软件包管理/常用APT命令.html","title":"常用 APT 命令","keywords":"","body":"常用 APT 命令 安装软件包 apt-get install packagename 删除软件包 apt-get remove packagename 更新软件包列表 apt-get update 升级有可用更新的系统（慎用） apt-get upgrade 其它 APT 命令 搜索 apt-cache search package 获取包信息 apt-cache show package 删除包及配置文件 apt-get remove package --purge 了解使用依赖 apt-cache depends package 查看被哪些包依赖 apt-cache rdepends package 安装相关的编译环境 apt-get build-dep package 下载源代码 apt-get source package 清理无用的包 apt-get clean && apt-get autoclean 检查是否有损坏的依赖 apt-get check Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux用户和组管理.html":{"url":"chapter02/Linux用户和组管理.html","title":"Linux 用户和组管理","keywords":"","body":"Linux 用户和组管理 Linux 操作系统是一个多用户操作系统，它允许多用户同时登录到系统上并使用资源。系统会根据账户来区分每个用户的文件，进程，任务和工作环境，使得每个用户工作都不受干扰。 使用 Root 用户 用户账户 组账户 账户系统文件 账户管理 用户和组状态 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:02 "},"chapter02/Linux用户和组管理/使用Root用户.html":{"url":"chapter02/Linux用户和组管理/使用Root用户.html","title":"使用 Root 用户","keywords":"","body":"使用 Root 用户 在实际生产操作中，我们基本上都是使用超级管理员账户操作 Linux 系统，也就是 Root 用户，Linux 系统默认是关闭 Root 账户的，我们需要为 Root 用户设置一个初始密码以方便我们使用。 设置 Root 账户密码 sudo passwd root 切换到 Root su 设置允许远程登录 Root nano /etc/ssh/sshd_config # Authentication: LoginGraceTime 120 #PermitRootLogin without-password //注释此行 PermitRootLogin yes //加入此行 StrictModes yes 重启服务 service ssh restart Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux用户和组管理/用户账户.html":{"url":"chapter02/Linux用户和组管理/用户账户.html","title":"用户账户","keywords":"","body":"用户和组 普通用户 普通用户在系统上的任务是进行普通操作 超级管理员 管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。 安装时创建的系统用户 此用户创建时被添加到 admin 组中，在 Ubuntu 中，admin 组中的用户默认是可以使用 sudo 命令来执行只有管理员才能执行的命令的。如果不使用 sudo 就是一个普通用户。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux用户和组管理/组账户.html":{"url":"chapter02/Linux用户和组管理/组账户.html","title":"组账户","keywords":"","body":"组账户 私有组 当创建一个用户时没有指定属于哪个组，Linux 就会建立一个与用户同名的私有组，此私有组只含有该用户。 标准组 当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的为附加组。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux用户和组管理/账户系统文件.html":{"url":"chapter02/Linux用户和组管理/账户系统文件.html","title":"账户系统文件","keywords":"","body":"账户系统文件 /etc/passwd 每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。每行账户包含如下信息： root:x:0:0:root:/root:/bin/bash 用户名： 就是账号，用来对应 UID，root UID 是 0。 口令： 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。 用户标示号（UID）： 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。 组标示号（GID）： 与 /etc/group 相关用来规定组名和 GID 相对应。 注释： 注释账号 宿主目录（主文件夹）： 用户登录系统后所进入的目录 root 在 /root/itcast 命令解释器（shell）： 指定该用户使用的 shell ，默认的是 /bin/bash /etc/shadow 为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息： root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7::: 账号名称： 需要和 /etc/passwd 一致。 密码： 经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下： -rw------- 1 root root 1560 Oct 26 17:20 passwd- 只有root能都读写 最近修改密码日期： 从1970-1-1起，到用户最后一次更改口令的天数 密码最小时间间隔： 从1970-1-1起，到用户可以更改口令的天数 密码最大时间间隔： 从1970-1-1起，必须更改的口令天数 密码到期警告时间： 在口令过期之前几天通知 密码到期后账号宽限时间 密码到期禁用账户时间： 在用户口令过期后到禁用账户的天数 保留 /etc/group 用户组的配置文件 root:x:0: 用户组名称 用户组密码： 给用户组管理员使用，通常不用 GID： 用户组的ID 此用户支持的账号名称： 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root:x:0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。 /etc/gshadow 该文件用户定义用户组口令，组管理员等信息只有root用户可读。 root:\\*:: 用户组名 密码列 用户组管理员的账号 用户组所属账号 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux用户和组管理/账户管理.html":{"url":"chapter02/Linux用户和组管理/账户管理.html","title":"账户管理","keywords":"","body":"账户管理 增加用户 useradd 用户名 useradd -u (UID号) useradd -p (口令) useradd -g (分组) useradd -s (SHELL) useradd -d (用户目录) 如：useradd lusifer 增加用户名为 lusifer 的账户 修改用户 usermod -u (新UID) usermod -d (用户目录) usermod -g (组名) usermod -s (SHELL) usermod -p (新口令) usermod -l (新登录名) usermod -L (锁定用户账号密码) usermod -U (解锁用户账号) 如：usermod -u 1024 -g group2 -G root lusifer 将 lusifer 用户 uid 修改为 1024，默认组改为系统中已经存在的 group2，并且加入到系统管理员组 删除用户 userdel 用户名 (删除用户账号) userdel -r 删除账号时同时删除目录 如：userdel -r lusifer 删除用户名为 lusifer 的账户并同时删除 lusifer 的用户目录 组账户维护 groupadd 组账户名 (创建新组) groupadd -g 指定组GID groupmod -g 更改组的GID groupmod -n 更改组账户名 groupdel 组账户名 (删除指定组账户) 口令维护 passwd 用户账户名 (设置用户口令) passwd -l 用户账户名 (锁定用户账户) passwd -u 用户账户名 (解锁用户账户) passwd -d 用户账户名 (删除账户口令) gpasswd -a 用户账户名 组账户名 (将指定用户添加到指定组) gpasswd -d 用户账户名 组账户名 (将用户从指定组中删除) gpasswd -A 用户账户名 组账户名 (将用户指定为组的管理员) Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux用户和组管理/用户和组状态.html":{"url":"chapter02/Linux用户和组管理/用户和组状态.html","title":"用户和组状态","keywords":"","body":"用户和组状态 su 用户名(切换用户账户) id 用户名(显示用户的UID，GID) whoami (显示当前用户名称) groups (显示用户所属组) Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux文件权限管理.html":{"url":"chapter02/Linux文件权限管理.html","title":"Linux 文件权限管理","keywords":"","body":"Linux 文件权限管理 查看文件和目录的权限 更改操作权限 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:02 "},"chapter02/Linux文件权限管理/查看文件和目录的权限.html":{"url":"chapter02/Linux文件权限管理/查看文件和目录的权限.html","title":"查看文件和目录的权限","keywords":"","body":"查看文件和目录的权限 ls –al 使用 ls 不带参数只显示文件名称，通过 ls –al 可以显示文件或者目录的权限信息。 ls -l 文件名 显示信息包括：文件类型 (d 目录，- 普通文件，l 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称 -rw-r--r-- 1 lusifer lusifer 675 Oct 26 17:20 .profile -：普通文件 rw-：说明用户 lusifer 有读写权限，没有运行权限 r--：表示用户组 lusifer 只有读权限，没有写和运行的权限 r--：其他用户只有读权限，没有写权限和运行的权限 -rw-r--r-- 1 lusifer lusifer 675 Oct 26 17:20 .profile 文档类型及权限 连接数 文档所属用户 文档所属组 文档大小 文档最后被修改日期 文档名称 - rw- r-- r-- 文档类型 文档所有者权限（user） 文档所属用户组权限（group） 其他用户权限（other） 文档类型 d 表示目录 l 表示软连接 – 表示文件 c 表示串行端口字符设备文件 b 表示可供存储的块设备文件 余下的字符 3 个字符为一组。r 只读，w 可写，x 可执行，- 表示无此权限 连接数 指有多少个文件指向同一个索引节点。 文档所属用户和所属组 就是文档属于哪个用户和用户组。文件所属用户和组是可以更改的 文档大小 默认是 bytes Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux文件权限管理/更改操作权限.html":{"url":"chapter02/Linux文件权限管理/更改操作权限.html","title":"更改操作权限","keywords":"","body":"更改操作权限 chown 是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组 chown [-R] 用户名称 文件或者目录 chown [-R] 用户名称 用户组名称 文件或目录 -R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限 chmod 改变访问权限 chmod [who] [+ | - | =] [mode] 文件名 who 表示操作对象可以是以下字母的一个或者组合 u：用户 user g：用户组 group o：表示其他用户 a：表示所有用户是系统默认的 操作符号 +：表示添加某个权限 -：表示取消某个权限 =：赋予给定的权限，取消文档以前的所有权限 mode 表示可执行的权限，可以是 r、w、x 文件名 文件名可以使空格分开的文件列表 示例 lusifer@UbuntuBase:~$ ls -al test.txt -rw-rw-r-- 1 lusifer lusifer 6 Nov 2 21:47 test.txt lusifer@UbuntuBase:~$ chmod u=rwx,g+r,o+r test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrw-r-- 1 lusifer lusifer 6 Nov 2 21:47 test.txt lusifer@UbuntuBase:~$ 数字设定法 数字设定法中数字表示的含义 0 表示没有任何权限 1 表示有可执行权限 = x 2 表示有可写权限 = w 4 表示有可读权限 = r 也可以用数字来表示权限如 chmod 755 file_name r w x r – x r - x 4 2 1 4 - 1 4 - 1 user group others 若要 rwx 属性则 4+2+1=7 若要 rw- 属性则 4+2=6 若要 r-x 属性则 4+1=5 lusifer@UbuntuBase:~$ chmod 777 test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrwxrwx 1 lusifer lusifer 6 Nov 2 21:47 test.txt lusifer@UbuntuBase:~$ chmod 770 test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrwx--- 1 lusifer lusifer 6 Nov 2 21:47 test.txt Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux安装基本服务环境.html":{"url":"chapter02/Linux安装基本服务环境.html","title":"Linux 安装基本服务环境","keywords":"","body":"Linux 安装基本服务环境 安装 Java 安装 Tomcat 安装 MySQL Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:02 "},"chapter02/Linux安装基本服务环境/安装Java.html":{"url":"chapter02/Linux安装基本服务环境/安装Java.html","title":"安装 Java","keywords":"","body":"安装 Java 此处以 JDK 1.8.0_152 为例 下载地址 http://www.oracle.com/technetwork/java/javase/downloads/index.html 解压缩并移动到指定目录 解压缩 tar -zxvf jdk-8u152-linux-x64.tar.gz 创建目录 mkdir -p /usr/local/java 移动安装包 mv jdk1.8.0_152/ /usr/local/java/ 设置所有者 chown -R root:root /usr/local/java/ 配置环境变量 配置系统环境变量 nano /etc/environment 添加如下语句 PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\" export JAVA_HOME=/usr/local/java/jdk1.8.0_152 export JRE_HOME=/usr/local/java/jdk1.8.0_152/jre export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib 配置用户环境变量 nano /etc/profile 添加如下语句 if [ \"$PS1\" ]; then if [ \"$BASH\" ] && [ \"$BASH\" != \"/bin/sh\" ]; then # The file bash.bashrc already sets the default PS1. # PS1='\\h:\\w\\$ ' if [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrc fi else if [ \"`id -u`\" -eq 0 ]; then PS1='# ' else PS1='$ ' fi fi fi export JAVA_HOME=/usr/local/java/jdk1.8.0_152 export JRE_HOME=/usr/local/java/jdk1.8.0_152/jre export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/bin if [ -d /etc/profile.d ]; then for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset i fi 使用户环境变量生效 source /etc/profile 配置软连接 sudo update-alternatives --install \"/usr/bin/java\" \"java\" \"/usr/local/java/jdk1.8.0_152/jre/bin/java\" 1 sudo update-alternatives --install \"/usr/bin/javac\" \"javac\" \"/usr/local/java/jdk1.8.0_152/bin/javac\" 1 sudo update-alternatives --install \"/usr/bin/javaws\" \"javaws\" \"/usr/local/java/jdk1.8.0_152/jre/bin/javaws\" 1 sudo update-alternatives --set java /usr/local/java/jdk1.8.0_152/jre/bin/java sudo update-alternatives --set javac /usr/local/java/jdk1.8.0_152/bin/javac sudo update-alternatives --set javaws /usr/local/java/jdk1.8.0_152/jre/bin/javaws 测试是否安装成功 root@UbuntuBase:/usr/local/java# java -version java version \"1.8.0_152\" Java(TM) SE Runtime Environment (build 1.8.0_152-b16) Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode) 为其他用户更新用户环境变量 su lusifer source /etc/profile Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux安装基本服务环境/安装Tomcat.html":{"url":"chapter02/Linux安装基本服务环境/安装Tomcat.html","title":"安装 Tomcat","keywords":"","body":"安装 Tomcat 此处以 Tomcat 8.5.23 为例 下载地址 https://tomcat.apache.org/ 解压缩并移动到指定目录 解压缩 tar -zxvf apache-tomcat-8.5.23.tar.gz 变更目录名 mv apache-tomcat-8.5.23 tomcat 移动目录 mv tomcat/ /usr/local/ 常用命令 启动 /usr/local/tomcat/bin/startup.sh 停止 /usr/local/tomcat/bin/shutdown.sh 目录内执行脚本 ./startup.sh Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter02/Linux安装基本服务环境/安装MySQL.html":{"url":"chapter02/Linux安装基本服务环境/安装MySQL.html","title":"安装 MySQL","keywords":"","body":"安装 MySQL 安装 更新数据源 apt-get update 安装 MySQL apt-get install mysql-server 系统将提示您在安装过程中创建 root 密码。选择一个安全的密码，并确保你记住它，因为你以后需要它。接下来，我们将完成 MySQL 的配置。 配置 因为是全新安装，您需要运行附带的安全脚本。这会更改一些不太安全的默认选项，例如远程 root 登录和示例用户。在旧版本的 MySQL 上，您需要手动初始化数据目录，但 Mysql 5.7 已经自动完成了。 运行安全脚本： mysql_secure_installation 这将提示您输入您在之前步骤中创建的 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。您只需在之前步骤中进行设置即可，因此无需现在更改。 测试 按上边方式安装完成后，MySQL 应该已经开始自动运行了。要测试它，请检查其状态。 lusifer@ubuntu:~$ systemctl status mysql.service ● mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled) Active: active (running) since Tue 2017-11-21 13:04:34 CST; 3min 24s ago Main PID: 2169 (mysqld) CGroup: /system.slice/mysql.service └─2169 /usr/sbin/mysqld Nov 21 13:04:33 ubuntu systemd[1]: Starting MySQL Community Server... Nov 21 13:04:34 ubuntu systemd[1]: Started MySQL Community Server. 查看 MySQL 版本： mysqladmin -p -u root version 配置远程访问 修改配置文件 nano /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉(语句前面加上 # 即可)：bind-address = 127.0.0.1 重启 MySQL service mysql restart 登录 MySQL mysql -u root -p 查看和设置密码安全级别 select @@validate_password_policy; set global validate_password_policy=0; 查看和设置密码长度限制 select @@validate_password_length; set global validate_password_length=1; 授权 root 用户允许所有人连接 grant all privileges on *.* to 'root'@'%' identified by '你的 mysql root 账户密码'; 命令 启动 service mysql start 停止 service mysql stop 重启 service mysql restart 其它配置 修改配置 mysqld.cnf 配置文件 vi /etc/mysql/mysql.conf.d/mysqld.cnf 配置默认字符集 在 [mysqld] 节点上增加如下配置 [client] default-character-set=utf8 在 [mysqld] 节点底部增加如下配置 default-storage-engine=INNODB character-set-server=utf8 collation-server=utf8_general_ci 配置忽略数据库大小写敏感 在 [mysqld] 节点底部增加如下配置 lower-case-table-names = 1 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker简介.html":{"url":"chapter03/Docker简介.html","title":"Docker 简介","keywords":"","body":"Docker 简介 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口 (类似 iPhone 的 app)，更重要的是容器性能开销极低。 Docker 的应用场景 Web 应用的自动化打包和发布 自动化测试和持续集成、发布 在服务型环境中部署和调整数据库或其他的后台应用 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS (Platform-as-a-Service) 环境 Docker 的优点 简化程序：Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。 避免选择恐惧症：如果你有选择恐惧症，还是资深患者。Docker 帮你打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。 节省开支：一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。 Docker 引擎 Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。 一种服务器，它是一种称为守护进程并且长时间运行的程序。 REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。 一个有命令行界面 (CLI) 工具的客户端。 Docker 引擎组件的流程如下图所示： Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker功能特点.html":{"url":"chapter03/Docker功能特点.html","title":"Docker 功能特点","keywords":"","body":"Docker 功能特点 虽然Docker提供了很多功能，但这里只列出了一些主要功能，如下所示： 轻松快捷的配置 这是Docker的一个主要功能，可帮助我们轻松快速地配置系统。可以在更少的时间和精力的情况下部署代码。 由于Docker可以在各种各样的环境中使用，基础架构不再要求与应用程序的环境相关联。 提高工作效率 通过放宽技术配置和应用的快速部署。 毫无疑问，它节约了时间提高了生产率。 Docker不仅有助于在孤立环境中执行应用程序，而且还减少了资源。 应用隔离 Docker提供用于在隔离环境中运行应用程序的容器。 每个容器独立于另一个容器，并允许执行任何类型的应用程序。 云调度 它是Docker容器的集群和调度工具。 Swarm使用Docker API作为其前端，这有助于我们使用各种工具来控制它。 它还可以将Docker主机集群控制为一个虚拟主机。 这是一个用于启用可插拔后端的自组织引擎组。 路由网 它将可用节点上已发布端口的传入请求路由到活动容器。 即使节点上没有任务正在运行，此功能也可以实现连接。 服务 服务是允许指定集群内的容器状态的任务列表。 每个任务表示一个应该运行的容器的一个实例，并且Swarm在节点之间调度它们。 安全管理 它允许将保密数据保存到云群 (swarm) 中，然后选择给予服务访问某些保密数据。它包括一些重要的命令给引擎，如保密数据检查，保密数据创建等。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker系统架构.html":{"url":"chapter03/Docker系统架构.html","title":"Docker 系统架构","keywords":"","body":"Docker 系统架构 Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。 Docker 容器通过 Docker 镜像来创建。 容器与镜像的关系类似于面向对象编程中的对象与类。 Docker 面向对象 容器 对象 镜像 类 标题 说明 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板。 容器(Container) 容器是独立运行的一个或一组应用。 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker安装.html":{"url":"chapter03/Docker安装.html","title":"Docker 安装","keywords":"","body":"Docker 安装 可以在任何操作系统上安装 Docker，无论是 Mac，Windows，Linux 还是任何云服务器。Docker 引擎在 Linux 发行版上运行。 在这里，我们将以 Linux Ubuntu Server 16.04 作为演示安装 Docker 引擎的过程。 前提条件 Docker 需要两个重要的安装要求： 它仅适用于 64 位 Linux 安装 它需要 Linux 内核版本 3.10 或更高版本。 要查看当前的内核版本，请打开终端并键入uname -r命令以查看内核版本： lusifer@UbuntuBase:~$ uname -r 4.4.0-21-generic 查看操作系统是32位还是64位： lusifer@UbuntuBase:~$ uname --m x86_64 使用脚本安装 Docker 使用在线安装脚本 curl -sSL https://get.daocloud.io/docker | sh 执行后会自动下载并安装 Docker 及依赖包 lusifer@UbuntuBase:~$ curl -sSL https://get.daocloud.io/docker | sh # Executing docker install script, commit: 49ee7c1 + sudo -E sh -c apt-get update -qq >/dev/null + sudo -E sh -c apt-get install -y -qq apt-transport-https ca-certificates curl software-properties-common >/dev/null + sudo -E sh -c curl -fsSL \"https://download.docker.com/linux/ubuntu/gpg\" | apt-key add -qq - >/dev/null + sudo -E sh -c echo \"deb [arch=amd64] https://download.docker.com/linux/ubuntu xenial edge\" > /etc/apt/sources.list.d/docker.list + [ ubuntu = debian ] + sudo -E sh -c apt-get update -qq >/dev/null + sudo -E sh -c apt-get install -y -qq --no-install-recommends docker-ce >/dev/null + sudo -E sh -c docker version Client: Version: 17.10.0-ce API version: 1.33 Go version: go1.8.3 Git commit: f4ffd25 Built: Tue Oct 17 19:04:16 2017 OS/Arch: linux/amd64 Server: Version: 17.10.0-ce API version: 1.33 (minimum version 1.12) Go version: go1.8.3 Git commit: f4ffd25 Built: Tue Oct 17 19:02:56 2017 OS/Arch: linux/amd64 Experimental: false If you would like to use Docker as a non-root user, you should now consider adding your user to the \"docker\" group with something like: sudo usermod -aG docker lusifer Remember that you will have to log out and back in for this to take effect! WARNING: Adding a user to the \"docker\" group will grant the ability to run containers which can be used to obtain root privileges on the docker host. Refer to https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface for more information. 完成后有个提示 If you would like to use Docker as a non-root user, you should now consider adding your user to the \"docker\" group with something like: sudo usermod -aG docker lusifer Remember that you will have to log out and back in for this to take effect! 当要以非 root 用户可以直接运行 docker 时，需要执行 sudo usermod -aG docker lusifer 命令，然后重新登陆，否则会有如下报错 lusifer@UbuntuBase:~$ docker run hello-world docker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post http://%2Fvar%2Frun%2Fdocker.sock/v1.33/containers/create: dial unix /var/run/docker.sock: connect: permission denied. See 'docker run --help'. 启动 Docker 后台服务 service docker start 查看 Docker 当前版本 lusifer@UbuntuBase:~$ docker version Client: Version: 17.10.0-ce API version: 1.33 Go version: go1.8.3 Git commit: f4ffd25 Built: Tue Oct 17 19:04:16 2017 OS/Arch: linux/amd64 Server: Version: 17.10.0-ce API version: 1.33 (minimum version 1.12) Go version: go1.8.3 Git commit: f4ffd25 Built: Tue Oct 17 19:02:56 2017 OS/Arch: linux/amd64 Experimental: false 配置加速器 由于网络原因，我们在 pull Image 的时候，从 Docker Hub 上下载会很慢... 所以，国内的 Docker 爱好者们就添加了一些国内的镜像 (mirror),方便大家使用。 修改配置文件 nano /lib/systemd/system/docker.service 添加 --registry-mirror=https://jxus37ac.mirror.aliyuncs.com 到 ExecStart： 保存配置：systemctl daemon-reload 重启服务：service docker restart Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker基本使用.html":{"url":"chapter03/Docker基本使用.html","title":"Docker 基本使用","keywords":"","body":"Docker 基本使用 第一个 Docker 应用程序 运行交互式的容器 以后台模式运行容器 停止容器 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:12 "},"chapter03/Docker基本使用/第一个Docker应用程序.html":{"url":"chapter03/Docker基本使用/第一个Docker应用程序.html","title":"第一个 Docker 应用程序","keywords":"","body":"第一个 Docker 应用程序 Docker 允许你在容器内运行应用程序，使用 docker run 命令来在容器内运行一个应用程序。 输出 Hello Docker： lusifer@UbuntuBase:~$ docker run ubuntu:15.10 /bin/echo \"Hello Docker\" Hello Docker 参数解释： docker：Docker 的二进制执行文件 run：与前面的 docker 组合来运行一个容器 ubuntu:15.10：指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像 /bin/echo \"Hello Docker\"：在启动的容器里执行的命令 以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo \"Hello Docker\"，然后输出结果。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker基本使用/运行交互式的容器.html":{"url":"chapter03/Docker基本使用/运行交互式的容器.html","title":"运行交互式的容器","keywords":"","body":"运行交互式的容器 我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现\"对话\"的能力 lusifer@UbuntuBase:~$ docker run -it ubuntu:15.10 /bin/bash root@76ab065de67b:/# 参数解释： -t：在新容器内指定一个伪终端或终端 -i：允许你对容器内的标准输入进行交互 此时我们已进入一个 ubuntu15.10 系统的容器 我们尝试在容器中运行命令 cat /proc/version 和 ls 分别查看当前系统的版本信息和当前目录下的文件列表 root@76ab065de67b:/# cat /proc/version Linux version 4.4.0-21-generic (buildd@lgw01-21) (gcc version 5.3.1 20160413 (Ubuntu 5.3.1-14ubuntu2) ) #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 root@76ab065de67b:/# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 退出容器： 运行 exit 使用 CTRL + D Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker基本使用/以后台模式运行容器.html":{"url":"chapter03/Docker基本使用/以后台模式运行容器.html","title":"以后台模式运行容器","keywords":"","body":"以后台模式运行容器 使用以下命令创建一个以进程方式运行的容器 lusifer@UbuntuBase:~$ docker run -d ubuntu:15.10 /bin/sh -c \"while true; do echo hello docker; sleep 1; done\" 0977407542d16c5699a2cc0455d977cb5d8ef011a1a762cdcf2323851f6b3ed3 在输出中，我们没有看到期望的\"hello docker\"，而是一串长字符 0977407542d16c5699a2cc0455d977cb5d8ef011a1a762cdcf2323851f6b3ed3 这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。 首先，我们需要确认容器有在运行，可以通过 docker ps 来查看 lusifer@UbuntuBase:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0977407542d1 ubuntu:15.10 \"/bin/sh -c 'while...\" 2 seconds ago Up 1 second thirsty_kowalevski CONTAINER ID：容器ID NAMES：自动分配的容器名称 在容器内使用 docker logs 命令，查看容器内的标准输出 lusifer@UbuntuBase:~$ docker logs 0977407542d1 hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker lusifer@UbuntuBase:~$ docker logs thirsty_kowalevski hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker hello docker 与正在运行的容器交互 docker exec -it /bin/bash Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker基本使用/停止容器.html":{"url":"chapter03/Docker基本使用/停止容器.html","title":"停止容器","keywords":"","body":"停止容器 lusifer@UbuntuBase:~$ docker stop thirsty_kowalevski thirsty_kowalevski lusifer@UbuntuBase:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES lusifer@UbuntuBase:~$ Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker容器管理.html":{"url":"chapter03/Docker容器管理.html","title":"Docker 容器管理","keywords":"","body":"Docker 容器管理 Docker 客户端 运行 WEB 容器 查看 WEB 容器 查看 WEB 应用日志 查看 WEB 应用容器的进程 检查 WEB 应用程序 重启 WEB 应用容器 移除 WEB 应用容器 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:12 "},"chapter03/Docker容器管理/Docker客户端.html":{"url":"chapter03/Docker容器管理/Docker客户端.html","title":"Docker 客户端","keywords":"","body":"Docker 客户端 docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。 lusifer@UbuntuBase:~$ docker Usage: docker COMMAND A self-sufficient runtime for containers Options: --config string Location of client config files (default \"/home/lusifer/.docker\") -D, --debug Enable debug mode --help Print usage -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (\"debug\"|\"info\"|\"warn\"|\"error\"|\"fatal\") (default \"info\") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default \"/home/lusifer/.docker/ca.pem\") --tlscert string Path to TLS certificate file (default \"/home/lusifer/.docker/cert.pem\") --tlskey string Path to TLS key file (default \"/home/lusifer/.docker/key.pem\") --tlsverify Use TLS and verify the remote -v, --version Print version information and quit Management Commands: config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images (experimental) volume Manage volumes Commands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry 可以通过命令 docker command --help 更深入的了解指定的 Docker 命令使用方法。 例如我们要查看 docker stats 指令的具体使用方法： lusifer@UbuntuBase:~$ docker stats --help Usage: docker stats [OPTIONS] [CONTAINER...] Display a live stream of container(s) resource usage statistics Options: -a, --all Show all containers (default shows just running) --format string Pretty-print images using a Go template --help Print usage --no-stream Disable streaming stats and only pull the first result --no-trunc Do not truncate output Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker容器管理/运行WEB容器.html":{"url":"chapter03/Docker容器管理/运行WEB容器.html","title":"运行 WEB 容器","keywords":"","body":"运行 WEB 容器 前面我们运行的容器并没有一些什么特别的用处。 接下来让我们尝试使用 docker 构建一个 web 应用程序。 我们将在 docker 容器中运行一个 Python Flask 应用来运行一个web应用。 lusifer@UbuntuBase:~$ docker run -d -P training/webapp python app.py d89a785788469da23529eebf70f1764611bb28818a8de7fa1ea85154327b807a 参数说明： -d：让容器在后台运行 -P：将容器内部使用的网络端口映射到我们使用的主机上 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker容器管理/查看WEB容器.html":{"url":"chapter03/Docker容器管理/查看WEB容器.html","title":"查看 WEB 容器","keywords":"","body":"查看 WEB 容器 使用 docker ps 来查看我们正在运行的容器 lusifer@UbuntuBase:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d89a78578846 training/webapp \"python app.py\" 2 minutes ago Up 2 minutes 0.0.0.0:32771->5000/tcp laughing_cori 这里多了端口信息 PORTS 0.0.0.0:32771->5000/tcp Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32771 上。 这时我们可以通过浏览器访问WEB应用 我们也可以指定 -p 标识来绑定指定端口 lusifer@UbuntuBase:~$ docker run -d -p 5000:5000 training/webapp python app.py 9490b017fdf6b8c6415d5d01b925413c6ed2dd782566d251ad2bdad90263c3cb lusifer@UbuntuBase:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9490b017fdf6 training/webapp \"python app.py\" 3 seconds ago Up 2 seconds 0.0.0.0:5000->5000/tcp amazing_archimedes Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker容器管理/查看WEB应用日志.html":{"url":"chapter03/Docker容器管理/查看WEB应用日志.html","title":"查看 WEB 应用日志","keywords":"","body":"查看 WEB 应用日志 docker logs [ID或者名字] 可以查看容器内部的标准输出： lusifer@UbuntuBase:~$ docker logs -f amazing_archimedes * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit) 192.168.75.1 - - [03/Nov/2017 06:14:05] \"GET / HTTP/1.1\" 200 - 192.168.75.1 - - [03/Nov/2017 06:14:05] \"GET /favicon.ico HTTP/1.1\" 404 - 192.168.75.1 - - [03/Nov/2017 06:16:57] \"GET / HTTP/1.1\" 200 - 192.168.75.1 - - [03/Nov/2017 06:16:57] \"GET /favicon.ico HTTP/1.1\" 404 - 参数说明： -f：让 dokcer logs 像使用 tail -f 一样来输出容器内部的标准输出 从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker容器管理/查看WEB应用容器的进程.html":{"url":"chapter03/Docker容器管理/查看WEB应用容器的进程.html","title":"查看 WEB 应用容器的进程","keywords":"","body":"查看 WEB 应用容器的进程 我们还可以使用 docker top 来查看容器内部运行的进程 lusifer@UbuntuBase:~$ docker top amazing_archimedes UID PID PPID C STIME TTY TIME CMD root 71917 71897 0 14:13 ? 00:00:00 python app.py Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker容器管理/检查WEB应用程序.html":{"url":"chapter03/Docker容器管理/检查WEB应用程序.html","title":"检查 WEB 应用程序","keywords":"","body":"检查 WEB 应用程序 使用 docker inspect 来查看Docker的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息： lusifer@UbuntuBase:~$ docker inspect amazing_archimedes [ { \"Id\": \"9490b017fdf6b8c6415d5d01b925413c6ed2dd782566d251ad2bdad90263c3cb\", \"Created\": \"2017-11-03T06:13:13.053498761Z\", \"Path\": \"python\", \"Args\": [ \"app.py\" ], \"State\": { \"Status\": \"running\", \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 71917, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2017-11-03T06:13:13.374235386Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, \"Image\": \"sha256:6fae60ef344644649a39240b94d73b8ba9c67f898ede85cf8e947a887b3e6557\", \"ResolvConfPath\": \"/var/lib/docker/containers/9490b017fdf6b8c6415d5d01b925413c6ed2dd782566d251ad2bdad90263c3cb/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/9490b017fdf6b8c6415d5d01b925413c6ed2dd782566d251ad2bdad90263c3cb/hostname\", \"HostsPath\": \"/var/lib/docker/containers/9490b017fdf6b8c6415d5d01b925413c6ed2dd782566d251ad2bdad90263c3cb/hosts\", \"LogPath\": \"/var/lib/docker/containers/9490b017fdf6b8c6415d5d01b925413c6ed2dd782566d251ad2bdad90263c3cb/9490b017fdf6b8c6415d5d01b925413c6ed2dd782566d251ad2bdad90263c3cb-json.log\", \"Name\": \"/amazing_archimedes\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"MountLabel\": \"\", \"ProcessLabel\": \"\", \"AppArmorProfile\": \"docker-default\", \"ExecIDs\": null, \"HostConfig\": { \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": { \"Type\": \"json-file\", \"Config\": {} }, \"NetworkMode\": \"default\", \"PortBindings\": { \"5000/tcp\": [ { \"HostIp\": \"\", \"HostPort\": \"5000\" } ] }, ... Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker容器管理/重启WEB应用容器.html":{"url":"chapter03/Docker容器管理/重启WEB应用容器.html","title":"重启 WEB 应用容器","keywords":"","body":"重启 WEB 应用容器 停止WEB应用容器 docker stop amazing_archimedes 已经停止的容器，我们可以使用命令 docker start 来启动 docker start amazing_archimedes 重启WEB应用容器 docker restart amazing_archimedes 查询全部容器 docker ps -a 查询最后一次创建的容器 docker ps -l Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker容器管理/移除WEB应用容器.html":{"url":"chapter03/Docker容器管理/移除WEB应用容器.html","title":"移除 WEB 应用容器","keywords":"","body":"移除 WEB 应用容器 我们可以使用 docker rm 命令来删除不需要的容器： lusifer@UbuntuBase:~$ docker rm 9490b017fdf6 5198a90e2406 d89a78578846 435db4b99464 76aafa3bb20d 0977407542d1 9490b017fdf6 5198a90e2406 d89a78578846 435db4b99464 76aafa3bb20d 0977407542d1 注意：删除容器时，容器必须是停止状态，否则会报错 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker镜像管理.html":{"url":"chapter03/Docker镜像管理.html","title":"Docker 镜像管理","keywords":"","body":"Docker 镜像管理 当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。 镜像列表 获取镜像 查找镜像 创建镜像 更新镜像 Dockerfile 设置镜像标签 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:12 "},"chapter03/Docker镜像管理/镜像列表.html":{"url":"chapter03/Docker镜像管理/镜像列表.html","title":"镜像列表","keywords":"","body":"镜像列表 我们可以使用 docker images 来列出本地主机上的镜像： lusifer@UbuntuBase:~$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 15.10 9b9cb95443b5 15 months ago 137MB training/webapp latest 6fae60ef3446 2 years ago 349MB 选项说明： REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有15.10、14.04等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。 所以，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下： docker run -it ubuntu:15.10 /bin/bash 如果要使用版本为14.04的ubuntu系统镜像来运行容器时，命令如下： docker run -it ubuntu:14.04 /bin/bash 如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker镜像管理/获取镜像.html":{"url":"chapter03/Docker镜像管理/获取镜像.html","title":"获取镜像","keywords":"","body":"获取镜像 当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。 lusifer@UbuntuBase:~$ docker pull ubuntu:14.04 14.04: Pulling from library/ubuntu bae382666908: Pull complete 29ede3c02ff2: Pull complete da4e69f33106: Pull complete 8d43e5f5d27f: Pull complete b0de1abb17d6: Pull complete Digest: sha256:6e3e3f3c5c36a91ba17ea002f63e5607ed6a8c8e5fbbddb31ad3e15638b51ebc Status: Downloaded newer image for ubuntu:14.04 下载完成后，我们可以直接使用这个镜像来运行容器。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker镜像管理/查找镜像.html":{"url":"chapter03/Docker镜像管理/查找镜像.html","title":"查找镜像","keywords":"","body":"查找镜像 我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： https://hub.docker.com/ 我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。 lusifer@UbuntuBase:~$ docker search ubuntu NAME DESCRIPTION STARS OFFICIAL AUTOMATED ubuntu Ubuntu is a Debian-based Linux operating s... 6759 [OK] dorowu/ubuntu-desktop-lxde-vnc Ubuntu with openssh-server and NoVNC 141 [OK] rastasheep/ubuntu-sshd Dockerized SSH service, built on top of of... 114 [OK] ansible/ubuntu14.04-ansible Ubuntu 14.04 LTS with ansible 88 [OK] ubuntu-upstart Upstart is an event-based replacement for ... 80 [OK] neurodebian NeuroDebian provides neuroscience research... 40 [OK] ubuntu-debootstrap debootstrap --variant=minbase --components... 32 [OK] nuagebec/ubuntu Simple always updated Ubuntu docker images... 22 [OK] tutum/ubuntu Simple Ubuntu docker images with SSH access 19 1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5 ubuntu-16-nginx-php-phpmyadmin-mysql-5 17 [OK] ppc64le/ubuntu Ubuntu is a Debian-based Linux operating s... 11 aarch64/ubuntu Ubuntu is a Debian-based Linux operating s... 9 i386/ubuntu Ubuntu is a Debian-based Linux operating s... 8 darksheer/ubuntu Base Ubuntu Image -- Updated hourly 3 [OK] codenvy/ubuntu_jdk8 Ubuntu, JDK8, Maven 3, git, curl, nmap, mc... 3 [OK] 1and1internet/ubuntu-16-nginx-php-5.6-wordpress-4 ubuntu-16-nginx-php-5.6-wordpress-4 2 [OK] 1and1internet/ubuntu-16-apache-php-7.0 ubuntu-16-apache-php-7.0 1 [OK] smartentry/ubuntu ubuntu with smartentry 0 [OK] 1and1internet/ubuntu-16-healthcheck ubuntu-16-healthcheck 0 [OK] pivotaldata/ubuntu-gpdb-dev Ubuntu images for GPDB development 0 thatsamguy/ubuntu-build-image Docker webapp build images based on Ubuntu 0 ossobv/ubuntu Custom ubuntu image from scratch (based on... 0 1and1internet/ubuntu-16-sshd ubuntu-16-sshd 0 [OK] pivotaldata/ubuntu A quick freshening-up of the base Ubuntu d... 0 defensative/socat-ubuntu 0 [OK] 说明： NAME：镜像仓库源的名称 DESCRIPTION：镜像的描述 OFFICIAL：是否docker官方发布 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker镜像管理/创建镜像.html":{"url":"chapter03/Docker镜像管理/创建镜像.html","title":"创建镜像","keywords":"","body":"创建镜像 当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改： 从已经创建的容器中更新镜像，并且提交这个镜像 使用 Dockerfile 指令来创建一个新的镜像 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker镜像管理/更新镜像.html":{"url":"chapter03/Docker镜像管理/更新镜像.html","title":"更新镜像","keywords":"","body":"更新镜像 更新镜像之前，我们需要使用镜像来创建一个容器： lusifer@UbuntuBase:~$ docker run -it ubuntu:15.10 /bin/bash root@9a3dcafd7a83:/# apt-get update Ign http://archive.ubuntu.com wily InRelease Ign http://archive.ubuntu.com wily-updates InRelease Ign http://archive.ubuntu.com wily-security InRelease Ign http://archive.ubuntu.com wily Release.gpg Ign http://archive.ubuntu.com wily-updates Release.gpg Ign http://archive.ubuntu.com wily-security Release.gpg Ign http://archive.ubuntu.com wily Release Ign http://archive.ubuntu.com wily-updates Release Ign http://archive.ubuntu.com wily-security Release 在运行的容器内使用 apt-get update 命令进行更新。 在完成操作之后，输入 exit 命令来退出这个容器。 此时ID为 9a3dcafd7a83 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。 lusifer@UbuntuBase:~$ docker commit -m=\"has update\" -a=\"lusifer\" 9a3dcafd7a83 lusifer/ubuntu:v2 sha256:2642b4944b285974e5f007f30bc33b651220ea9931982c3c53b61a8f8fd5011b 各个参数说明： -m：提交的描述信息 -a：指定镜像作者 9a3dcafd7a83：容器ID lusifer/ubuntu:v2：指定要创建的目标镜像名 我们可以使用 docker images 命令来查看我们的新镜像 lusifer/ubuntu:v2： lusifer@UbuntuBase:~$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE lusifer/ubuntu v2 2642b4944b28 2 minutes ago 137MB ubuntu 14.04 dea1945146b9 7 weeks ago 188MB ubuntu 15.10 9b9cb95443b5 15 months ago 137MB training/webapp latest 6fae60ef3446 2 years ago 349MB 使用我们的新镜像 lusifer/ubuntu 来启动一个容器： lusifer@UbuntuBase:~$ docker run -it lusifer/ubuntu:v2 /bin/bash root@060f7af5fbec:/# Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker镜像管理/Dockerfile.html":{"url":"chapter03/Docker镜像管理/Dockerfile.html","title":"Dockerfile","keywords":"","body":"Dockerfile Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。 docker build 命令用于从Dockerfile构建映像。可以在 docker build 命令中使用 -f 标志指向文件系统中任何位置的Dockerfile。 docker build -f /path/to/a/Dockerfile Dockerfile文件说明 说明不区分大小写，但必须遵循建议使用大写字母的约定。 Docker 以从上到下的顺序运行 Dockerfile 的指令。为了指定基本映像，第一条指令必须是 FROM。 一个声明以＃字符开头则被视为注释。可以在Docker文件中使用RUN，CMD，FROM，EXPOSE，ENV等指令。 在这里列出了一些常用的说明。 FROM 该指令用于设置后续指令的基本映像。有效的 Dockerfile 必须使用FROM作为其第一条指令。 FROM ubuntu MAINTAINER 指定镜像的作者 MAINTAINER RUN 该指令用于执行当前映像的任何命令。 RUN /bin/bash -c 'echo \"Hello World\"' CMD 这用于执行映像的应用程序。应该以下列形式总是使用CMD CMD [\"executable\", \"param1\", \"param2\"] 这是使用CMD的首选方法。Dockerfile文件中只能有一个CMD。如果使用多个CMD，则只会执行最后一个CMD。 例：CMD [“/bin/echo”, “this is a echo test ”] COPY 该指令用于将来自源的新文件或目录复制到目的地的容器的文件系统。 COPY abc/ /xyz 规则： source路径必须在构建的上下文之内。无法使用COPY ../something /something，因为docker构建的第一步是将上下文目录(和子目录)发送到 docker 守护程序。 如果source是目录，则会复制目录的全部内容，包括文件系统元数据。 WORKDIR WORKDIR用于为Dockerfile中的RUN，CMD和COPY指令设置工作目录。如果工作目录不存在，它默认将会创建。 我们可以在Dockerfile文件中多次使用WORKDIR。 备注：可以简单理解为 cd 命令，但是如果目录不存在它会自动创建。 构建镜像 我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。 root@UbuntuBase:/usr/local/docker/ubuntu# cat Dockerfile FROM ubuntu MAINTAINER Lusifer RUN /bin/echo 'root:123456' |chpasswd RUN useradd lusifer RUN /bin/echo 'lusifer:123456' |chpasswd RUN /bin/echo -e \"LANG=\\\"en_US.UTF-8\\\"\" >/etc/default/local EXPOSE 22 EXPOSE 80 CMD /usr/sbin/sshd -D 每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。 第一条FROM，指定使用哪个镜像源 RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。 然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。 root@UbuntuBase:/usr/local/docker/ubuntu# docker build -t lusifer/ubuntu:latest . Sending build context to Docker daemon 2.048kB Step 1/9 : FROM ubuntu latest: Pulling from library/ubuntu ae79f2514705: Pull complete 5ad56d5fc149: Pull complete 170e558760e8: Pull complete 395460e233f5: Pull complete 6f01dc62e444: Pull complete Digest: sha256:506e2d5852de1d7c90d538c5332bd3cc33b9cbd26f6ca653875899c505c82687 Status: Downloaded newer image for ubuntu:latest ---> 747cb2d60bbe Step 2/9 : MAINTAINER Lusifer ---> Running in bdfec0486691 ---> 40da56c4c0ad Step 3/9 : RUN /bin/echo 'root:123456' |chpasswd ---> Running in 5baae880ffce ---> bc898d1fc903 Step 4/9 : RUN useradd lusifer ---> Running in 83b9ca8c7e59 ---> 0e52bfd4fdec Step 5/9 : RUN /bin/echo 'lusifer:123456' |chpasswd ---> Running in 8e04b80de324 ---> 229189d4fce2 Step 6/9 : RUN /bin/echo -e \"LANG=\\\"en_US.UTF-8\\\"\" >/etc/default/local ---> Running in 36c09a3d36f4 ---> dc2b33c0216e Step 7/9 : EXPOSE 22 ---> Running in 19b391acb5d8 ---> 7a9a0480fb19 Step 8/9 : EXPOSE 80 ---> Running in fed8dad6ac5f ---> 70ff9da03753 Step 9/9 : CMD /usr/sbin/sshd -D ---> Running in fa89f7d2f1dc ---> 6cdd9c6b840d Removing intermediate container 8e04b80de324 Removing intermediate container 36c09a3d36f4 Removing intermediate container 19b391acb5d8 Removing intermediate container fed8dad6ac5f Removing intermediate container fa89f7d2f1dc Removing intermediate container bdfec0486691 Removing intermediate container 5baae880ffce Removing intermediate container 83b9ca8c7e59 Successfully built 6cdd9c6b840d Successfully tagged lusifer/ubuntu:latest 参数说明： -t：指定要创建的目标镜像名 .：Dockerfile 文件所在目录，可以指定 Dockerfile 的绝对路径 使用 docker images 查看创建的镜像已经在列表中存在,镜像ID为 6cdd9c6b840d root@UbuntuBase:/usr/local/docker/ubuntu# docker images REPOSITORY TAG IMAGE ID CREATED SIZE lusifer/ubuntu latest 6cdd9c6b840d 3 minutes ago 122MB lusifer/ubuntu v2 2642b4944b28 About an hour ago 137MB ubuntu latest 747cb2d60bbe 3 weeks ago 122MB ubuntu 14.04 dea1945146b9 7 weeks ago 188MB ubuntu 15.10 9b9cb95443b5 15 months ago 137MB training/webapp latest 6fae60ef3446 2 years ago 349MB 我们可以使用新的镜像来创建容器 root@UbuntuBase:/usr/local/docker/ubuntu# docker run -it lusifer/ubuntu /bin/bash root@f68cc2d65679:/# id lusifer uid=1000(lusifer) gid=1000(lusifer) groups=1000(lusifer) 从上面看到新镜像已经包含我们创建的用户 lusifer Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker镜像管理/设置镜像标签.html":{"url":"chapter03/Docker镜像管理/设置镜像标签.html","title":"设置镜像标签","keywords":"","body":"设置镜像标签 我们可以使用 docker tag 命令，为镜像添加一个新的标签。 docker tag 6cdd9c6b840d lusifer/ubuntu:dev docker tag 镜像ID，这里是 6cdd9c6b840d ，用户名称、镜像源名(repository name)和新的标签名(tag)。 使用 docker images 命令可以看到，ID为 6cdd9c6b840d 的镜像多一个标签。 root@UbuntuBase:/usr/local/docker/ubuntu# docker images REPOSITORY TAG IMAGE ID CREATED SIZE lusifer/ubuntu dev 6cdd9c6b840d 15 minutes ago 122MB lusifer/ubuntu latest 6cdd9c6b840d 15 minutes ago 122MB lusifer/ubuntu v2 2642b4944b28 About an hour ago 137MB ubuntu latest 747cb2d60bbe 3 weeks ago 122MB ubuntu 14.04 dea1945146b9 7 weeks ago 188MB ubuntu 15.10 9b9cb95443b5 15 months ago 137MB training/webapp latest 6fae60ef3446 2 years ago 349MB Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker实例教程.html":{"url":"chapter03/Docker实例教程.html","title":"Docker 实例教程","keywords":"","body":"Docker 实例教程 Docker 安装 Tomcat Docker 安装 MySQL Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:12 "},"chapter03/Docker实例教程/Docker安装Tomcat.html":{"url":"chapter03/Docker实例教程/Docker安装Tomcat.html","title":"Docker 安装 Tomcat","keywords":"","body":"Docker 安装 Tomcat 查找 Docker Hub 上的 Tomcat 镜像 root@UbuntuBase:/usr/local/docker/tomcat# docker search tomcat NAME DESCRIPTION STARS OFFICIAL AUTOMATED tomcat Apache Tomcat is an open source implementa... 1550 [OK] dordoka/tomcat Ubuntu 14.04, Oracle JDK 8 and Tomcat 8 ba... 43 [OK] tomee Apache TomEE is an all-Apache Java EE cert... 42 [OK] davidcaste/alpine-tomcat Apache Tomcat 7/8 using Oracle Java 7/8 wi... 21 [OK] consol/tomcat-7.0 Tomcat 7.0.57, 8080, \"admin/admin\" 16 [OK] cloudesire/tomcat Tomcat server, 6/7/8 15 [OK] maluuba/tomcat7 9 [OK] tutum/tomcat Base docker image to run a Tomcat applicat... 8 jeanblanchard/tomcat Minimal Docker image with Apache Tomcat 8 andreptb/tomcat Debian Jessie based image with Apache Tomc... 7 [OK] bitnami/tomcat Bitnami Tomcat Docker Image 5 [OK] aallam/tomcat-mysql Debian, Oracle JDK, Tomcat & MySQL 4 [OK] antoineco/tomcat-mod_cluster Apache Tomcat with JBoss mod_cluster 1 [OK] maluuba/tomcat7-java8 Tomcat7 with java8. 1 amd64/tomcat Apache Tomcat is an open source implementa... 1 primetoninc/tomcat Apache tomcat 8.5, 8.0, 7.0 1 [OK] trollin/tomcat 0 fabric8/tomcat-8 Fabric8 Tomcat 8 Image 0 [OK] awscory/tomcat tomcat 0 oobsri/tomcat8 Testing CI Jobs with different names. 0 hegand/tomcat docker-tomcat 0 [OK] s390x/tomcat Apache Tomcat is an open source implementa... 0 ppc64le/tomcat Apache Tomcat is an open source implementa... 0 99taxis/tomcat7 Tomcat7 0 [OK] qminderapp/tomcat7 Tomcat 7 0 这里我们拉取官方的镜像 docker pull tomcat 等待下载完成后，我们就可以在本地镜像列表里查到 REPOSITORY 为 tomcat 的镜像。 运行容器： docker run --name tomcat -p 8080:8080 -v $PWD/test:/usr/local/tomcat/webapps/test -d tomcat 命令说明： -p 8080:8080：将容器的8080端口映射到主机的8080端口 -v $PWD/test:/usr/local/tomcat/webapps/test：将主机中当前目录下的test挂载到容器的/test 查看容器启动情况 root@UbuntuBase:/usr/local/docker/tomcat/webapps# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 38498e53128c tomcat \"catalina.sh run\" 2 minutes ago Up 2 minutes 0.0.0.0:8080->8080/tcp tomcat 通过浏览器访问 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker实例教程/Docker安装MySQL.html":{"url":"chapter03/Docker实例教程/Docker安装MySQL.html","title":"Docker 安装 MySQL","keywords":"","body":"Docker 安装 MySQL 查找 Docker Hub 上的 MySQL 镜像 root@UbuntuBase:/usr/local/docker/mysql# docker search mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relati... 5177 [OK] mariadb MariaDB is a community-developed fork of M... 1602 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Crea... 361 [OK] percona Percona Server is a fork of the MySQL rela... 298 [OK] hypriot/rpi-mysql RPi-compatible Docker Image with Mysql 72 zabbix/zabbix-server-mysql Zabbix Server with MySQL database support 62 [OK] centurylink/mysql Image containing mysql. Optimized to be li... 53 [OK] sameersbn/mysql 48 [OK] zabbix/zabbix-web-nginx-mysql Zabbix frontend based on Nginx web-server ... 36 [OK] tutum/mysql Base docker image to run a MySQL database ... 27 1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5 ubuntu-16-nginx-php-phpmyadmin-mysql-5 17 [OK] schickling/mysql-backup-s3 Backup MySQL to S3 (supports periodic back... 16 [OK] centos/mysql-57-centos7 MySQL 5.7 SQL database server 15 linuxserver/mysql A Mysql container, brought to you by Linux... 12 centos/mysql-56-centos7 MySQL 5.6 SQL database server 6 openshift/mysql-55-centos7 DEPRECATED: A Centos7 based MySQL v5.5 ima... 6 frodenas/mysql A Docker Image for MySQL 3 [OK] dsteinkopf/backup-all-mysql backup all DBs in a mysql server 3 [OK] circleci/mysql MySQL is a widely used, open-source relati... 2 cloudposse/mysql Improved `mysql` service with support for ... 0 [OK] astronomerio/mysql-sink MySQL sink 0 [OK] ansibleplaybookbundle/rhscl-mysql-apb An APB which deploys RHSCL MySQL 0 [OK] cloudfoundry/cf-mysql-ci Image used in CI of cf-mysql-release 0 astronomerio/mysql-source MySQL source 0 [OK] jenkler/mysql Docker Mysql package 0 这里我们拉取官方的镜像 docker pull mysql 等待下载完成后，我们就可以在本地镜像列表里查到 REPOSITORY 为 mysql 的镜像 运行容器： docker run -p 3306:3306 --name mysql \\ -v /usr/local/docker/mysql/conf:/etc/mysql \\ -v /usr/local/docker/mysql/logs:/var/log/mysql \\ -v /usr/local/docker/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -d mysql 命令参数： -p 3306:3306：将容器的3306端口映射到主机的3306端口 -v /usr/local/docker/mysql/conf:/etc/mysql：将主机当前目录下的 conf 挂载到容器的 /etc/mysql -v /usr/local/docker/mysql/logs:/var/log/mysql：将主机当前目录下的 logs 目录挂载到容器的 /var/log/mysql -v /usr/local/docker/mysql/data:/var/lib/mysql：将主机当前目录下的 data 目录挂载到容器的 /var/lib/mysql -e MYSQL\\_ROOT\\_PASSWORD=123456：初始化root用户的密码 查看容器启动情况 root@UbuntuBase:/usr/local/docker/mysql# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bc49c9de4cdf mysql:latest \"docker-entrypoint...\" 4 minutes ago Up 4 minutes 0.0.0.0:3306->3306/tcp mysql 使用客户端工具连接 MySQL Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker部署应用.html":{"url":"chapter03/Docker部署应用.html","title":"Docker 部署应用","keywords":"","body":"Docker 部署应用 上传应用到服务器 创建 Dockerfile FROM tomcat MAINTAINER Lusifer ADD app.war /usr/local/tomcat/webapps/app.war 构建镜像 docker build -t lusifer/tomcat . 启动容器 docker run --name tomcat -p 8080:8080 lusifer/tomcat Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker数据卷.html":{"url":"chapter03/Docker数据卷.html","title":"Docker 数据卷","keywords":"","body":"Docker 数据卷 数据卷简介 创建数据卷 备份数据卷 恢复数据卷 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:12 "},"chapter03/Docker数据卷/数据卷简介.html":{"url":"chapter03/Docker数据卷/数据卷简介.html","title":"数据卷简介","keywords":"","body":"数据卷简介 数据卷是一个可以供一个或多个容器使用的特殊目录。 可以达到以下目的： 绕过“拷贝写”系统，以达到本地磁盘 IO 的性能，（比如运行一个容器，在容器中对数据卷修改内容，会直接改变宿主机上的数据卷中的内容，所以是本地磁盘IO的性能，而不是先在容器中写一份，最后还要将容器中的修改的内容拷贝出来进行同步。） 绕过“拷贝写”系统，有些文件不需要在 docker commit 打包进镜像文件。 在多个容器间共享目录。 在宿主和容器间共享目录。 在宿主和容器间共享一个文件。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker数据卷/创建数据卷.html":{"url":"chapter03/Docker数据卷/创建数据卷.html","title":"创建数据卷","keywords":"","body":"创建数据卷 方法一：dockerfile 中指定 VOLUME 后的目录，如 VOLUME /var/lib/test 方法二：docker run 命令中加 -v 选项。如： docker run -d -P -v /webapp training/webapp python app.py 注意： 这里定义的 /webapp 数据卷，但是不知道宿主机上与之对应的在哪里。我们需要仔细的观察 docker inspect 的结果，是非常长的一段东西。在这里我只摘出我们需要的部分： \"Mounts\": [ { \"Type\": \"volume\", \"Name\": \"ae15b45565ac99bc8f770b226684f7ef707eb8a4d9b8111a0e6b8410ab7b7942\", \"Source\": \"/var/lib/docker/volumes/ae15b45565ac99bc8f770b226684f7ef707eb8a4d9b8111a0e6b8410ab7b7942/_data\", \"Destination\": \"/webapp\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" } ] \"Volumes\": { \"/webapp\": {} } 注意： 这里 “Name”: “ae15b45565ac99bc8f770b226684f7ef707eb8a4d9b8111a0e6b8410ab7b7942”，这个并不是容器 id 而是数据卷的 ID，我们可以在 /var/lib/docker/volumes/ 下找到名子为这个数字的目录。它就是我们数据卷在宿主机上对应的目录。 直接挂载宿主机目录 docker run -d -P -v /usr/local/docker/python/webapp:/webapp training/webapp python app.py Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker数据卷/备份数据卷.html":{"url":"chapter03/Docker数据卷/备份数据卷.html","title":"备份数据卷","keywords":"","body":"备份数据卷 这其实是利用 tar 命令来执行的。 备份的原理：使用 tar -zcvf 对数据卷打包压缩 创建一个 MySQL 容器： docker run -p 3306:3306 --name mysql \\ -v /usr/local/docker/mysql/conf:/etc/mysql \\ -v /usr/local/docker/mysql/logs:/var/log/mysql \\ -v /usr/local/docker/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -d mysql 进入 /usr/local/docker/mysql 目录，使用 tar -zxvf backup.tar.gz . 打包当前目录，即可得到一个压缩包，这个压缩包就是我们需要的备份数据。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter03/Docker数据卷/恢复数据卷.html":{"url":"chapter03/Docker数据卷/恢复数据卷.html","title":"恢复数据卷","keywords":"","body":"恢复数据卷 解压缩备份数据压缩包 tar -zxvf backup.tar.gz 重新启动一个新的容器并将数据卷指向需要还原的数据卷目录 docker run -p 3306:3306 --name mysql \\ -v /usr/local/docker/mysql/backup/conf:/etc/mysql \\ -v /usr/local/docker/mysql/backup/logs:/var/log/mysql \\ -v /usr/local/docker/mysql/backup/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -d mysql Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter04/DockerCompose.html":{"url":"chapter04/DockerCompose.html","title":"Docker Compose","keywords":"","body":"Docker Compose Docker Compose 简介 Docker Compose 安装 Docker Compose 使用 Docker Compose 命令 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:23 "},"chapter04/DockerCompose/DockerCompose简介.html":{"url":"chapter04/DockerCompose/DockerCompose简介.html","title":"Docker Compose 简介","keywords":"","body":"Docker Compose 简介 Docker Compose 是一种用于通过使用单个命令创建和启动 Docker 应用程序的工具。我们可以使用它来配置应用程序的服务。 它是开发，测试和升级环境的利器。 它提供以下命令来管理应用程序的整个生命周期： 启动，停止和重建服务 查看运行服务的状态 流式运行服务的日志输出 在服务上运行一次性命令 要实现 docker compose，需要包括以下步骤： 将应用程序环境变量放在 Docker 文件中以公开访问。 在 docker-compose.yml 文件中提供和配置服务名称，以便它们可以在隔离的环境中一起运行。 运行 docker-compose 将启动并运行整个应用程序。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter04/DockerCompose/DockerCompose安装.html":{"url":"chapter04/DockerCompose/DockerCompose安装.html","title":"Docker Compose 安装","keywords":"","body":"Docker Compose 安装 以下是在 Ubuntu 系统中安装 Docker Compose 的说明： curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 以下是下载进度： % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 617 0 617 0 0 168 0 --:--:-- 0:00:03 --:--:-- 168 100 8649k 100 8649k 0 0 15651 0 0:09:25 0:09:25 --:--:-- 10383 给 docker-compose 添加执行的权限： sudo chmod +x /usr/local/bin/docker-compose 查看 docker-compose 的版本 docker-compose version Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter04/DockerCompose/DockerCompose使用.html":{"url":"chapter04/DockerCompose/DockerCompose使用.html","title":"Docker Compose 使用","keywords":"","body":"Docker Compose 使用 创建一个 docker-compose.yml 配置文件： version: '3' services: webapp: restart: always image: training/webapp container_name: webapp ports: - 5000:5000 参数说明： version：指定脚本语法解释器版本 services：要启动的服务列表 webapp：服务名称，可以随便起名，不重复即可 restart：启动方式，这里的 always 表示总是启动，即使服务器重启了也会立即启动服务 image：镜像的名称，默认从 Docker Hub 下载 container_name：容器名称，可以随便起名，不重复即可 ports：端口映射列列表，左边为宿主机端口，右边为容器端口 前台运行： lusifer@UbuntuBase:/usr/local/docker/python$ docker-compose up Creating network \"python_default\" with the default driver Creating webapp ... Creating webapp ... done Attaching to webapp webapp | * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit) 后台运行： lusifer@UbuntuBase:/usr/local/docker/python$ docker-compose up -d Creating webapp ... Creating webapp ... done lusifer@UbuntuBase:/usr/local/docker/python$ 运行效果： Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter04/DockerCompose/DockerCompose命令.html":{"url":"chapter04/DockerCompose/DockerCompose命令.html","title":"Docker Compose 命令","keywords":"","body":"Docker Compose 命令 前台运行 docker-compose up 后台运行 docker-compose up -d 启动 docker-compose start 停止 docker-compose stop 停止并移除容器 docker-compose down Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter04/DockerCompose实例教程.html":{"url":"chapter04/DockerCompose实例教程.html","title":"Docker Compose 实例教程","keywords":"","body":"Docker Compose 实例教程 Docker Compose 运行 Tomcat Docker Compose 运行 MySQL Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:22 "},"chapter04/DockerCompose实例教程/DockerCompose运行Tomcat.html":{"url":"chapter04/DockerCompose实例教程/DockerCompose运行Tomcat.html","title":"Docker Compose 运行 Tomcat","keywords":"","body":"Docker Compose 运行 Tomcat docker-compose.yml 配置文件： version: '3' services: tomcat: restart: always image: tomcat container_name: tomcat ports: - 8080:8080 volumes: - /usr/local/docker/tomcat/webapps/test:/usr/local/tomcat/webapps/test environment: TZ: Asia/Shanghai Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter04/DockerCompose实例教程/DockerCompose运行MySQL.html":{"url":"chapter04/DockerCompose实例教程/DockerCompose运行MySQL.html","title":"Docker Compose 运行 MySQL","keywords":"","body":"Docker Compose 运行 MySQL docker-compose.yml 配置文件： version: '3' services: mysql: restart: always image: mysql container_name: mysql ports: - 3306:3306 environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123456 command: --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 --max_allowed_packet=128M --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\" volumes: - mysql-data:/var/lib/mysql volumes: mysql-data: Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter04/附录.html":{"url":"chapter04/附录.html","title":"附录","keywords":"","body":"附录 YAML 配置文件语言 Docker Compose 配置文件详解 Docker 常用命令 Docker 资源汇总 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:22 "},"chapter04/附录/YAML配置文件语言.html":{"url":"chapter04/附录/YAML配置文件语言.html","title":"YAML 配置文件语言","keywords":"","body":"YAML 配置文件语言 简介 YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。 YAML 语言的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。它的基本语法规则如下： 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略。 YAML 支持的数据结构有三种： 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 对象 对象的一组键值对，使用冒号结构表示 animal: pets 数组 一组连词线开头的行，构成一个数组 - Cat - Dog - Goldfish 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格 - - Cat - Dog - Goldfish 复合结构 对象和数组可以结合使用，形成复合结构 languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 纯量 纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量 字符串 布尔值 整数 浮点数 Null 时间 日期 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter04/附录/DockerCompose配置文件详解.html":{"url":"chapter04/附录/DockerCompose配置文件详解.html","title":"Docker Compose 配置文件详解","keywords":"","body":"Docker Compose 配置文件详解 image services: web: image: hello-world 在 services 标签下的第二级标签是 web，这个名字是用户自己自定义，它就是服务名称。 image 则是指定服务的镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 build 服务除了可以基于指定的镜像，还可以基于一份 Dockerfile，在使用 up 启动之时执行构建任务，这个构建标签就是 build，它可以指定 Dockerfile 所在文件夹的路径。Compose 将会利用它自动构建这个镜像，然后使用这个镜像启动服务容器。 build: /path/to/build/dir 也可以是相对路径，只要上下文确定就可以读取到 Dockerfile build: ./dir 设定上下文根目录，然后以该目录为准指定 Dockerfile build: context: ../ dockerfile: path/of/Dockerfile 注意 build 都是一个目录，如果你要指定 Dockerfile 文件需要在 build 标签的子级标签中使用 dockerfile 标签指定，如上面的例子。 如果你同时指定了 image 和 build 两个标签，那么 Compose 会构建镜像并且把镜像命名为 image 后面的那个名字。 build: ./dir image: webapp:tag 既然可以在 docker-compose.yml 中定义构建任务，那么一定少不了 arg 这个标签，就像 Dockerfile 中的 ARG 指令，它可以在构建过程中指定环境变量，但是在构建成功后取消，在 docker-compose.yml 文件中也支持这样的写法： build: context: . args: buildno: 1 password: secret 下面这种写法也是支持的，一般来说下面的写法更适合阅读 build: context: . args: - buildno=1 - password=secret 与 ENV 不同的是，ARG 是允许空值的。例如： args: - buildno - password 这样构建过程可以向它们赋值 注意：YAML 的布尔值（true, false, yes, no, on, off）必须要使用引号引起来（单引号、双引号均可），否则会当成字符串解析。 command 使用 command 可以覆盖容器启动后默认执行的命令。 command: bundle exec thin -p 3000 也可以写成类似 Dockerfile 中的格式： command: [bundle, exec, thin, -p, 3000] container_name 前面说过 Compose 的容器名称格式是： 虽然可以自定义项目名称、服务名称，但是如果你想完全控制容器的命名，可以使用这个标签指定： container_name: app 这样容器的名字就指定为 app 了。 depends_on 在使用 Compose 时，最大的好处就是少打启动命令，但是一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。 例如在没启动数据库容器的时候启动了应用容器，这时候应用容器会因为找不到数据库而退出，为了避免这种情况我们需要加入一个标签，就是 depends_on，这个标签解决了容器的依赖、启动先后的问题。 例如下面容器会先启动 redis 和 db 两个服务，最后才启动 web 服务： version: '2' services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意的是，默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系。 dns 和 --dns 参数一样用途，格式如下： dns: 8.8.8.8 也可以是一个列表： dns: - 8.8.8.8 - 9.9.9.9 此外 dns_search 的配置也类似： dns_search: example.com dns_search: - dc1.example.com - dc2.example.com tmpfs 挂载临时目录到容器内部，与 run 的参数一样效果： tmpfs: /run tmpfs: - /run - /tmp entrypoint 在 Dockerfile 中有一个指令叫做 ENTRYPOINT 指令，用于指定接入点，第四章有对比过与 CMD 的区别。 在 docker-compose.yml 中可以定义接入点，覆盖 Dockerfile 中的定义： entrypoint: /code/entrypoint.sh 格式和 Docker 类似，不过还可以写成这样： entrypoint: - php - -d - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so - -d - memory_limit=-1 - vendor/bin/phpunit env_file 还记得前面提到的 .env 文件吧，这个文件可以设置 Compose 的变量。而在 docker-compose.yml 中可以定义一个专门存放变量的文件。 如果通过 docker-compose -f FILE 指定了配置文件，则 env_file 中路径会使用配置文件路径。 如果有变量名称与 environment 指令冲突，则以后者为准。格式如下： env_file: .env 或者根据 docker-compose.yml 设置多个： env_file: - ./common.env - ./apps/web.env - /opt/secrets.env 注意的是这里所说的环境变量是对宿主机的 Compose 而言的，如果在配置文件中有 build 操作，这些变量并不会进入构建过程中，如果要在构建中使用变量还是首选前面刚讲的 arg 标签。 environment 与上面的 env_file 标签完全不同，反而和 arg 有几分类似，这个标签的作用是设置镜像变量，它可以保存变量到镜像里面，也就是说启动的容器也会包含这些变量设置，这是与 arg 最大的不同。 一般 arg 标签的变量仅用在构建过程中。而 environment 和 Dockerfile 中的 ENV 指令一样会把变量一直保存在镜像、容器中，类似 docker run -e 的效果。 environment: RACK_ENV: development SHOW: 'true' SESSION_SECRET: environment: - RACK_ENV=development - SHOW=true - SESSION_SECRET expose 这个标签与Dockerfile中的EXPOSE指令一样，用于指定暴露的端口，但是只是作为一种参考，实际上docker-compose.yml的端口映射还得ports这样的标签。 expose: - \"3000\" - \"8000\" external_links 在使用Docker过程中，我们会有许多单独使用docker run启动的容器，为了使Compose能够连接这些不在docker-compose.yml中定义的容器，我们需要一个特殊的标签，就是external_links，它可以让Compose项目里面的容器连接到那些项目配置外部的容器（前提是外部容器中必须至少有一个容器是连接到与项目内的服务的同一个网络里面）。 格式如下： external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql extra_hosts 添加主机名的标签，就是往/etc/hosts文件中添加一些记录，与Docker client的--add-host类似： extra_hosts: - \"somehost:162.242.195.82\" - \"otherhost:50.31.209.229\" 启动之后查看容器内部hosts： 162.242.195.82 somehost 50.31.209.229 otherhost labels 向容器添加元数据，和Dockerfile的LABEL指令一个意思，格式如下： labels: com.example.description: \"Accounting webapp\" com.example.department: \"Finance\" com.example.label-with-empty-value: \"\" labels: - \"com.example.description=Accounting webapp\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" links 还记得上面的depends_on吧，那个标签解决的是启动顺序问题，这个标签解决的是容器连接问题，与Docker client的--link一样效果，会连接到其它服务中的容器。 格式如下： links: - db - db:database - redis 使用的别名将会自动在服务容器中的/etc/hosts里创建。例如： 172.12.2.186 db 172.12.2.186 database 172.12.2.187 redis 相应的环境变量也将被创建。 logging 这个标签用于配置日志服务。格式如下： logging: driver: syslog options: syslog-address: \"tcp://192.168.0.42:123\" 默认的driver是json-file。只有json-file和journald可以通过docker-compose logs显示日志，其他方式有其他日志查看方式，但目前Compose不支持。对于可选值可以使用options指定。 有关更多这方面的信息可以阅读官方文档： https://docs.docker.com/engine/admin/logging/overview/ pid pid: \"host\" 将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用这个标签将能够访问和操纵其他容器和宿主机的名称空间。 ports 映射端口的标签。 使用HOST:CONTAINER格式或者只是指定容器的端口，宿主机会随机映射端口。 ports: - \"3000\" - \"8000:8000\" - \"49100:22\" - \"127.0.0.1:8001:8001\" 注意：当使用HOST:CONTAINER格式来映射端口时，如果你使用的容器端口小于60你可能会得到错误得结果，因为YAML将会解析xx:yy这种数字格式为60进制。所以建议采用字符串格式。 security_opt 为每个容器覆盖默认的标签。简单说来就是管理全部服务的标签。比如设置全部服务的user标签值为USER。 security_opt: - label:user:USER - label:role:ROLE stop_signal 设置另一个信号来停止容器。在默认情况下使用的是SIGTERM停止容器。设置另一个信号可以使用stop_signal标签。 stop_signal: SIGUSR1 volumes 挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER] 这样的格式，或者使用 [HOST:CONTAINER:ro] 这样的格式，后者对于容器来说，数据卷是只读的，这样可以有效保护宿主机的文件系统。 Compose的数据卷指定路径可以是相对路径，使用 . 或者 .. 来指定相对目录。 数据卷的格式可以是下面多种形式： volumes: // 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。 - /var/lib/mysql // 使用绝对路径挂载数据卷 - /opt/data:/var/lib/mysql // 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。 - ./cache:/tmp/cache // 使用用户的相对路径（~/ 表示的目录是 /home// 或者 /root/）。 - ~/configs:/etc/configs/:ro // 已经存在的命名的数据卷。 - datavolume:/var/lib/mysql 如果你不使用宿主机的路径，你可以指定一个volume_driver。 volume_driver: mydriver volumes_from 从其它容器或者服务挂载数据卷，可选的参数是 :ro或者 :rw，前者表示容器只读，后者表示容器对数据卷是可读可写的。默认情况下是可读可写的。 volumes_from: - service_name - service_name:ro - container:container_name - container:container_name:rw cap_add, cap_drop 添加或删除容器的内核功能。详细信息在前面容器章节有讲解，此处不再赘述。 cap_add: - ALL cap_drop: - NET_ADMIN - SYS_ADMIN cgroup_parent 指定一个容器的父级cgroup。 cgroup_parent: m-executor-abcd devices 设备映射列表。与Docker client的--device参数类似。 devices: - \"/dev/ttyUSB0:/dev/ttyUSB0\" extends 这个标签可以扩展另一个服务，扩展内容可以是来自在当前文件，也可以是来自其他文件，相同服务的情况下，后来者会有选择地覆盖原有配置。 extends: file: common.yml service: webapp 用户可以在任何地方使用这个标签，只要标签内容包含file和service两个值就可以了。file的值可以是相对或者绝对路径，如果不指定file的值，那么Compose会读取当前YML文件的信息。 network_mode 网络模式，与Docker client的--net参数类似，只是相对多了一个service:[service name] 的格式。 例如： network_mode: \"bridge\" network_mode: \"host\" network_mode: \"none\" network_mode: \"service:[service name]\" network_mode: \"container:[container name/id]\" 可以指定使用服务或者容器的网络。 networks 加入指定网络，格式如下： services: some-service: networks: - some-network - other-network 关于这个标签还有一个特别的子标签aliases，这是一个用来设置服务别名的标签，例如： services: some-service: networks: some-network: aliases: - alias1 - alias3 other-network: aliases: - alias2 相同的服务可以在不同的网络有不同的别名。 其它 还有这些标签：cpu_shares, cpu_quota, cpuset, domainname, hostname, ipc, mac_address, mem_limit, memswap_limit, privileged, read_only, restart, shm_size, stdin_open, tty, user, working_dir 上面这些都是一个单值的标签，类似于使用docker run的效果。 cpu_shares: 73 cpu_quota: 50000 cpuset: 0,1 user: postgresql working_dir: /code domainname: foo.com hostname: foo ipc: host mac_address: 02:42:ac:11:65:43 mem_limit: 1000000000 memswap_limit: 2000000000 privileged: true restart: always read_only: true shm_size: 64M stdin_open: true tty: true Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter04/附录/Docker常用命令.html":{"url":"chapter04/附录/Docker常用命令.html","title":"Docker 常用命令","keywords":"","body":"Docker 常用命令 查看Docker版本 docker version 从Docker文件构建Docker映像 docker build -t image-name docker-file-location 运行Docker映像 docker run -d image-name 查看可用的Docker映像 docker images 查看最近的运行容器 docker ps -l 查看所有正在运行的容器 docker ps -a 停止运行容器 docker stop container_id 删除一个镜像 docker rmi image-name 删除所有镜像 docker rmi $(docker images -q) 强制删除所有镜像 docker rmi -r $(docker images -q) 删除所有为 的镜像 docker rmi $(docker images -q -f dangling=true) 删除所有容器 docker rm $(docker ps -a -q) 进入Docker容器 docker exec -it container-id /bin/bash 查看所有数据卷 docker volume ls 删除指定数据卷 docker volume rm [volume_name] 删除所有未关联的数据卷 docker volume rm $(docker volume ls -qf dangling=true) Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter04/附录/Docker资源汇总.html":{"url":"chapter04/附录/Docker资源汇总.html","title":"Docker 资源汇总","keywords":"","body":"Docker 资源汇总 Docker官方英文资源 docker官网：http://www.docker.com Docker windows入门：https://docs.docker.com/windows/ Docker Linux 入门：https://docs.docker.com/linux/ Docker mac 入门：https://docs.docker.com/mac/ Docker 用户指引：https://docs.docker.com/engine/userguide/ Docker 官方博客：http://blog.docker.com/ Docker Hub:https://hub.docker.com/ Docker开源：https://www.docker.com/open-source Docker中文资源 Docker中文网站：http://www.docker.org.cn Docker安装手册：http://www.docker.org.cn/book/install.html 一小时Docker教程 ：https://blog.csphere.cn/archives/22 Docker 从入门到实践：http://dockerpool.com/static/books/docker_practice/index.html Docker中文指南：http://www.widuu.com/chinese_docker/index.html 其它资源 https://segmentfault.com/t/docker https://github.com/docker/docker https://wiki.openstack.org/wiki/Docker https://wiki.archlinux.org/index.php/Docker Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/git.html":{"url":"chapter05/git.html","title":"Git","keywords":"","body":"Git Git 简介 Git 安装 Git 工作流程 Git 工作区、暂存区和版本库 Git 基本操作 Git 标签 TortoiseGit 简化操作 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:33 "},"chapter05/git/git简介.html":{"url":"chapter05/git/git简介.html","title":"Git 简介","keywords":"","body":"Git 简介 Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git 与 SVN 区别 GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。Git 与 SVN 区别点： GIT 是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 GIT 把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT 分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT 没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT 的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/git/git安装.html":{"url":"chapter05/git/git安装.html","title":"Git 安装","keywords":"","body":"Git 安装 下载 下载地址：https://git-scm.com/downloads 安装 双击安装文件，然后出现安装向导界面,点击下一步(Next)即可 接着出现授权信息界面， Next即可 选择安装路径 选择文件关联,如果你不清楚,直接默认,下一步即可 接着出现开始菜单文件夹,默认,下一步即可 然后是是否配置Path的配置,选择中间一个,可以通过 Windows命令行(CMD)调用 git 命令。 然后点击下一步 选择回车换行的格式。默认即可.(检出时转换为Windows风格,提交时转换为Linux风格.) 然后是安装进度界面 安装完成. 去掉那个查看版本说明的复选框,点击完成(Finish)按钮即可 可以在cmd里面测试是否设置了Path,是否安装成功. 在CMD中输入 git 或者 git --version 试试 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/git/git工作流程.html":{"url":"chapter05/git/git工作流程.html","title":"Git 工作流程","keywords":"","body":"Git 工作流程 一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/git/git工作区暂缓区版本库.html":{"url":"chapter05/git/git工作区暂缓区版本库.html","title":"Git 工作区、暂存区和版本库","keywords":"","body":"Git 工作区、暂缓区和版本库 我们先来理解下 Git 工作区、暂存区和版本库概念 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage, 或 index。一般存放在 .git 目录下的 index 文件 (.git/index) 中，所以我们把暂存区有时也叫作索引 (index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是 Git 的版本库。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/git/git基本操作.html":{"url":"chapter05/git/git基本操作.html","title":"Git 基本操作","keywords":"","body":"Git 基本操作 获取与创建项目命令 git init 用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。 git init git clone 使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。 git clone [url] 基本快照 git add git add 命令可将该文件添加到缓存 git add git status git status 以查看在你上次提交之后是否有修改。 git status git status -s git diff 执行 git diff 来查看执行 git status 的结果的详细信息。 git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 尚未缓存的改动：git diff 查看已缓存的改动： git diff --cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff --stat git commit 使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。 Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。 git config --global user.name 'yourname' git config --global user.email youremail 将文件写入缓存区并提供提交注释 git commit -m 'update message' git reset HEAD git reset HEAD 命令用于取消已缓存的内容。 git reset HEAD -- 拉取与推送 git pull git pull命令用于从另一个存储库或本地分支获取并集成(整合)。git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂。 git pull : 将远程存储库中的更改合并到当前分支中。在默认模式下，git pull是git fetch后跟git merge FETCH_HEAD的缩写。更准确地说，git pull使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中。 git push git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相似。 git push : Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/git/git标签.html":{"url":"chapter05/git/git标签.html","title":"Git 标签","keywords":"","body":"Git 标签 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 比如说，我们想为我们的 商城 项目发布一个\"1.0.0\"版本。 我们可以用 git tag -a v1.0.0 命令给最新一次提交打上（HEAD） \"v1.0.0\" 的标签。 -a 选项意为\"创建一个带注解的标签\"。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 git tag -a v1.0.0 如果我们要查看所有标签可以使用以下命令： git tag Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/git/TortoiseGit简化操作.html":{"url":"chapter05/git/TortoiseGit简化操作.html","title":"TortoiseGit 简化操作","keywords":"","body":"TortoiseGit 简化操作 TortoiseGit, 中文名海龟 Git. 海龟 Git 只支持 Windows 系统, 有一个前辈海龟 SVN, TortoiseSVN 和 TortoiseGit 都是非常优秀的开源的版本库客户端. 分为 32 位版与 64 位版.并且支持各种语言,包括简体中文 下载 下载地址：https://tortoisegit.org/download/ 安装 我们需要先安装程序包,然后安装语言包(LanguagePack). 因为TortoiseGit 只是一个程序壳,必须依赖一个 Git Core,也就是上一节我们安装的 Git. 所以安装前请确定已完成上一节的操作. 下面以64位版本为演示(64,32位除文件名不一样,其他的操作都一致) 双击安装程序 下一步,进入版权信息界面. 直接点击下一步(Next)即可 下一步,选择SSH客户端. 可以选择 TortoiseGitPlink(位于TortoiseGit安装目录/bin 下), 也可以选择 Git 默认的SSH客户端,位于 Git安装目录/bin/ssh.exe(如果配置了 Path,那直接是 ssh.exe) 接着是选择安装目录,可以保持默认,或者安装到开发环境目录下,安装的程序组件保持默认即可 下一步到确认安装界面,点击 Install按钮安装即可,如下图所示 安装完成,点击 Finish 按钮即可 安装语言包 双击打开语言包安装程序 点击下一步(Alt+N), 语言包会自动安装完成 配置 在空白处点击鼠标右键, 选择 --> TortoiseGit --> Settings, 然后就可以看到配置界面 选中General,在右边的 Language中选择中文. 不勾选自动升级的复选框,可能还需要指定 Git.exe 文件的路径 再次点击鼠标右键,可以看到弹出菜单中已经变成中文. 原来的 Settings 变成 设置; Clone 变为 克隆 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/GitLab.html":{"url":"chapter05/GitLab.html","title":"GitLab","keywords":"","body":"GitLab GitLab 简介 GitLab 安装 GitLab 设置 GitLab 账户 GitLab 使用 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:33 "},"chapter05/GitLab/GitLab简介.html":{"url":"chapter05/GitLab/GitLab简介.html","title":"GitLab 简介","keywords":"","body":"GitLab 简介 GitLab 是利用 Ruby on Rails 一个开源的版本管理系统，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。它拥有与 Github 类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序 (Wall) 进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/GitLab/GitLab安装.html":{"url":"chapter05/GitLab/GitLab安装.html","title":"GitLab 安装","keywords":"","body":"GitLab 安装 我们使用 Docker 来安装和运行 GitLab 中文版，由于新版本问题较多，这里我们使用目前相对稳定的 10.5 版本，docker-compose.yml 配置如下： version: '3' services: web: image: 'twang2218/gitlab-ce-zh:10.5' restart: always hostname: '192.168.75.145' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://192.168.75.145:8080' gitlab_rails['gitlab_shell_ssh_port'] = 2222 unicorn['port'] = 8888 nginx['listen_port'] = 8080 ports: - '8080:8080' - '8443:443' - '2222:22' volumes: - /usr/local/docker/gitlab/config:/etc/gitlab - /usr/local/docker/gitlab/data:/var/opt/gitlab - /usr/local/docker/gitlab/logs:/var/log/gitlab 安装完成后的工作 访问地址：http://ip:8080 端口 8080 是因为我在配置中设置的外部访问地址为 8080，默认是 80 初始化安装完成后效果如下： 设置管理员初始密码，这里的密码最好是 字母 + 数字 组合，并且 大于等于 8 位 配置完成后登录，管理员账号是 root 注意： 如果服务器配置较低，启动运行可能需要较长时间，请耐心等待 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/GitLab/GitLab设置.html":{"url":"chapter05/GitLab/GitLab设置.html","title":"GitLab 设置","keywords":"","body":"GitLab 设置 第一次使用时需要做一些初始化设置，点击“管理区域”-->“设置” 账户与限制设置 关闭头像功能，由于 Gravatar 头像为网络头像，在网络情况不理想时可能导致访问时卡顿 注册限制 由于是内部代码托管服务器，可以直接关闭注册功能，由管理员统一创建用户即可 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/GitLab/GitLab账户.html":{"url":"chapter05/GitLab/GitLab账户.html","title":"GitLab 账户","keywords":"","body":"GitLab 账户 使用时请不要直接通过 root 用户操作，需要先创建用户，然后通过创建的用户操作，如果你是管理员还需要为其他开发人员分配账户 创建用户 点击“管理区域”-->“新建用户” 设置账户信息 同时你可以将自己设置为管理员 修改用户密码 由于我们创建时并没有配置邮箱，所以还需要重新编辑用户信息并手动设置密码 退出并使用新账户登录 注意：创建完账户，第一次登录时还会提示你修改登录密码 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter05/GitLab/GitLab使用.html":{"url":"chapter05/GitLab/GitLab使用.html","title":"GitLab 使用","keywords":"","body":"GitLab 使用 创建第一个托管项目 点击 + 号 --> 新建项目 输入项目名称及描述信息，设置可见等级为私有，这样别人就看不见你的项目 初始化项目 我们选择通过增加一个 README 的方式来初始化项目 直接提交修改即可 使用 SSH 的方式拉取和推送项目 生成 SSH KEY 使用 ssh-keygen 工具生成，位置在 Git 安装目录下，我的是 C:\\Program Files\\Git\\usr\\bin 输入命令： ssh-keygen -t rsa -C \"your_email@example.com\" 执行成功后的效果： Microsoft Windows [版本 10.0.14393] (c) 2016 Microsoft Corporation。保留所有权利。 C:\\Program Files\\Git\\usr\\bin>ssh-keygen -t rsa -C \"topsale@vip.qq.com\" Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/Lusifer/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/Users/Lusifer/.ssh/id_rsa. Your public key has been saved in /c/Users/Lusifer/.ssh/id_rsa.pub. The key fingerprint is: SHA256:cVesJKa5VnQNihQOTotXUAIyphsqjb7Z9lqOji2704E topsale@vip.qq.com The key's randomart image is: +---[RSA 2048]----+ | + ..=o=. .+. | | o o + B .+.o.o | |o . + +=o+.. | |.= . oo... | |= o So | |oE . o | | .. .. . | | o*o+ | | *B*oo | +----[SHA256]-----+ C:\\Program Files\\Git\\usr\\bin> 复制 SSH-KEY 信息到 GitLab 秘钥位置在：C:\\Users\\你的用户名\\.ssh 目录下，找到 id_rsa.pub 并使用编辑器打开，如： 登录 GitLab，点击“用户头像”-->“设置”-->“SSH 密钥” 成功增加密钥后的效果 使用 TortoiseGit 克隆项目 新建一个存放代码仓库的本地文件夹 在文件夹空白处按右键 选择“Git 克隆...” 服务项目地址到 URL 如果弹出连接信息请选择是 成功克隆项目到本地 使用 TortoiseGit 推送项目（提交代码） 创建或修改文件（这里的文件为所有文件，包括：代码、图片等） 我们以创建 .gitignore 过滤配置文件为例，该文件的主要作用为过滤不需要上传的文件，比如：IDE 生成的工程文件、编译后的 class 文件等 在工程目录下，新建 .gitignore 文件，并填入如下配置： .gradle *.sw? .#* *# *~ /build /code .classpath .project .settings .metadata .factorypath .recommenders bin build target .factorypath .springBeans interpolated*.xml dependency-reduced-pom.xml build.log _site/ .*.md.html manifest.yml MANIFEST.MF settings.xml activemq-data overridedb.* *.iml *.ipr *.iws .idea .DS_Store .factorypath dump.rdb transaction-logs **/overlays/ **/logs/ **/temp/ **/classes/ 右键呼出菜单，选择“提交 Master...” 点击“全部”并填入“日志信息” 点击“提交并推送” 成功后的效果图 查看 GitLab 确认提交成功 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter06/Spring简史.html":{"url":"chapter06/Spring简史.html","title":"Spring 简史","keywords":"","body":"Spring 简史 Spring 1.x 时代 在 Spring1.x 时代，都是通过 xml 文件配置 bean，随着项目的不断扩大，需要将 xml 配置分放到不同的配置文件中，需要频繁的在 java 类和 xml 配置文件中切换。 Spring 2.x 时代 随着 JDK 1.5 带来的注解支持，Spring2.x 可以使用注解对 Bean 进行申明和注入，大大的减少了 xml 配置文件，同时也大大简化了项目的开发。 那么，问题来了，究竟是应该使用 xml 还是注解呢？ 最佳实践： 应用的基本配置用 xml，比如：数据源、资源文件等 业务开发用注解，比如：Service 中注入 bean 等 Spring 3.x 时代 从 Spring3.x 开始提供了 Java 配置方式，使用 Java 配置方式可以更好的理解你配置的 Bean，现在我们就处于这个时代，并且 Spring4.x 和 Spring boot 都推荐使用 java 配置的方式。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter06/SpringBoot简介.html":{"url":"chapter06/SpringBoot简介.html","title":"Spring Boot 简介","keywords":"","body":"Spring Boot 简介 随着动态语言的流行 (Ruby、Groovy、Scala、Node.js)，Java 的开发显得格外的笨重：繁多的配置、低下的开发效率、复杂的部署流程以及第三方技术集成难度大。 在上述环境下，Spring Boot 应运而生。它使用“习惯优于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速的运行起来。使用 Spring Boot 很容易创建一个独立运行（运行 Jar，内嵌 Servlet 容器）准生产级别的基于 Spring 框架的项目，使用 Spring Boot 你可以不用或者只需很少的 Spring 配置。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter06/SpringBoot的优点.html":{"url":"chapter06/SpringBoot的优点.html","title":"Spring Boot 的优点","keywords":"","body":"Spring Boot 的优点 快速构建项目 对主流开发框架的无配置集成 项目可独立运行，无需外部依赖 Servlet 容器 提供运行时的应用监控 极大地提高了开发、部署效率 与云计算的天然集成 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter06/SpringBoot的缺点.html":{"url":"chapter06/SpringBoot的缺点.html","title":"Spring Boot 的缺点","keywords":"","body":"Spring Boot 的缺点 坑多文档少 版本迭代速度很快，一些模块改动很大 由于不用自己做配置，报错时很难定位 网上现成的解决方案比较少 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter06/第一个SpringBoot应用程序.html":{"url":"chapter06/第一个SpringBoot应用程序.html","title":"第一个 Spring Boot 应用程序","keywords":"","body":"第一个 Spring Boot 应用程序 这里我们使用 Intellij IDEA 来新建一个 Spring Boot 项目。 新建 Spring Initializr 项目 填写项目信息 选择项目使用技术 填写项目名称 新建 Spring Boot 项目后，会在根包目录下有一个 artifactId + Application 命名规则的入口类 添加测试控制器 package com.lusifer.spring.boot.hello; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @SpringBootApplication public class HelloApplication { @RequestMapping(value = \"/\") public String index() { return \"Hello Spring Boot.\"; } public static void main(String[] args) { SpringApplication.run(HelloApplication.class, args); } } 代码解释 @SpringBootApplication：是 Spring Boot 项目的核心注解，主要目的是开启自动配置。 main() 方法：是一个标准的 Java 应用的 main 方法，主要作用是作为项目启动的入口。 运行效果 HelloApplication 文件中单击右键，在右键菜单中选择 Run \"HelloApplication\" 运行项目 访问 http://localhost:8080 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter06/SpringBoot基本配置.html":{"url":"chapter06/SpringBoot基本配置.html","title":"Spring Boot 基本配置","keywords":"","body":"Spring Boot 基本配置 自定义 Banner Spring Boot 配置文件 Starter POM Spring Boot 日志配置 关闭特定的自动配置 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:41 "},"chapter06/SpringBoot基本配置/自定义Banner.html":{"url":"chapter06/SpringBoot基本配置/自定义Banner.html","title":"自定义 Banner","keywords":"","body":"自定义 Banner 在 Spring Boot 启动的时候会有一个默认的启动图案 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.8.RELEASE) 我们在 src/main/resources 目录下新建一个 banner.txt 通过 http://patorjk.com/software/taag 网站生成字符串，将网站生成的字符复制到 banner.txt 中 再次运行这个程序 _ooOoo_ o8888888o 88\" . \"88 (| -_- |) O\\ = /O ____/`---'\\____ .' \\\\| |// `. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__ `-` ___/-. / ___`. .' /--.--\\ `. . __ .\"\" '_/___.' >'\"\". | | : `- \\`.;`\\ _ /`;.`/ - ` : | | \\ \\ `-. \\_ __\\ /__ _/ .-` / / ======`-.____`-.___\\_____/___.-`____.-'====== `=---=' ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter06/SpringBoot基本配置/SpringBoot配置文件.html":{"url":"chapter06/SpringBoot基本配置/SpringBoot配置文件.html","title":"Spring Boot 配置文件","keywords":"","body":"Spring Boot 配置文件 Spring Boot项目使用一个全局的配置文件 application.properties 或者是 application.yml，在 resources 目录下或者类路径下的 /config 下，一般我们放到 resources 下。 修改 tomcat 的端口为 9090，并将默认的访问路径 \"/\" 修改为 \"boot\"，可以在 application.properties 中添加： server.port=9090 server.context-path=/boot 或在 application.yml 中添加： server: port: 9090 context-path: /boot 测试效果： 修改 DispatcherServlet 的规则为：*.html server: port: 9090 context-path: /boot servlet-path: '*.html' 测试效果： 更多配置：https://docs.spring.io/spring-boot/docs/1.5.8.RELEASE/reference/html/common-application-properties.html Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter06/SpringBoot基本配置/StarterPOM.html":{"url":"chapter06/SpringBoot基本配置/StarterPOM.html","title":"Starter POM","keywords":"","body":"starter pom Spring Boot 为我们提供了简化企业级开发绝大多数场景的 starter pom ，只要使用了应用场景所需要的 starter pom ，相关的技术配置将会消除，就可以得到 Spring Boot 为我们提供的自动配置的 Bean。 官方提供的 starter pom https://docs.spring.io/spring-boot/docs/1.5.8.RELEASE/reference/html/using-boot-build-systems.html#using-boot-starter Name Description Pom spring-boot-starter Core starter, including auto-configuration support, logging and YAML Pom spring-boot-starter-activemq Starter for JMS messaging using Apache ActiveMQ Pom spring-boot-starter-amqp Starter for using Spring AMQP and Rabbit MQ Pom spring-boot-starter-aop Starter for aspect-oriented programming with Spring AOP and AspectJ Pom spring-boot-starter-artemis Starter for JMS messaging using Apache Artemis Pom spring-boot-starter-batch Starter for using Spring Batch Pom spring-boot-starter-cache Starter for using Spring Framework’s caching support Pom spring-boot-starter-cloud-connectors Starter for using Spring Cloud Connectors which simplifies connecting to services in cloud platforms like Cloud Foundry and Heroku Pom spring-boot-starter-data-cassandra Starter for using Cassandra distributed database and Spring Data Cassandra Pom spring-boot-starter-data-couchbase Starter for using Couchbase document-oriented database and Spring Data Couchbase Pom spring-boot-starter-data-elasticsearch Starter for using Elasticsearch search and analytics engine and Spring Data Elasticsearch Pom spring-boot-starter-data-gemfire Starter for using GemFire distributed data store and Spring Data GemFire Pom spring-boot-starter-data-jpa Starter for using Spring Data JPA with Hibernate Pom spring-boot-starter-data-ldap Starter for using Spring Data LDAP Pom spring-boot-starter-data-mongodb Starter for using MongoDB document-oriented database and Spring Data MongoDB Pom spring-boot-starter-data-neo4j Starter for using Neo4j graph database and Spring Data Neo4j Pom spring-boot-starter-data-redis Starter for using Redis key-value data store with Spring Data Redis and the Jedis client Pom spring-boot-starter-data-rest Starter for exposing Spring Data repositories over REST using Spring Data REST Pom spring-boot-starter-data-solr Starter for using the Apache Solr search platform with Spring Data Solr Pom spring-boot-starter-freemarker Starter for building MVC web applications using FreeMarker views Pom spring-boot-starter-groovy-templates Starter for building MVC web applications using Groovy Templates views Pom spring-boot-starter-hateoas Starter for building hypermedia-based RESTful web application with Spring MVC and Spring HATEOAS Pom spring-boot-starter-integration Starter for using Spring Integration Pom spring-boot-starter-jdbc Starter for using JDBC with the Tomcat JDBC connection pool Pom spring-boot-starter-jersey Starter for building RESTful web applications using JAX-RS and Jersey. An alternative tospring-boot-starter-web Pom spring-boot-starter-jooq Starter for using jOOQ to access SQL databases. An alternative tospring-boot-starter-data-jpaorspring-boot-starter-jdbc Pom spring-boot-starter-jta-atomikos Starter for JTA transactions using Atomikos Pom spring-boot-starter-jta-bitronix Starter for JTA transactions using Bitronix Pom spring-boot-starter-jta-narayana Spring Boot Narayana JTA Starter Pom spring-boot-starter-mail Starter for using Java Mail and Spring Framework’s email sending support Pom spring-boot-starter-mobile Starter for building web applications using Spring Mobile Pom spring-boot-starter-mustache Starter for building MVC web applications using Mustache views Pom spring-boot-starter-security Starter for using Spring Security Pom spring-boot-starter-social-facebook Starter for using Spring Social Facebook Pom spring-boot-starter-social-linkedin Stater for using Spring Social LinkedIn Pom spring-boot-starter-social-twitter Starter for using Spring Social Twitter Pom spring-boot-starter-test Starter for testing Spring Boot applications with libraries including JUnit, Hamcrest and Mockito Pom spring-boot-starter-thymeleaf Starter for building MVC web applications using Thymeleaf views Pom spring-boot-starter-validation Starter for using Java Bean Validation with Hibernate Validator Pom spring-boot-starter-web Starter for building web, including RESTful, applications using Spring MVC. Uses Tomcat as the default embedded container Pom spring-boot-starter-web-services Starter for using Spring Web Services Pom spring-boot-starter-websocket Starter for building WebSocket applications using Spring Framework’s WebSocket support Pom Name Description Pom spring-boot-starter-actuator Starter for using Spring Boot’s Actuator which provides production ready features to help you monitor and manage your application Pom spring-boot-starter-remote-shell Starter for using the CRaSH remote shell to monitor and manage your application over SSH. Deprecated since 1.5 Pom Name Description Pom spring-boot-starter-jetty Starter for using Jetty as the embedded servlet container. An alternative tospring-boot-starter-tomcat Pom spring-boot-starter-log4j2 Starter for using Log4j2 for logging. An alternative tospring-boot-starter-logging Pom spring-boot-starter-logging Starter for logging using Logback. Default logging starter Pom spring-boot-starter-tomcat Starter for using Tomcat as the embedded servlet container. Default servlet container starter used byspring-boot-starter-web Pom spring-boot-starter-undertow Starter for using Undertow as the embedded servlet container. An alternative tospring-boot-starter-tomcat Pom Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter06/SpringBoot基本配置/SpringBoot日志配置.html":{"url":"chapter06/SpringBoot基本配置/SpringBoot日志配置.html","title":"Spring Boot 日志配置","keywords":"","body":"Spring Boot 日志配置 Spring Boot 对各种日志框架都做了支持，我们可以通过配置来修改默认的日志的配置 默认情况下，Spring Boot 使用 Logback 作为日志框架 配置日志文件 logging: file: ../logs/spring-boot-hello.log level.org.springframework.web: DEBUG Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter06/SpringBoot基本配置/关闭特定的自动配置.html":{"url":"chapter06/SpringBoot基本配置/关闭特定的自动配置.html","title":"关闭特定的自动配置","keywords":"","body":"关闭特定的自动配置 关闭特定的自动配置使用 @SpringBootApplication 注解的 exclude 参数 @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) 说明：这里是关闭数据源的自动配置，实例用法见 项目实战-实现文章管理功能-PageHelper 分页查询 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:18:07 "},"chapter07/Thymeleaf简介.html":{"url":"chapter07/Thymeleaf简介.html","title":"Thymeleaf 简介","keywords":"","body":"Thymeleaf 简介 Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点 Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板 + 数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 Thymeleaf 开箱即用的特性。它提供标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、 OGNL 表达式效果，避免每天套模板、改 JSTL、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 Thymeleaf 提供 Spring 标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/SpringBoot与Thymeleaf.html":{"url":"chapter07/SpringBoot与Thymeleaf.html","title":"Spring Boot 与 Thymeleaf","keywords":"","body":"Spring Boot 与 Thymeleaf 如果希望以 Jar 形式发布模块则尽量不要使用 JSP 相关知识，这是因为 JSP 在内嵌的 Servlet 容器上运行有一些问题 (内嵌 Tomcat、 Jetty 不支持 Jar 形式运行 JSP，Undertow 不支持 JSP)。 Spring Boot 中推荐使用 Thymeleaf 作为模板引擎，因为 Thymeleaf 提供了完美的 Spring MVC 支持 Spring Boot 提供了大量模板引擎，包括： FreeMarker Groovy Mustache Thymeleaf Velocity Beetl Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/第一个Thymeleaf模板页.html":{"url":"chapter07/第一个Thymeleaf模板页.html","title":"第一个 Thymeleaf 模板页","keywords":"","body":"第一个 Thymeleaf 模板页 新建一个名为 spring-boot-thymeleaf 的 Spring Boot 项目，并引入 Thymeleaf 的 starter pom org.springframework.boot spring-boot-starter-thymeleaf net.sourceforge.nekohtml nekohtml 1.9.22 示例 JavaBean 此类用来在模板页面展示数据用，包含 name 和 age 属性 package com.lusifer.spring.boot.thymeleaf.bean; public class PersonBean { private String name; private Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 脚本样式静态文件 根据默认原则，脚本样式、图片等静态文件应该放置在 src/main/resources/static 下，这里引入 Bootstrap 和 jQuery 演示页面 根据默认原则，页面应该放置在 src/main/resources/templates 下，在该目录下新建 index.html 访问 model 列表 获得名字 var single = [[${singlePerson}]]; console.log(single.name + \"/\" + single.age); function getName(name) { console.log(name) } 数据准备 package com.lusifer.spring.boot.thymeleaf; import com.lusifer.spring.boot.thymeleaf.bean.PersonBean; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import java.util.ArrayList; import java.util.List; @Controller @SpringBootApplication public class ThymeleafApplication { @RequestMapping(value = \"/\") public String index(Model model) { PersonBean person = new PersonBean(); person.setName(\"张三\"); person.setAge(22); List people = new ArrayList<>(); PersonBean p1 = new PersonBean(); p1.setName(\"李四\"); p1.setAge(23); people.add(p1); PersonBean p2 = new PersonBean(); p2.setName(\"王五\"); p2.setAge(24); people.add(p2); PersonBean p3 = new PersonBean(); p3.setName(\"赵六\"); p3.setAge(25); people.add(p3); model.addAttribute(\"singlePerson\", person); model.addAttribute(\"people\", people); return \"index\"; } public static void main(String[] args) { SpringApplication.run(ThymeleafApplication.class, args); } } 在 application.yml 中配置属性解析器 # Thymeleaf Start spring: thymeleaf: cache: false # 开发时关闭缓存,不然没法看到实时页面 mode: LEGACYHTML5 # 用非严格的 HTML encoding: UTF-8 content-type: text/html # Thymeleaf End 测试运行 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf常用语法.html":{"url":"chapter07/Thymeleaf常用语法.html","title":"Thymeleaf 常用语法","keywords":"","body":"Thymeleaf 常用语法 引入 Thymeleaf 修改 html 标签用于引入 thymeleaf 引擎，这样才可以在其他标签里使用 th:* 语法，这是下面语法的前提。 获取变量值 name 可以看出获取变量值用 $ 符号,对于javaBean的话使用 变量名.属性名 方式获取,这点和 EL 表达式一样. 另外 $ 表达式只能写在th标签内部,不然不会生效,上面例子就是使用 th:text 标签的值替换 p 标签里面的值,至于 p 里面的原有的值只是为了给前端开发时做展示用的.这样的话很好的做到了前后端分离. 引入 URL Thymeleaf 对于 URL 的处理是通过语法 @{…} 来处理的 绝对路径 相对路径 Content路径,默认访问static下的css文件夹 类似的标签有:th:href 和 th:src 字符串替换 很多时候可能我们只需要对一大段文字中的某一处地方进行替换，可以通过字符串拼接操作完成： 一种更简洁的方式是： 当然这种形式限制比较多，|…|中只能包含变量表达式${…}，不能包含其他常量、条件表达式等。 运算符 在表达式中可以使用各类算术运算符，例如+, -, *, /, % th:with=\"isEven=(${prodStat.count} % 2 == 0)\" 逻辑运算符>, =，==,!=都可以使用，唯一需要注意的是使用时需要用它的HTML转义符： th:if=\"${prodStat.count} &gt; 1\" th:text=\"'Execution mode is ' + ( (${execMode} == 'dev')? 'Development' : 'Production')\" 条件 if/unless Thymeleaf 中使用 th:if 和 th:unless 属性进行条件判断，下面的例子中，标签只有在 th:if 中条件成立时才显示： Login th:unless 于 th:if 恰好相反，只有表达式中的条件不成立，才会显示其内容。 switch Thymeleaf 同样支持多路选择 Switch 结构： User is an administrator User is a manager 默认属性 default 可以用 * 表示： User is an administrator User is a manager User is some other thing 循环 渲染列表数据是一种非常常见的场景，例如现在有 n 条记录需要渲染成一个表格，该数据集合必须是可以遍历的，使用 th:each 标签： Product list NAME PRICE IN STOCK Onions 2.41 yes Return to home 可以看到，需要在被循环渲染的元素（这里是）中加入 th:each 标签，其中 th:each=\"prod : ${prods}\" 意味着对集合变量 prods 进行遍历，循环变量是 prod 在循环体中可以通过表达式访问。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf参考手册.html":{"url":"chapter07/Thymeleaf参考手册.html","title":"Thymeleaf 参考手册","keywords":"","body":"Thymeleaf 参考手册 声明 使用文本 其它 th 标签 表达式语法 内置对象 循环 判断 模板布局 th:block th:inline Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:19:50 "},"chapter07/Thymeleaf参考手册/声明.html":{"url":"chapter07/Thymeleaf参考手册/声明.html","title":"声明","keywords":"","body":"声明 修改 html 标签用于引入 thymeleaf 引擎，这样才可以在其他标签里使用 th:* 语法，这是下面语法的前提。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf参考手册/使用文本.html":{"url":"chapter07/Thymeleaf参考手册/使用文本.html","title":"使用文本","keywords":"","body":"使用文本 语法 说明 {home.welcome} 使用国际化文本,国际化传参直接追加(value…) ${user.name} 使用会话属性 @{} – – ${} 中预存对象（表达式中基本对象） param 获取请求参数，比如${param.name},http://localhost:8080?name=jeff session 获取 session 的属性 application 获取 application 的属性 execInfo 有两个属性 templateName和 now(是 java 的 Calendar 对象) ctx vars locale httpServletRequest httpSession – – th扩展标签 th:text 普通字符串 th:utext 转义文本 th:href th:attr th:with 定义常量 th:attrappend th:classappend th:styleappend Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf参考手册/其它th标签.html":{"url":"chapter07/Thymeleaf参考手册/其它th标签.html","title":"其它 th 标签","keywords":"","body":"其它 th 标签 th:abbr th:accept th:accept-charset th:abbr th:accept th:accept-charset th:accesskey th:action th:align th:alt th:archive th:audio th:autocomplete th:axis th:background th:bgcolor th:border th:cellpadding th:cellspacing th:challenge th:charset th:cite th:class th:classid th:codebase th:codetype th:cols th:colspan th:compact th:content th:contenteditable th:contextmenu th:data th:datetime th:dir th:draggable th:dropzone th:enctype th:for th:form th:formaction th:formenctype th:formmethod th:formtarget th:frame th:frameborder th:headers th:height th:high th:href th:hreflang th:hspace th:http-equiv th:icon th:id th:keytype th:kind th:label th:lang th:list th:longdesc th:low th:manifest th:marginheight th:marginwidth th:max th:maxlength th:media th:method th:min th:name th:optimum th:pattern th:placeholder th:poster th:preload th:radiogroup th:rel th:rev th:rows th:rowspan th:rules th:sandbox th:scheme th:scope th:scrolling th:size th:sizes th:span th:spellcheck th:src th:srclang th:standby th:start th:step th:style th:summary th:tabindex th:target th:title th:type th:usemap th:value th:valuetype th:vspace th:width th:wrap th:xmlbase th:xmllang th:xmlspace th:alt-title 或th:lang-xmllang（如果其中两个属性值相同） 对于 html5 元素名称的另一种友好写法 ... ... Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf参考手册/表达式语法.html":{"url":"chapter07/Thymeleaf参考手册/表达式语法.html","title":"表达式语法","keywords":"","body":"表达式语法 简单表达式语法 #{...} : Message 表达式 Welcome to our grocery store, Sebastian Pepper! Welcome to our grocery store, Sebastian Pepper! ${} : 变量表达式 ongl 标准语法，方法也可以被调用 *{} : 选择变量表达式 Name: Sebastian. Surname: Pepper. Nationality: Saturn. 等价于 Name: Sebastian. Surname: Pepper. Nationality: Saturn. 当然了，这两者可以混合使用 还有一种方式 Name: Sebastian. Surname: Pepper. Nationality: Saturn. @{} : 链接 URL 表达式 view view view 变量 分类 示例 文本 ‘one text’ , ‘Another one!’ ,… 数字 0 , 34 , 3.0 , 12.3 ,… 真假 true , false 文字符号 one , sometext , main ,… 字符连接 分类 示例 + ‘The name is ‘+${name} |…| |The name is ${name}| 算数运算 语法 示例 +, -, *, /, % 二元运算符 - 减号（一元运算符） 真假运算 分类 示例 and , or 二元运算符 ! , not 否定（一元运算符） 比较运算 分类 示例 >, =, 比较 == , != ( eq , ne ) 平等 条件运算 分类 示例 if-then (if) ? (then) if-then-else (if) ? (then) : (else) Default (value) ?: (defaultvalue) 综合示例 'User is of type ' + (${user.isAdmin()} ? 'Administrator' : (${user.type} ?: 'Unknown')) Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf参考手册/内置对象.html":{"url":"chapter07/Thymeleaf参考手册/内置对象.html","title":"内置对象","keywords":"","body":"内置对象 #dates /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Dates * ====================================================================== */ /* * Format date with the standard locale format * Also works with arrays, lists or sets */ ${#dates.format(date)} ${#dates.arrayFormat(datesArray)} ${#dates.listFormat(datesList)} ${#dates.setFormat(datesSet)} /* * Format date with the ISO8601 format * Also works with arrays, lists or sets */ ${#dates.formatISO(date)} ${#dates.arrayFormatISO(datesArray)} ${#dates.listFormatISO(datesList)} ${#dates.setFormatISO(datesSet)} /* * Format date with the specified pattern * Also works with arrays, lists or sets */ ${#dates.format(date, 'dd/MMM/yyyy HH:mm')} ${#dates.arrayFormat(datesArray, 'dd/MMM/yyyy HH:mm')} ${#dates.listFormat(datesList, 'dd/MMM/yyyy HH:mm')} ${#dates.setFormat(datesSet, 'dd/MMM/yyyy HH:mm')} /* * Obtain date properties * Also works with arrays, lists or sets */ ${#dates.day(date)} // also arrayDay(...), listDay(...), etc. ${#dates.month(date)} // also arrayMonth(...), listMonth(...), etc. ${#dates.monthName(date)} // also arrayMonthName(...), listMonthName(...), etc. ${#dates.monthNameShort(date)} // also arrayMonthNameShort(...), listMonthNameShort(...), etc. ${#dates.year(date)} // also arrayYear(...), listYear(...), etc. ${#dates.dayOfWeek(date)} // also arrayDayOfWeek(...), listDayOfWeek(...), etc. ${#dates.dayOfWeekName(date)} // also arrayDayOfWeekName(...), listDayOfWeekName(...), etc. ${#dates.dayOfWeekNameShort(date)} // also arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...), etc. ${#dates.hour(date)} // also arrayHour(...), listHour(...), etc. ${#dates.minute(date)} // also arrayMinute(...), listMinute(...), etc. ${#dates.second(date)} // also arraySecond(...), listSecond(...), etc. ${#dates.millisecond(date)} // also arrayMillisecond(...), listMillisecond(...), etc. /* * Create date (java.util.Date) objects from its components */ ${#dates.create(year,month,day)} ${#dates.create(year,month,day,hour,minute)} ${#dates.create(year,month,day,hour,minute,second)} ${#dates.create(year,month,day,hour,minute,second)} ${#dates.create(year,month,day,hour,minute,second,millisecond)} /* * Create a date (java.util.Date) object for the current date and time */ ${#dates.createNow()} /* * Create a date (java.util.Date) object for the current date (time set to 00:00) */ ${#dates.createToday()} #Calendars /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Calendars * ====================================================================== */ /* * Format calendar with the standard locale format * Also works with arrays, lists or sets */ ${#calendars.format(cal)} ${#calendars.arrayFormat(calArray)} ${#calendars.listFormat(calList)} ${#calendars.setFormat(calSet)} /* * Format calendar with the ISO8601 format * Also works with arrays, lists or sets */ ${#calendars.formatISO(cal)} ${#calendars.arrayFormatISO(calArray)} ${#calendars.listFormatISO(calList)} ${#calendars.setFormatISO(calSet)} /* * Format calendar with the specified pattern * Also works with arrays, lists or sets */ ${#calendars.format(cal, 'dd/MMM/yyyy HH:mm')} ${#calendars.arrayFormat(calArray, 'dd/MMM/yyyy HH:mm')} ${#calendars.listFormat(calList, 'dd/MMM/yyyy HH:mm')} ${#calendars.setFormat(calSet, 'dd/MMM/yyyy HH:mm')} /* * Obtain calendar properties * Also works with arrays, lists or sets */ ${#calendars.day(date)} // also arrayDay(...), listDay(...), etc. ${#calendars.month(date)} // also arrayMonth(...), listMonth(...), etc. ${#calendars.monthName(date)} // also arrayMonthName(...), listMonthName(...), etc. ${#calendars.monthNameShort(date)} // also arrayMonthNameShort(...), listMonthNameShort(...), etc. ${#calendars.year(date)} // also arrayYear(...), listYear(...), etc. ${#calendars.dayOfWeek(date)} // also arrayDayOfWeek(...), listDayOfWeek(...), etc. ${#calendars.dayOfWeekName(date)} // also arrayDayOfWeekName(...), listDayOfWeekName(...), etc. ${#calendars.dayOfWeekNameShort(date)} // also arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...), etc. ${#calendars.hour(date)} // also arrayHour(...), listHour(...), etc. ${#calendars.hour(date)} // also arrayHour(...), listHour(...), etc. ${#calendars.minute(date)} // also arrayMinute(...), listMinute(...), etc. ${#calendars.second(date)} // also arraySecond(...), listSecond(...), etc. ${#calendars.millisecond(date)} // also arrayMillisecond(...), listMillisecond(...), etc. /* * Create calendar (java.util.Calendar) objects from its components */ ${#calendars.create(year,month,day)} ${#calendars.create(year,month,day,hour,minute)} ${#calendars.create(year,month,day,hour,minute,second)} ${#calendars.create(year,month,day,hour,minute,second,millisecond)} /* * Create a calendar (java.util.Calendar) object for the current date and time */ ${#calendars.createNow()} /* * Create a calendar (java.util.Calendar) object for the current date (time set to 00:00) */ ${#calendars.createToday()} #numbers /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Numbers * ====================================================================== */ /* * ========================== * Formatting integer numbers * ========================== */ /* * Set minimum integer digits. * Also works with arrays, lists or sets */ ${#numbers.formatInteger(num,3)} ${#numbers.arrayFormatInteger(numArray,3)} ${#numbers.listFormatInteger(numList,3)} ${#numbers.setFormatInteger(numSet,3)} /* * Set minimum integer digits and thousands separator: * 'POINT', 'COMMA', 'WHITESPACE', 'NONE' or 'DEFAULT' (by locale). * Also works with arrays, lists or sets */ ${#numbers.formatInteger(num,3,'POINT')} ${#numbers.arrayFormatInteger(numArray,3,'POINT')} ${#numbers.listFormatInteger(numList,3,'POINT')} ${#numbers.setFormatInteger(numSet,3,'POINT')} /* * ========================== * Formatting decimal numbers * ========================== */ /* * Set minimum integer digits and (exact) decimal digits. * Also works with arrays, lists or sets */ ${#numbers.formatDecimal(num,3,2)} ${#numbers.arrayFormatDecimal(numArray,3,2)} ${#numbers.listFormatDecimal(numList,3,2)} ${#numbers.setFormatDecimal(numSet,3,2)} /* * Set minimum integer digits and (exact) decimal digits, and also decimal separator. * Also works with arrays, lists or sets */ ${#numbers.formatDecimal(num,3,2,'COMMA')} ${#numbers.arrayFormatDecimal(numArray,3,2,'COMMA')} ${#numbers.listFormatDecimal(numList,3,2,'COMMA')} ${#numbers.setFormatDecimal(numSet,3,2,'COMMA')} /* * Set minimum integer digits and (exact) decimal digits, and also thousands and * decimal separator. * Also works with arrays, lists or sets */ ${#numbers.formatDecimal(num,3,'POINT',2,'COMMA')} ${#numbers.arrayFormatDecimal(numArray,3,'POINT',2,'COMMA')} ${#numbers.listFormatDecimal(numList,3,'POINT',2,'COMMA')} ${#numbers.setFormatDecimal(numSet,3,'POINT',2,'COMMA')} /* * ========================== * Utility methods * ========================== */ /* * Create a sequence (array) of integer numbers going * from x to y */ ${#numbers.sequence(from,to)} ${#numbers.sequence(from,to,step)} #strings /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Strings * ====================================================================== */ /* * Null-safe toString() */ ${#strings.toString(obj)} // also array*, list* and set* /* * Check whether a String is empty (or null). Performs a trim() operation before check * Also works with arrays, lists or sets * * Also works with arrays, lists or sets */ ${#strings.isEmpty(name)} ${#strings.arrayIsEmpty(nameArr)} ${#strings.listIsEmpty(nameList)} ${#strings.setIsEmpty(nameSet)} /* * Perform an 'isEmpty()' check on a string and return it if false, defaulting to * another specified string if true. * Also works with arrays, lists or sets */ ${#strings.defaultString(text,default)} ${#strings.arrayDefaultString(textArr,default)} ${#strings.listDefaultString(textList,default)} ${#strings.setDefaultString(textSet,default)} /* * Check whether a fragment is contained in a String * Also works with arrays, lists or sets */ ${#strings.contains(name,'ez')} // also array*, list* and set* ${#strings.containsIgnoreCase(name,'ez')} // also array*, list* and set* /* * Check whether a String starts or ends with a fragment * Also works with arrays, lists or sets */ ${#strings.startsWith(name,'Don')} // also array*, list* and set* ${#strings.endsWith(name,endingFragment)} // also array*, list* and set* /* * Substring-related operations * Also works with arrays, lists or sets */ ${#strings.indexOf(name,frag)} // also array*, list* and set* ${#strings.substring(name,3,5)} // also array*, list* and set* ${#strings.substringAfter(name,prefix)} // also array*, list* and set* ${#strings.substringBefore(name,suffix)} // also array*, list* and set* ${#strings.replace(name,'las','ler')} // also array*, list* and set* /* * Append and prepend * Also works with arrays, lists or sets */ ${#strings.prepend(str,prefix)} // also array*, list* and set* ${#strings.append(str,suffix)} // also array*, list* and set* /* * Change case * Also works with arrays, lists or sets */ ${#strings.toUpperCase(name)} // also array*, list* and set* ${#strings.toLowerCase(name)} // also array*, list* and set* /* * Split and join */ ${#strings.arrayJoin(namesArray,',')} ${#strings.listJoin(namesList,',')} ${#strings.setJoin(namesSet,',')} ${#strings.arraySplit(namesStr,',')} // returns String[] ${#strings.listSplit(namesStr,',')} // returns List ${#strings.setSplit(namesStr,',')} // returns Set /* * Trim * Also works with arrays, lists or sets */ ${#strings.trim(str)} // also array*, list* and set* /* * Compute length * Also works with arrays, lists or sets */ ${#strings.length(str)} // also array*, list* and set* /* * Abbreviate text making it have a maximum size of n. If text is bigger, it * will be clipped and finished in \"...\" * Also works with arrays, lists or sets */ ${#strings.abbreviate(str,10)} // also array*, list* and set* /* * Convert the first character to upper-case (and vice-versa) */ ${#strings.capitalize(str)} // also array*, list* and set* ${#strings.unCapitalize(str)} // also array*, list* and set* /* * Convert the first character of every word to upper-case */ ${#strings.capitalizeWords(str)} // also array*, list* and set* ${#strings.capitalizeWords(str,delimiters)} // also array*, list* and set* /* * Escape the string */ ${#strings.escapeXml(str)} // also array*, list* and set* ${#strings.escapeJava(str)} // also array*, list* and set* ${#strings.escapeJavaScript(str)} // also array*, list* and set* ${#strings.unescapeJava(str)} // also array*, list* and set* ${#strings.unescapeJavaScript(str)} // also array*, list* and set* /* * Null-safe comparison and concatenation */ ${#strings.equals(first, second)} ${#strings.equalsIgnoreCase(first, second)} ${#strings.concat(values...)} ${#strings.concatReplaceNulls(nullValue, values...)} /* * Random */ ${#strings.randomAlphanumeric(count)} #objects /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Objects * ====================================================================== */ /* * Return obj if it is not null, and default otherwise * Also works with arrays, lists or sets */ ${#objects.nullSafe(obj,default)} ${#objects.arrayNullSafe(objArray,default)} ${#objects.listNullSafe(objList,default)} ${#objects.setNullSafe(objSet,default)} #bools /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Bools * ====================================================================== */ /* * Evaluate a condition in the same way that it would be evaluated in a th:if tag * (see conditional evaluation chapter afterwards). * Also works with arrays, lists or sets */ ${#bools.isTrue(obj)} ${#bools.arrayIsTrue(objArray)} ${#bools.listIsTrue(objList)} ${#bools.setIsTrue(objSet)} /* * Evaluate with negation * Also works with arrays, lists or sets */ ${#bools.isFalse(cond)} ${#bools.arrayIsFalse(condArray)} ${#bools.listIsFalse(condList)} ${#bools.setIsFalse(condSet)} /* * Evaluate and apply AND operator * Receive an array, a list or a set as parameter */ ${#bools.arrayAnd(condArray)} ${#bools.listAnd(condList)} ${#bools.setAnd(condSet)} /* * Evaluate and apply OR operator * Receive an array, a list or a set as parameter */ ${#bools.arrayOr(condArray)} ${#bools.listOr(condList)} ${#bools.setOr(condSet)} #arrays /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Arrays * ====================================================================== */ /* * Converts to array, trying to infer array component class. * Note that if resulting array is empty, or if the elements * of the target object are not all of the same class, * this method will return Object[]. */ ${#arrays.toArray(object)} /* * Convert to arrays of the specified component class. */ ${#arrays.toStringArray(object)} ${#arrays.toIntegerArray(object)} ${#arrays.toLongArray(object)} ${#arrays.toDoubleArray(object)} ${#arrays.toFloatArray(object)} ${#arrays.toBooleanArray(object)} /* * Compute length */ ${#arrays.length(array)} /* * Check whether array is empty */ ${#arrays.isEmpty(array)} /* * Check if element or elements are contained in array */ ${#arrays.contains(array, element)} ${#arrays.containsAll(array, elements)} #lists /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Lists * ====================================================================== */ /* * Converts to list */ ${#lists.toList(object)} /* * Compute size */ ${#lists.size(list)} /* * Check whether list is empty */ ${#lists.isEmpty(list)} /* * Check if element or elements are contained in list */ ${#lists.contains(list, element)} ${#lists.containsAll(list, elements)} /* * Sort a copy of the given list. The members of the list must implement * comparable or you must define a comparator. */ ${#lists.sort(list)} ${#lists.sort(list, comparator)} #sets /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Sets * ====================================================================== */ /* * Converts to set */ ${#sets.toSet(object)} /* * Compute size */ ${#sets.size(set)} /* * Check whether set is empty */ ${#sets.isEmpty(set)} /* * Check if element or elements are contained in set */ ${#sets.contains(set, element)} ${#sets.containsAll(set, elements)} #maps /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Maps * ====================================================================== */ /* * Compute size */ ${#maps.size(map)} /* * Check whether map is empty */ ${#maps.isEmpty(map)} /* * Check if key/s or value/s are contained in maps */ ${#maps.containsKey(map, key)} ${#maps.containsAllKeys(map, keys)} ${#maps.containsValue(map, value)} ${#maps.containsAllValues(map, value)} #aggregates /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Aggregates * ====================================================================== */ /* * Compute sum. Returns null if array or collection is empty */ ${#aggregates.sum(array)} ${#aggregates.sum(collection)} /* * Compute average. Returns null if array or collection is empty */ ${#aggregates.avg(array)} ${#aggregates.avg(collection)} #messages /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Messages * ====================================================================== */ /* * Obtain externalized messages. Can receive a single key, a key plus arguments, * or an array/list/set of keys (in which case it will return an array/list/set of * externalized messages). * If a message is not found, a default message (like '??msgKey??') is returned. */ ${#messages.msg('msgKey')} ${#messages.msg('msgKey', param1)} ${#messages.msg('msgKey', param1, param2)} ${#messages.msg('msgKey', param1, param2, param3)} ${#messages.msgWithParams('msgKey', new Object[] {param1, param2, param3, param4})} ${#messages.arrayMsg(messageKeyArray)} ${#messages.listMsg(messageKeyList)} ${#messages.setMsg(messageKeySet)} /* * Obtain externalized messages or null. Null is returned instead of a default * message if a message for the specified key is not found. */ ${#messages.msgOrNull('msgKey')} ${#messages.msgOrNull('msgKey', param1)} ${#messages.msgOrNull('msgKey', param1, param2)} ${#messages.msgOrNull('msgKey', param1, param2, param3)} ${#messages.msgOrNullWithParams('msgKey', new Object[] {param1, param2, param3, param4})} ${#messages.arrayMsgOrNull(messageKeyArray)} ${#messages.listMsgOrNull(messageKeyList)} ${#messages.setMsgOrNull(messageKeySet)} #ids /* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Ids * ====================================================================== */ /* * Normally used in th:id attributes, for appending a counter to the id attribute value * so that it remains unique even when involved in an iteration process. */ ${#ids.seq('someId')} /* * Normally used in th:for attributes in tags, so that these labels can refer to Ids * generated by means if the #ids.seq(...) function. * * Depending on whether the goes before or after the element with the #ids.seq(...) * function, the \"next\" (label goes before \"seq\") or the \"prev\" function (label goes after * \"seq\") function should be called. */ ${#ids.next('someId')} ${#ids.prev('someId')} Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf参考手册/循环.html":{"url":"chapter07/Thymeleaf参考手册/循环.html","title":"循环","keywords":"","body":"循环 Onions 2.41 yes 迭代器的状态 index: 当前的索引，从0开始 count: 当前的索引，从1开始 size：总数 current: even/odd: first last NAME PRICE IN STOCK Onions 2.41 yes Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf参考手册/判断.html":{"url":"chapter07/Thymeleaf参考手册/判断.html","title":"判断","keywords":"","body":"判断 if view unless view switch User is an administrator User is a manager User is an administrator User is a manager User is some other thing Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf参考手册/模板布局.html":{"url":"chapter07/Thymeleaf参考手册/模板布局.html","title":"模板布局","keywords":"","body":"模板布局 th:fragment 示例 templates/footer.html © 2011 The Good Thymes Virtual Grocery templates/index.html中使用 ... 或者 ... © 2011 The Good Thymes Virtual Grocery ... 使用 ... th:include 和 th:replace 区别 th:include 加入代码 th:replace 替换代码 模板传参：参数传递顺序不强制 定义 ... 使用 ... ... 等价于 ） Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf参考手册/thblock.html":{"url":"chapter07/Thymeleaf参考手册/thblock.html","title":"th:block","keywords":"","body":"th:block ... ... ... 推荐下面写法（编译前看不见） ... ... ... /*/--> Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf参考手册/thinline.html":{"url":"chapter07/Thymeleaf参考手册/thinline.html","title":"th:inline","keywords":"","body":"th:inline th:inline 可以等于 text , javascript(dart) , none text: [[…]] Hello, [[#{test}]] javascript: /[[…]]/ var username = /*[[ #{test} ]]*/; var name = /*[[ ${param.name[0]}+${execInfo.templateName}+'-'+${#dates.createNow()}+'-'+${#locale} ]]*/; /**/ adding code: /* [+…+]*/ var x = 23; /*[+ var msg = 'Hello, ' + [[${session.user.name}]]; +]*/ var f = function() { ... removind code: /[- / and /* -]*/ var x = 23; /*[- */ var msg = 'This is a non-working template'; /* -]*/ var f = function() { ... Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter07/Thymeleaf自定义标签.html":{"url":"chapter07/Thymeleaf自定义标签.html","title":"Thymeleaf 自定义标签","keywords":"","body":"Thymeleaf 自定义标签 我们知道在 JSP 中，可以使用 JSTL 标签简化开发，并且 JSTL 还具备自定义标签的功能，那 Thymeleaf 如何实现自定义标签呢 Maven org.thymeleaf thymeleaf-spring4 3.0.9.RELEASE nz.net.ultraq.thymeleaf thymeleaf-layout-dialect 2.3.0 创建方言类 方言类需要继承 Thymeleaf 的 AbstractProcessorDialect package com.ooqiu.gaming.server.web.admin.config.thymeleaf.dialect; import com.ooqiu.gaming.server.web.admin.config.thymeleaf.tag.SysDictTagProcessor; import org.thymeleaf.dialect.AbstractProcessorDialect; import org.thymeleaf.processor.IProcessor; import org.thymeleaf.standard.StandardDialect; import org.thymeleaf.standard.processor.StandardXmlNsTagProcessor; import org.thymeleaf.templatemode.TemplateMode; import java.util.HashSet; import java.util.Set; /** * Thymeleaf 方言：系统用 * Title: SysDialect * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 9:34 */ public class SysDialect extends AbstractProcessorDialect { // 定义方言名称 private static final String DIALECT_NAME = \"Sys Dialect\"; public SysDialect() { // 设置自定义方言与“方言处理器”优先级相同 super(DIALECT_NAME, \"sys\", StandardDialect.PROCESSOR_PRECEDENCE); } /** * 元素处理器 * @param dialectPrefix 方言前缀 * @return */ @Override public Set getProcessors(String dialectPrefix) { Set processors = new HashSet(); // 添加自定义标签处理器 processors.add(new SysDictTagProcessor(dialectPrefix)); processors.add(new StandardXmlNsTagProcessor(TemplateMode.HTML, dialectPrefix)); return processors; } } 创建标签处理器 标签处理器需要继承 Thymeleaf 的 AbstractElementTagProcessor package com.ooqiu.gaming.server.web.admin.config.thymeleaf.tag; import org.thymeleaf.context.ITemplateContext; import org.thymeleaf.model.IModel; import org.thymeleaf.model.IModelFactory; import org.thymeleaf.model.IProcessableElementTag; import org.thymeleaf.processor.element.AbstractElementTagProcessor; import org.thymeleaf.processor.element.IElementTagStructureHandler; import org.thymeleaf.templatemode.TemplateMode; /** * 自定义标签 * Title: SysDictTagProcessor * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 10:52 */ public class SysDictTagProcessor extends AbstractElementTagProcessor { // 标签名 private static final String TAG_NAME = \"dict\"; // 优先级 private static final int PRECEDENCE = 10000; public SysDictTagProcessor(String dialectPrefix) { super( // 此处理器将仅应用于HTML模式 TemplateMode.HTML, // 要应用于名称的匹配前缀 dialectPrefix, // 标签名称：匹配此名称的特定标签 TAG_NAME, // 将标签前缀应用于标签名称 true, // 无属性名称：将通过标签名称匹配 null, // 没有要应用于属性名称的前缀 false, // 优先(内部方言自己的优先) PRECEDENCE ); } /** * 处理自定义标签 DOM 结构 * * @param iTemplateContext 模板页上下文 * @param iProcessableElementTag 待处理标签 * @param iElementTagStructureHandler 元素标签结构处理器 */ @Override protected void doProcess(ITemplateContext iTemplateContext, IProcessableElementTag iProcessableElementTag, IElementTagStructureHandler iElementTagStructureHandler) { // 创建将替换自定义标签的 DOM 结构 IModelFactory modelFactory = iTemplateContext.getModelFactory(); IModel model = modelFactory.createModel(); // 需要替换的页面元素 model.add(modelFactory.createOpenElementTag(\"div\")); model.add(modelFactory.createText(\"Hello Thymeleaf Dialect\")); model.add(modelFactory.createCloseElementTag(\"div\")); // 利用引擎替换整个标签 iElementTagStructureHandler.replaceWith(model, false); } } 注入方言 package com.ooqiu.gaming.server.web.admin.config.thymeleaf; import com.ooqiu.gaming.server.web.admin.config.thymeleaf.dialect.SysDialect; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * Thymeleaf 方言配置 * Title: ThymeleafDialectConfig * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 10:57 */ @Configuration public class ThymeleafDialectConfig { /** * 系统方言 * * @return */ @Bean public SysDialect sysDialect() { return new SysDialect(); } } 前台 HTML 中声明使用 增加命名空间配置：xmlns:sys=\"\" 使用标签 实例用法 详见：项目实战-实现文章管理功能-自定义Thymeleaf字典标签 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:18:07 "},"chapter08/集成Druid.html":{"url":"chapter08/集成Druid.html","title":"集成 Druid","keywords":"","body":"集成 Druid Starter POM com.alibaba druid-spring-boot-starter 1.1.5 application.yml spring: datasource: druid: url: jdbc:mysql://ip:port/dbname?useUnicode=true&characterEncoding=utf-8&useSSL=false username: root password: 123456 initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true driver-class-name: com.mysql.jdbc.Driver Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter08/集成tkmybatis.html":{"url":"chapter08/集成tkmybatis.html","title":"集成 tk.mybatis","keywords":"","body":"集成 tk.mybatis 我们使用 tk.mybatis 简化 mybatis 开发，所以我们在 pom 中仅添加 tk.mybatis 的 starter pom Starter POM tk.mybatis mapper-spring-boot-starter 1.1.5 mysql mysql-connector-java application.yml mybatis: type-aliases-package: com.lusifer.spring.boot.pojo mapper-locations: classpath:mapper/*.xml 创建 MyMapper 通用接口 package com.lusifer.spring.boot.utils; import tk.mybatis.mapper.common.Mapper; import tk.mybatis.mapper.common.MySqlMapper; /** * 自己的 Mapper * 特别注意，该接口不能被扫描到，否则会出错 * Title: MyMapper * Description: * * @author Lusifer * @version 1.0.0 * @date 2017/11/7 10:43 */ public interface MyMapper extends Mapper, MySqlMapper { } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter08/集成PageHelper.html":{"url":"chapter08/集成PageHelper.html","title":"集成 PageHelper","keywords":"","body":"集成 PageHelper 我们使用 PageHelper 做数据库分页插件 Starter POM com.github.pagehelper pagehelper-spring-boot-starter 1.2.3 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter08/MyBatisMavenPlugin自动生成代码.html":{"url":"chapter08/MyBatisMavenPlugin自动生成代码.html","title":"MyBatis 插件自动生成代码","keywords":"","body":"MyBatis Maven Plugin 自动生成代码 我们使用 MyBatis 的 Maven 插件来生成数据库访问代码 POM org.mybatis.generator mybatis-generator-maven-plugin 1.3.5 ${basedir}/src/main/resources/generator/generatorConfig.xml true true mysql mysql-connector-java ${mysql.version} tk.mybatis mapper 3.4.4 自动生成配置 在 src/main/resources/generator/ 目录下创建 generatorConfig.xml 配置文件： 数据源配置 在 src/main/resources 目录下创建 jdbc.properties 数据源配置： jdbc.driverClass=com.mysql.jdbc.Driver jdbc.connectionURL=jdbc:mysql://ip:port/dbname?useUnicode=true&characterEncoding=utf-8&useSSL=false jdbc.username=root jdbc.password=123456 生成代码 mvn mybatis-generator:generate Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter08/测试查询.html":{"url":"chapter08/测试查询.html","title":"测试查询","keywords":"","body":"测试查询 Application 中增加注解 @MapperScan @MapperScan(basePackages = \"com.lusifer.spring.boot.mybatis.mapper\") JUnit 测试代码 @RunWith(SpringRunner.class) @SpringBootTest public class GamingServerDatabaseApplicationTests { @Autowired private ChannelMapper channelMapper; @Test public void contextLoads() { List channels = channelMapper.selectAll(); System.out.println(channels); } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter09/项目简介.html":{"url":"chapter09/项目简介.html","title":"项目简介","keywords":"","body":"项目简介 功能架构 功能描述 技术选型 开发环境 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:20:07 "},"chapter09/项目简介/功能架构.html":{"url":"chapter09/项目简介/功能架构.html","title":"功能架构","keywords":"","body":"功能架构 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter09/项目简介/功能描述.html":{"url":"chapter09/项目简介/功能描述.html","title":"功能描述","keywords":"","body":"功能描述 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter09/项目简介/技术选型.html":{"url":"chapter09/项目简介/技术选型.html","title":"技术选型","keywords":"","body":"技术选型 管理模板 基于 Bootstrap 的前端流行框架 MetroNic 为后台管理模板 核心框架 使用 Spring Boot 构建整个项目，去除 XML 配置 视图框架 使用 Spring MVC 构建视图层 持久化框架 使用 MyBatis 做 ORM 关系映射并使用二次封装的工具类 tk.mybatis 简化持久化开发 数据库连接池 使用阿里巴巴 Druid 作为 MySQL 数据库连接池，原因你懂的 页面引擎 因为 Spring Boot 项目都是打包成 Jar 文件运行，我们选择使用和 Spring MVC 契合度最高的 Thymeleaf 作为前端模板引擎 全文检索 使用基于 Lucence 的全文检索引擎 Solr 为整个系统提供搜索服务 数据库 使用在互联网领域最受欢迎的 MySQL 为系统数据库 数据缓存 采用 Redis 集群方案做数据缓存服务 项目构建及管理工具 使用 Maven 统一管理 Jar 版本并打包及构建项目 存储服务 内部系统使用 FastDFS 管理图片及文件存储，外部采用阿里云 OSS 作文件存储服务 消息中间件 消息队列使用 RabbitMQ ，Broker 方面直接采用官方的 RabbitMQ Management 接口文档引擎 在开发阶段采用 Swagger2 自动生成 API 接口文档，方便开发人员查看，提高开发效率 负载均衡 使用反向代理服务 Nginx 为负载均衡服务器并配合容器化引擎提供高并发、高性能、高可用服务 容器化引擎 使用 Docker 为容器化引擎并配合 Docker Compose 管理容器。容器编排解决方案使用 k8s(Kubernetes) RPC 通信 微服务架构层面，各个模块的通信采用基于 RPC 通信协议的 Dubbo 为主要通信框架。由于使用的是开源版本，所以其中的服务治理方案采用 Zookeeper 桥接实现，可靠性也依赖于 Zookeeper。 代码管理 代码管理方面采用社区版的 GitLab 为代码托管服务器，代码的交付使用 Git Flow 工作流模式 CI/CD 持续集成与持续交付 本部门使用 GitLab 自带的 Runner 做持续集成的测试发布，运维部门采用 Jenkins 作为生产环境的持续交付方案 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter09/项目简介/开发环境.html":{"url":"chapter09/项目简介/开发环境.html","title":"开发环境","keywords":"","body":"开发环境 操作系统：Windows 10 JDK 版本：1.8 IDE 工具：Intellij IDEA 2017 数据库：MySQL 5.7 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter09/搭建项目.html":{"url":"chapter09/搭建项目.html","title":"搭建项目","keywords":"","body":"搭建项目 创建依赖管理项目 创建通用工具项目 创建数据库管理项目 创建领域模型项目 创建管理后台接口项目 创建管理后台实现项目 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:20:07 "},"chapter09/搭建项目/创建依赖管理项目.html":{"url":"chapter09/搭建项目/创建依赖管理项目.html","title":"创建依赖管理项目","keywords":"","body":"创建依赖管理项目 我们需要一个统一的第三方 Jar 的依赖版本管理项目 项目名称 gaming-server-dependencies POM 4.0.0 com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT pom gaming-server-dependencies org.springframework.boot spring-boot-starter-parent 1.5.10.RELEASE UTF-8 UTF-8 1.8 1.1.5 1.2.3 1.1.5 3.3.2 23.5-jre 0.26 2.24.0 3.4.4 com.alibaba druid-spring-boot-starter ${spring-boot-alibaba-druid.version} tk.mybatis mapper ${tk-mybatis.version} tk.mybatis mapper-spring-boot-starter ${spring-boot-tk-mybatis.version} com.github.pagehelper pagehelper-spring-boot-starter ${spring-boot-pagehelper.version} org.hibernate hibernate-validator ${hibernate-validator.version} org.apache.commons commons-lang3 ${commons-lang3.version} com.fasterxml.jackson.core jackson-databind ${jackson.version} com.esotericsoftware.kryo kryo ${kryo.version} de.javakaffee kryo-serializers ${kryo-serializers.version} net.sourceforge.nekohtml nekohtml ${nekohtml.version} org.projectlombok lombok ${lombok.version} com.google.guava guava ${google-guava.version} mysql mysql-connector-java ${mysql.version} ${project.artifactId} org.apache.maven.plugins maven-resources-plugin ${maven-resources-plugin.version} UTF-8 org.apache.maven.plugins maven-compiler-plugin ${maven-compiler-plugin.version} ${java.version} ${java.version} UTF-8 org.apache.maven.plugins maven-surefire-plugin ${maven-surefire-plugin.version} true Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter09/搭建项目/创建通用工具项目.html":{"url":"chapter09/搭建项目/创建通用工具项目.html","title":"创建通用工具项目","keywords":"","body":"创建通用工具项目 项目名称 gaming-server-commons POM 4.0.0 com.ooqiu.gaming gaming-server-commons 1.0.0-SNAPSHOT jar gaming-server-commons com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT org.apache.commons commons-lang3 com.fasterxml.jackson.core jackson-databind com.esotericsoftware.kryo kryo de.javakaffee kryo-serializers org.projectlombok lombok com.google.guava guava tk.mybatis mapper 创建 tk.mybatis 通用接口 创建 tk.mybatis.mapper 包 创建 MyMapper 接口 package tk.mybatis.mapper; import tk.mybatis.mapper.common.Mapper; import tk.mybatis.mapper.common.MySqlMapper; /** * 自己的 Mapper * 特别注意，该接口不能被扫描到，否则会出错 * Title: MyMapper * Description: * * @author Lusifer * @version 1.0.0 * @date 2017/11/7 10:43 */ public interface MyMapper extends Mapper, MySqlMapper { } 目录结构 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter09/搭建项目/创建数据库管理项目.html":{"url":"chapter09/搭建项目/创建数据库管理项目.html","title":"创建数据库管理项目","keywords":"","body":"创建数据库管理项目 该项目的主要作用是 MyBatis 的代码自动生成 项目名称 gaming-server-database POM 4.0.0 com.ooqiu.gaming gaming-server-database 1.0.0-SNAPSHOT jar gaming-server-database com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT org.springframework.boot spring-boot-starter org.springframework.boot spring-boot-starter-test test com.alibaba druid-spring-boot-starter tk.mybatis mapper-spring-boot-starter com.github.pagehelper pagehelper-spring-boot-starter mysql mysql-connector-java org.mybatis.generator mybatis-generator-maven-plugin 1.3.5 ${basedir}/src/main/resources/generator/generatorConfig.xml true true mysql mysql-connector-java ${mysql.version} tk.mybatis mapper 3.4.4 application.yml spring: datasource: druid: url: jdbc:mysql://192.168.75.132:3306/toutiao?useUnicode=true&characterEncoding=utf-8&useSSL=false username: root password: 123456 initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true driver-class-name: com.mysql.jdbc.Driver mybatis: type-aliases-package: com.ooqiu.gaming.server.database.domain mapper-locations: classpath:mapper/*.xml 自定义 MyMapper 接口 package com.ooqiu.gaming.server.utils; import tk.mybatis.mapper.common.Mapper; import tk.mybatis.mapper.common.MySqlMapper; /** * 自己的 Mapper * 特别注意，该接口不能被扫描到，否则会出错 * Title: MyMapper * Description: * * @author Lusifer * @version 1.0.0 * @date 2017/11/7 10:43 */ public interface MyMapper extends Mapper, MySqlMapper { } 自动生成配置 在 src/main/resources/generator/ 目录下创建 generatorConfig.xml 配置文件： 数据源配置 在 src/main/resources 目录下创建 jdbc.properties 数据源配置： jdbc.driverClass=com.mysql.jdbc.Driver jdbc.connectionURL=jdbc:mysql://192.168.75.132:3306/toutiao?useUnicode=true&characterEncoding=utf-8&useSSL=false jdbc.username=root jdbc.password=123456 生成代码 mvn mybatis-generator:generate Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter09/搭建项目/创建领域模型项目.html":{"url":"chapter09/搭建项目/创建领域模型项目.html","title":"创建领域模型项目","keywords":"","body":"创建领域模型项目 该项目的主要作用为领域建模(实体类) 项目名称 gaming-server-domain POM 4.0.0 com.ooqiu.gaming gaming-server-domain 1.0.0-SNAPSHOT jar gaming-server-domain com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT org.hibernate hibernate-validator javax.persistence persistence-api 1.0 目录结构 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter09/搭建项目/创建管理后台接口项目.html":{"url":"chapter09/搭建项目/创建管理后台接口项目.html","title":"创建管理后台接口项目","keywords":"","body":"创建管理后台接口项目 该项目仅负责定义接口 项目名称 gaming-server-service-admin-api POM 4.0.0 com.ooqiu.gaming gaming-server-service-admin-api 1.0.0-SNAPSHOT jar gaming-server-service-admin-api com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-domain 1.0.0-SNAPSHOT com.github.pagehelper pagehelper-spring-boot-starter Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter09/搭建项目/创建管理后台实现项目.html":{"url":"chapter09/搭建项目/创建管理后台实现项目.html","title":"创建管理后台实现项目","keywords":"","body":"创建管理后台实现项目 该项目仅负责接口的实现 项目名称 gaming-server-service-admin POM 4.0.0 com.ooqiu.gaming gaming-server-service-admin 0.0.1-SNAPSHOT jar gaming-server-service-admin com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT org.springframework.boot spring-boot-starter org.springframework.boot spring-boot-starter-test test com.alibaba druid-spring-boot-starter tk.mybatis mapper-spring-boot-starter mysql mysql-connector-java com.ooqiu.gaming gaming-server-service-admin-api 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-commons 1.0.0-SNAPSHOT org.springframework.boot spring-boot-maven-plugin com.ooqiu.gaming.server.service.admin.GamingServerServiceAdminApplication 目录结构 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter09/Git的过滤文件.html":{"url":"chapter09/Git的过滤文件.html","title":"Git 的过滤文件","keywords":"","body":"Git的过滤文件 .gitattributes # Windows-specific files that require CRLF: *.bat eol=crlf *.txt eol=crlf # Unix-specific files that require LF: *.java eol=lf *.sh eol=lf .gitignore target/ !.mvn/wrapper/maven-wrapper.jar ### STS ### .apt_generated .classpath .factorypath .project .settings .springBeans ### IntelliJ IDEA ### .idea *.iws *.iml *.ipr ### JRebel ### rebel.xml ### MAC ### .DS_Store ### Other ### logs/ temp/ Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10.html":{"url":"chapter10.html","title":"第10章 项目实战-Dubbo 让服务间通信","keywords":"","body":"第十章 项目实战-Dubbo 让服务间通信 再谈微服务 背景介绍 面向服务架构与微服务 服务框架对比 框架功能比较 RPC 对比 REST Dubbo Dubbo 简介 Dubbox 简介 Dubbo 服务治理 Dubbo 核心功能 Dubbo 组件角色 Zookeeper 简介 设计目标 分布式协调技术 分布式锁的实现 应用举例 Zookeeper 安装 单机模式 伪集群模式 集群模式 Dubbo Admin 管理控制台 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:17:18 "},"chapter10/再谈微服务.html":{"url":"chapter10/再谈微服务.html","title":"再谈微服务","keywords":"","body":"再谈微服务 背景介绍 面向服务架构与微服务 服务框架对比 框架功能比较 RPC 对比 REST Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:17:17 "},"chapter10/再谈微服务/背景介绍.html":{"url":"chapter10/再谈微服务/背景介绍.html","title":"背景介绍","keywords":"","body":"背景介绍 技术为业务而生，架构也为业务而出现。随着业务的发展、用户量的增长，系统数量增多，调用依赖关系也变得复杂，为了确保系统高可用、高并发的要求，系统的架构也从单体时代慢慢迁移至服务SOA时代，根据不同服务对系统资源的要求不同，我们可以更合理的配置系统资源，使系统资源利用率最大化。 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web框架(MVC) 是关键。 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。 平台随着业务的发展从 All in One 环境就可以满足业务需求（以Java来说，可能只是一两个war包就解决了）；发展到需要拆分多个应用，并且采用MVC的方式分离前后端，加快开发效率；在发展到服务越来越多，不得不将一些核心或共用的服务拆分出来，提供实时流动监控计算等，其实发展到此阶段，如果服务拆分的足够精细，并且独立运行，这个时候至少可以理解为SOA（Service-Oriented Architecture）架构了。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/再谈微服务/面向服务架构与微服务.html":{"url":"chapter10/再谈微服务/面向服务架构与微服务.html","title":"面向服务架构与微服务","keywords":"","body":"面向服务架构与微服务 微服务与 SOA 有很多相同之处。两者都属于典型的、包含松耦合分布式组件的系统结构。在围绕着服务的概念创建架构这一方面，微服务提供了一种更清晰、定义更良好的方式。微服务的原则与敏捷软件开发思想是高度一致的，而它与SOA原则的演化的目标也是相同的，则减少传统的企业服务总线开发的高复杂性。两者之间最关键的区别在于，微服务专注于以自治的方式产生价值。但是两种架构背后的意图是不同的：SOA尝试将应用集成，一般采用中央管理模式来确保各应用能够交互运作。微服务尝试部署新功能，快速有效地扩展开发团队。它着重于分散管理、代码再利用与自动化执行。 功能 SOA 微服务 组件大小 大块业务逻辑 单独任务或小块业务逻辑 耦合 通常松耦合 总是松耦合 公司架构 任何类型 小型、专注于功能交叉的团队 管理 着重中央管理 着重分散管理 目标 确保应用能够交互操作 执行新功能，快速拓展开发团队 微服务并不是一种新思想的方法。它更像是一种思想的精炼，一种SOA的精细化演进，并且更好地利用了先进的技术以解决问题，例如容器与自动化等。所以对于我们去选择服务技术框架时，并不是非黑即白，而是针对 SOA、MSA 两种架构设计同时要考虑到兼容性，对于现有平台情况架构设计，退则守 SOA，进则攻 MSA，阶段性选择适合的。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/再谈微服务/服务框架对比.html":{"url":"chapter10/再谈微服务/服务框架对比.html","title":"服务框架对比","keywords":"","body":"服务框架对比 现在业界比较成熟的服务框架有很多，比如：Hessian、CXF、Dubbo、Dubbox、Spring Cloud、gRPC、thrift 等技术实现，都可以进行远程调用，具体技术实现优劣参考以下分析，这也是具体在技术方案选择过程中的重要依据。 Dubbo 是阿里巴巴公司开源的一个 Java 高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring 框架无缝集成。不过，略有遗憾的是，据说在淘宝内部，dubbo 由于跟淘宝另一个类似的框架 HSF（非开源）有竞争关系，导致 dubbo 团队已经解散，反到是当当网的扩展版本 Dubbox 仍在持续发展，墙内开花墙外香。其它的一些知名电商如当当、国美维护了自己的分支或者在 dubbo 的基础开发，但是官方的库缺乏维护，相关的依赖类比如 Spring，Netty 还是很老的版本(Spring 3.2.16.RELEASE, netty 3.2.5.Final)，倒是有些网友写了升级 Spring 和 Netty 的插件。 PS：沉寂 3 年后，与 2017 年 9 月正式恢复更新 Dubbox Dubbox 与 Dubbo 本质上没有区别，名字的含义扩展了 Dubbo 而已，以下扩展出来的功能，也是选择 Dubbox 很重要的考察点。 支持 REST 风格远程调用（HTTP + JSON/XML) 支持基于 Kryo 和 FST 的 Java 高效序列化实现 支持基于 Jackson 的 JSON 序列化 支持基于嵌入式 Tomcat 的 HTTP remoting 体系 升级 Spring 至 3.x 升级 ZooKeeper 客户端 支持完全基于 Java 代码的 Dubbo 配置 PS：阿里的 Dubbo 团队已将以上特性集成 Spring Cloud 完全基于 Spring Boot，是一个非常新的项目，2016 年推出 1.0 的 release 版本，目前 Github 上更新速度很快. 虽然 Spring Cloud 时间最短, 但是相比 Dubbo 等 RPC 框架, Spring Cloud 提供的全套的分布式系统解决方案。Spring Cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局琐，leader选举，分布式session，集群状态）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用．它们将在任何分布式环境中工作，包括开发人员自己的笔记本电脑，裸物理机的数据中心，和像 Cloud Foundry 云管理平台。在未来引领这微服务架构的发展，提供业界标准的一套微服务架构解决方案。 缺点是项目很年轻，很少见到国内业界有人在生产上成套使用，一般都是只有其中一两个组件。相关的技术文档大部分是英文的，案例也相对较少，使用的话需要摸索的时间会长一些。 下图是 Spring Cloud 和 Dubbo 对比： Motan 是新浪微博开源的一个 Java 框架。它诞生的比较晚，起于 2013 年，2016 年 5 月开源。Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。与 Dubbo 相比，Motan 在功能方面并没有那么全面，也没有实现特别多的扩展。用的人比较少，功能和稳定性有待观望。对跨语言调用支持较差，主要支持 Java。 Hessian 采用的是二进制 RPC 协议，适用于发送二进制数据。但本身也是一个 Web Service 框架对 RPC 调用提供支持，功能简单，使用起来也方便。基于 Http 协议进行传输。通过 Servlet 提供远程服务。通过 Hessain 本身提供的API来发起请求。响应端根据 Hessian 提供的 API 来接受请求。 rpcx 是 Go 语言生态圈的 Dubbo，比 Dubbo 更轻量，实现了 Dubbo 的许多特性，借助于 Go 语言优秀的并发特性和简洁语法，可以使用较少的代码实现分布式的RPC服务。 gRPC 是 Google 开发的高性能、通用的开源 RPC 框架，其由 Google 主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf(Protocol Buffers) 序列化协议开发，且支持众多开发语言。本身它不是分布式的，所以要实现上面的框架的功能需要进一步的开发。 thrift 是 Apache 的一个跨语言的高性能的服务框架，也得到了广泛的应用。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/再谈微服务/框架功能比较.html":{"url":"chapter10/再谈微服务/框架功能比较.html","title":"框架功能比较","keywords":"","body":"框架功能比较 功能 Hessian Montan rpcx gRPC Thrift Dubbo Dubbox Spring Cloud 开发语言 跨语言 Java Go 跨语言 跨语言 Java Java Java 分布式(服务治理) × √ √ × × √ √ √ 多序列化框架支持 hessian √(支持Hessian2、Json,可扩展) √ ×只支持protobuf) ×(thrift格式) √ √ √ 多种注册中心 × √ √ × × √ √ √ 管理中心 × √ √ × × √ √ √ 跨编程语言 √ ×(支持php client和C server) × √ √ × × × 支持REST × × × × × × √ √ 关注度 低 中 低 中 中 中 高 中 上手难度 低 低 中 中 中 低 低 中 运维成本 低 中 中 中 低 中 中 中 开源机构 Caucho Weibo Apache Google Apache Alibaba Dangdang Apache 实际场景中选择 Spring Cloud ： Spring 全家桶，用起来很舒服，只有你想不到，没有它做不到。可惜因为发布的比较晚，国内还没出现比较成功的案例，大部分都是试水，不过毕竟有 Spring 作背景，还是比较看好。 Dubbox：相对于 Dubbo 支持了 REST，估计是很多公司选择 Dubbox 的一个重要原因之一，但如果使用 Dubbo 的 RPC 调用方式，服务间仍然会存在 API 强依赖，各有利弊，懂的取舍吧。 Thrift： 如果你比较高冷，完全可以基于 Thrift 自己搞一套抽象的自定义框架吧。 Montan：可能因为出来的比较晚，目前除了新浪微博 16 年初发布的， Hessian：如果是初创公司或系统数量还没有超过 5 个，推荐选择这个，毕竟在开发速度、运维成本、上手难度等都是比较轻量、简单的，即使在以后迁移至 SOA，也是无缝迁移。 rpcx/gRPC：在服务没有出现严重性能的问题下，或技术栈没有变更的情况下，可能一直不会引入，即使引入也只是小部分模块优化使用。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/再谈微服务/RPC对比REST.html":{"url":"chapter10/再谈微服务/RPC对比REST.html","title":"RPC 对比 REST","keywords":"","body":"RPC 对比 REST 由于 Dubbo 是基础框架，其实现的内容对于我们实施微服务架构是否合理，也需要我们根据自身需求去考虑是否要修改，比如 Dubbo 的服务调用是通过 RPC 实现的，但是如果仔细拜读过 Martin Fowler 的 microservices 一文，其定义的服务间通信是 HTTP 协议的 REST API。那么这两种有何区别呢？ 服务提供方与调用方接口依赖方式太强 我们为每个微服务定义了各自的 service 抽象接口，并通过持续集成发布到私有仓库中，调用方应用对微服务提供的抽象接口存在强依赖关系，因此不论开发、测试、集成环境都需要严格的管理版本依赖，才不会出现服务方与调用方的不一致导致应用无法编译成功等一系列问题，以及这也会直接影响本地开发的环境要求，往往一个依赖很多服务的上层应用，每天都要更新很多代码并 install 之后才能进行后续的开发。若没有严格的版本管理制度或开发一些自动化工具，这样的依赖关系会成为开发团队的一大噩梦。而 REST 接口相比 RPC 更为轻量化，服务提供方和调用方的依赖只是依靠一纸契约，不存在代码级别的强依赖，当然 REST 接口也有痛点，因为接口定义过轻，很容易导致定义文档与实际实现不一致导致服务集成时的问题，但是该问题很好解决，只需要通过每个服务整合 swagger，让每个服务的代码与文档一体化，就能解决。所以在分布式环境下，REST 方式的服务依赖要比 RPC 方式的依赖更为灵活。 服务对平台敏感，难以简单复用 通常我们在提供对外服务时，都会以 REST 的方式提供出去，这样可以实现跨平台的特点，任何一个语言的调用方都可以根据接口定义来实现。那么在 Dubbo 中我们要提供 REST 接口时，不得不实现一层代理，用来将 RPC 接口转换成 REST 接口进行对外发布。若我们每个服务本身就以 REST 接口方式存在，当要对外提供服务时，主要在 API 网关中配置映射关系和权限控制就可实现服务的复用了。 Dubbo 实现了服务治理的基础，但是要完成一个完备的微服务架构，还需要在各环节去扩展和完善以保证集群的健康，以减轻开发、测试以及运维各个环节上增加出来的压力，这样才能让各环节人员真正的专注于业务逻辑。 而 Spring Cloud 依然发扬了 Spring Source 整合一切的作风，以标准化的姿态将一些微服务架构的成熟产品与框架揉为一体，并继承了 Spring Boot 简单配置、快速开发、轻松部署的特点，让原本复杂的架构工作变得相对容易上手一些。所以，如果选择 Dubbo 请务必在各个环节做好整套解决方案的准备，不然很可能随着服务数量的增长，整个团队都将疲于应付各种架构上不足引起的困难。而如果选择 Spring Cloud，相对来说每个环节都已经有了对应的组件支持，可能有些也不一定能满足你所有的需求，但是其活跃的社区与高速的迭代进度也会是你可以依靠的强大后盾。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/dubbo.html":{"url":"chapter10/dubbo.html","title":"Dubbo","keywords":"","body":"Dubbo Dubbo 简介 Dubbox 简介 Dubbo 服务治理 Dubbo 核心功能 Dubbo 组件角色 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:17:18 "},"chapter10/Dubbo/Dubbo简介.html":{"url":"chapter10/Dubbo/Dubbo简介.html","title":"Dubbo 简介","keywords":"","body":"Dubbo 简介 Dubbo 是 Alibaba 开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。 GitHub：https://github.com/alibaba/dubbo Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/Dubbo/Dubbox简介.html":{"url":"chapter10/Dubbo/Dubbox简介.html","title":"Dubbox 简介","keywords":"","body":"Dubbox 简介 无论是 Dubbo 还是 Dubbox，其本质都是远程调用框架，而对于远程调用如果没有分布式的需求，其实是不需要用这么重的框架，只有在分布式的时候，才有 Dubbo 这样的分布式服务框架的需求，说白了就是个远程服务调用的分布式框架，其重点在于分布式的治理。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/Dubbo/Dubbo服务治理.html":{"url":"chapter10/Dubbo/Dubbo服务治理.html","title":"Dubbo 服务治理","keywords":"","body":"Dubbo 服务治理 特性 描述 透明远程调用 就像调用本地方法一样调用远程方法；只需简单配置，没有任何 API 侵入 负载均衡机制 Client 端 LB，可在内网替代 F5 等硬件负载均衡器 容错重试机制 服务 Mock 数据，重试次数、超时机制等 自动注册发现 注册中心基于接口名查询服务提 供者的 IP 地址，并且能够平滑添加或删除服务提供者 性能日志监控 Monitor 统计服务的调用次调和调用时间的监控中心 服务治理中心 路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等手动配置 自动治理中心 无，比如：熔断限流机制、自动权重调整等 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/Dubbo/Dubbo核心功能.html":{"url":"chapter10/Dubbo/Dubbo核心功能.html","title":"Dubbo 核心功能","keywords":"","body":"Dubbo 核心功能 Remoting 远程通讯，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。 Cluster 服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 Registry 服务注册中心，服务自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/Dubbo/Dubbo组件角色.html":{"url":"chapter10/Dubbo/Dubbo组件角色.html","title":"Dubbo 组件角色","keywords":"","body":"Dubbo 组件角色 组件角色 说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次调和调用时间的监控中心 Container 服务运行容器 调用关系说明： 服务容器 Container 负责启动，加载，运行服务提供者。 服务提供者 Provider 在启动时，向注册中心注册自己提供的服务。 服务消费者 Consumer 在启动时，向注册中心订阅自己所需的服务。 注册中心 Registry 返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者 Consumer，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者 Consumer 和提供者 Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 Monitor。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/Zookeeper简介.html":{"url":"chapter10/Zookeeper简介.html","title":"Zookeeper 简介","keywords":"","body":"Zookeeper 简介 Zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户 设计目标 分布式协调技术 分布式锁的实现 应用举例 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:17:18 "},"chapter10/Zookeeper简介/设计目标.html":{"url":"chapter10/Zookeeper简介/设计目标.html","title":"设计目标","keywords":"","body":"设计目标 简单的数据结构，Zookeeper 就是以简单的树形结构来进行协调的（也叫做树形名字空间）。 可以构建集群，一般 Zookeeper 集群通常甶一组机器构成，一般3~5台机器就可以组成一个 Zookeeper 集群了，只要集群中超过一半以上的机器能够正常工作，那么整个集群就能正常对外服务。 顺序访问。对于来自每一个客户端的每一个请求，Zookeeper 都会分配一个全局唯一的递增编号，这个编号反映了所有事物操作的先后顺序，应用程序可以使用 Zookeeper 的这个特性来实现更高层次的同步。 高性能，甶于 Zookeeper 将全量数据存储在内存中，并直接服务于所有的非事务请求，因此尤其 是在读操作为主的场景下，性能非常突出。在 JMeter 压力测试下（100%读请求），其结果大约在 12-13W 的 QPS。 QPS： 每秒查询率 QPS 是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/Zookeeper简介/分布式协调技术.html":{"url":"chapter10/Zookeeper简介/分布式协调技术.html","title":"分布式协调技术","keywords":"","body":"分布式协调技术 什么是分布式协调技术？分布式协调技术主要用来解决分布式环境当中多个进程之间的同步控制，让他们有序的去访问某种临界资源，防止造成\"脏数据\"的后果。 在这图中有三台机器，每台机器各跑一个应用程序。然后我们将这三台机器通过网络将其连接起来，构成一个系统来为用户提供服务，对用户来说这个系统的架构是透明的，他感觉不到我这个系统是一个什么样的架构。那么我们就可以把这种系统称作一个分布式系统。 在这个分布式系统中如何对进程进行调度，我假设在第一台机器上挂载了一个资源，然后这三个物理分布的进程都要竞争这个资源，但我们又不希望他们同时进行访问，这时候我们就需要一个协调器，来让他们有序的来访问这个资源。这个协调器就是我们经常提到的那个锁，比如说\"进程-1\"在使用该资源的时候，会先去获得锁，\"进程1\"获得锁以后会对该资源保持独占，这样其他进程就无法访问该资源，\"进程1\"用完该资源以后就将锁释放掉，让其他进程来获得锁，那么通过这个锁机制，我们就能保证了分布式系统中多个进程能够有序的访问该临界资源。那么我们把这个分布式环境下的这个锁叫作分布式锁。这个分布式锁也就是我们分布式协调技术实现的核心内容。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/Zookeeper简介/分布式锁的实现.html":{"url":"chapter10/Zookeeper简介/分布式锁的实现.html","title":"分布式锁的实现","keywords":"","body":"分布式锁的实现 为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。那么这个锁怎么实现呢？这实现起来确实相对来说比较困难的。 面临的问题 比如，在同一台机器上，你对一个服务的调用如果成功，那就是成功，如果调用失败，比如抛出异常那就是调用失败。但是在分布式环境中，由于网络的不可 靠，你对一个服务的调用失败了并不表示一定是失败的，可能是执行成功了，但是响应返回的时候失败了。还有，A和B都去调用C服务，在时间上 A还先调用一些，B后调用，那么最后的结果是不是一定A的请求就先于B到达呢？ 这些在同一台机器上的种种假设，我们都要重新思考，我们还要思考这些问题给我们的设计和编码带来了哪些影响。还有，在分布式环境中为了提升可靠性，我们往往会部署多套服务，但是如何在多套服务中达到一致性，这在同一台机器上多个进程之间的同步相对来说比较容易办到，但在分布式环境中确实一个大难题。 所以分布式协调远比在同一台机器上对多个进程的调度要难得多，而且如果为每一个分布式应用都开发一个独立的协调程序。一方面，协调程序的反复编写浪 费，且难以形成通用、伸缩性好的协调器。另一方面，协调程序开销比较大，会影响系统原有的性能。所以，急需一种高可靠、高可用的通用协调机制来用以协调分布式应用。 分布式锁的实现者 目前，在分布式协调技术方面做得比较好的就是 Google 的 Chubby 还有 Apache 的 Zookeeper 他们都是分布式锁的实现者。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/Zookeeper简介/应用举例.html":{"url":"chapter10/Zookeeper简介/应用举例.html","title":"应用举例","keywords":"","body":"应用举例 分布式锁应用场景 在分布式锁服务中，有一种最典型应用场景，就是通过对集群进行 Master 选举，来解决分布式系统中的单点故障。什么是分布式系统中的单点故障：通常分布式系统采用主从模式，就是一个主控机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当我们的主节点发生故障时，那么整个系统就都瘫痪了，那么我们把这种故障叫作单点故障。 主从模式分布式系统 单点故障 传统解决方案 传统方式是采用一个备用节点，这个备用节点定期给当前主节点发送 ping 包，主节点收到 ping 包以后向备用节点发送回复Ack，当备用节点收到回复的时候就会认为当前主节点还活着，让他继续提供服务。 当主节点挂了，这时候备用节点收不到回复了，然后他就认为主节点挂了接替他成为主节点 但是这种方式就是有一个隐患，就是网络问题，来看一网络问题会造成什么后果 也就是说我们的主节点并没有挂，只是在回复的时候网络发生故障，这样我们的备用节点同样收不到回复，就会认为主节点挂了，然后备用节点将他的Master实例启动起来，这样我们的分布式系统当中就有了两个主节点也就是---双Master， 出现Master以后我们的从节点就会将它所做的事一部分汇报给了主节点，一部分汇报给了从节点，这样服务就全乱了。为了防止出现这种情况，我们引入了 Zookeeper，它虽然不能避免网络故障，但它能够保证每时每刻只有一个 Master。我么来看一下 Zookeeper 是如何实现的。 Zookeeper 解决方案 Master 启动 在引入了 Zookeeper 以后我们启动了两个主节点，\"主节点-A\"和\"主节点-B\"他们启动以后，都向 Zookeeper 去注册一个节点。我们 假设\"主节点-A\"锁注册的节点是\"master-00001\"，\"主节点-B\"注册的节点是\"master-00002\"，注册完以后进行选举，编号最小的节点将在选举中获胜获得锁成为主节点，也就是我们的\"主节点-A\"将会获得锁成为主节点，然后\"主节点-B\"将被阻塞成为一个备用节点。那么，通过这种方式就完成了对两个 Master 进程的调度。 Master 故障 如果\"主节点-A\"挂了，这时候他所注册的节点将被自动删除，Zookeeper 会自动感知节点的变化，然后再次发出选举，这时候\"主节点-B\"将在选举中获胜，替代\"主节点-A\"成为主节点。 Master 恢复 如果主节点恢复了，他会再次向 Zookeeper 注册一个节点，这时候他注册的节点将会是\"master-00003\"，Zookeeper 会感知节点的变化再次发动选举，这时候\"主节点-B\"在选举中会再次获胜继续担任\"主节点\"，\"主节点-A\"会担任备用节点。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/Zookeeper安装.html":{"url":"chapter10/Zookeeper安装.html","title":"Zookeeper 安装","keywords":"","body":"Zookeeper 安装 Zookeeper安装方式有三种 单机模式：Zookeeper 只运行在一台服务器上，适合测试环境 伪集群模式：就是在一台物理机上运行多个 Zookeeper 实例 集群模式：Zookeeper 运行于一个集群上，适合生产环境，这个计算机集群被称为一个“集合体”（ensemble） Zookeeper 通过复制来实现高可用性，只要集合体中半数以上的机器处于可用状态，它就能够保证服务继续。为什么一定要超过半数呢？这跟 Zookeeper 的复制策略有关：Zookeeper 确保对 znode 树的每一个修改都会被复制到集合体中超过半数的机器上。 单机模式 伪集群模式 集群模式 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:17:18 "},"chapter10/Zookeeper安装/单机模式.html":{"url":"chapter10/Zookeeper安装/单机模式.html","title":"单机模式","keywords":"","body":"单机模式 我们使用 Docker 来搭建单机模式的 Zookeeper，docker-compose.yml 配置文件如下： version: '3.1' services: zoo1: image: zookeeper restart: always hostname: zoo1 ports: - 2181:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=zoo1:2888:3888 验证测试： 以交互的方式进入容器 docker exec -it zookeeper_zoo1_1 /bin/bash 使用客户端连接到服务端 bash-4.3# ./bin/zkCli.sh -server 192.168.75.130:2181 Connecting to 192.168.75.130:2181 2017-11-09 07:45:58,365 [myid:] - INFO [main:Environment@100] - Client environment:zookeeper.version=3.4.10-39d3a4f269333c922ed3db283be479f9deacaa0f, built on 03/23/2017 10:13 GMT 2017-11-09 07:45:58,374 [myid:] - INFO [main:Environment@100] - Client environment:host.name=zoo1 2017-11-09 07:45:58,374 [myid:] - INFO [main:Environment@100] - Client environment:java.version=1.8.0_131 2017-11-09 07:45:58,380 [myid:] - INFO [main:Environment@100] - Client environment:java.vendor=Oracle Corporation 2017-11-09 07:45:58,381 [myid:] - INFO [main:Environment@100] - Client environment:java.home=/usr/lib/jvm/java-1.8-openjdk/jre 2017-11-09 07:45:58,381 [myid:] - INFO [main:Environment@100] - Client environment:java.class.path=/zookeeper-3.4.10/bin/../build/classes:/zookeeper-3.4.10/bin/../build/lib/*.jar:/zookeeper-3.4.10/bin/../lib/slf4j-log4j12-1.6.1.jar:/zookeeper-3.4.10/bin/../lib/slf4j-api-1.6.1.jar:/zookeeper-3.4.10/bin/../lib/netty-3.10.5.Final.jar:/zookeeper-3.4.10/bin/../lib/log4j-1.2.16.jar:/zookeeper-3.4.10/bin/../lib/jline-0.9.94.jar:/zookeeper-3.4.10/bin/../zookeeper-3.4.10.jar:/zookeeper-3.4.10/bin/../src/java/lib/*.jar:/conf: 2017-11-09 07:45:58,381 [myid:] - INFO [main:Environment@100] - Client environment:java.library.path=/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64/server:/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64:/usr/lib/jvm/java-1.8-openjdk/jre/../lib/amd64:/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib 2017-11-09 07:45:58,381 [myid:] - INFO [main:Environment@100] - Client environment:java.io.tmpdir=/tmp 2017-11-09 07:45:58,381 [myid:] - INFO [main:Environment@100] - Client environment:java.compiler= 2017-11-09 07:45:58,381 [myid:] - INFO [main:Environment@100] - Client environment:os.name=Linux 2017-11-09 07:45:58,382 [myid:] - INFO [main:Environment@100] - Client environment:os.arch=amd64 2017-11-09 07:45:58,382 [myid:] - INFO [main:Environment@100] - Client environment:os.version=4.4.0-98-generic 2017-11-09 07:45:58,386 [myid:] - INFO [main:Environment@100] - Client environment:user.name=root 2017-11-09 07:45:58,386 [myid:] - INFO [main:Environment@100] - Client environment:user.home=/root 2017-11-09 07:45:58,386 [myid:] - INFO [main:Environment@100] - Client environment:user.dir=/zookeeper-3.4.10 2017-11-09 07:45:58,389 [myid:] - INFO [main:ZooKeeper@438] - Initiating client connection, connectString=192.168.75.130:2181 sessionTimeout=30000 watcher=org.apache.zookeeper.ZooKeeperMain$MyWatcher@3eb07fd3 2017-11-09 07:45:58,428 [myid:] - INFO [main-SendThread(192.168.75.130:2181):ClientCnxn$SendThread@1032] - Opening socket connection to server 192.168.75.130/192.168.75.130:2181. Will not attempt to authenticate using SASL (unknown error) Welcome to ZooKeeper! JLine support is enabled 2017-11-09 07:45:58,529 [myid:] - INFO [main-SendThread(192.168.75.130:2181):ClientCnxn$SendThread@876] - Socket connection established to 192.168.75.130/192.168.75.130:2181, initiating session [zk: 192.168.75.130:2181(CONNECTING) 0] 2017-11-09 07:45:58,573 [myid:] - INFO [main-SendThread(192.168.75.130:2181):ClientCnxn$SendThread@1299] - Session establishment complete on server 192.168.75.130/192.168.75.130:2181, sessionid = 0x15f9fbc12ec0000, negotiated timeout = 30000 WATCHER:: WatchedEvent state:SyncConnected type:None path:null 使用服务端工具检查服务器状态 bash-4.3# ./bin/zkServer.sh status ZooKeeper JMX enabled by default Using config: /conf/zoo.cfg Mode: standalone Mode: standalone - 单机模式 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/Zookeeper安装/伪集群模式.html":{"url":"chapter10/Zookeeper安装/伪集群模式.html","title":"伪集群模式","keywords":"","body":"伪集群模式 我们使用 Docker 来搭建伪集群模式的 Zookeeper，docker-compose.yml 配置文件如下： version: '3.1' services: zoo1: image: zookeeper restart: always hostname: zoo1 ports: - 2181:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888 zoo2: image: zookeeper restart: always hostname: zoo2 ports: - 2182:2181 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888 zoo3: image: zookeeper restart: always hostname: zoo3 ports: - 2183:2181 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888 验证测试： 分别以交互方式进入容器查看 docker exec -it zookeeper_zoo1_1 /bin/bash docker exec -it zookeeper_zoo2_1 /bin/bash docker exec -it zookeeper_zoo3_1 /bin/bash 使用服务端工具检查服务器状态 root@UbuntuBase:/usr/local/docker/zookeeper# docker exec -it zookeeper_zoo1_1 /bin/bash bash-4.3# ./bin/zkServer.sh status ZooKeeper JMX enabled by default Using config: /conf/zoo.cfg Mode: follower root@UbuntuBase:/usr/local/docker/zookeeper# docker exec -it zookeeper_zoo2_1 /bin/bash bash-4.3# ./bin/zkServer.sh status ZooKeeper JMX enabled by default Using config: /conf/zoo.cfg Mode: follower root@UbuntuBase:/usr/local/docker/zookeeper# docker exec -it zookeeper_zoo3_1 /bin/bash bash-4.3# ./bin/zkServer.sh status ZooKeeper JMX enabled by default Using config: /conf/zoo.cfg Mode: leader 从上面的验证结果可以看出：zoo1 为跟随者，zoo2 为跟随者，zoo3 为领导者 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/Zookeeper安装/集群模式.html":{"url":"chapter10/Zookeeper安装/集群模式.html","title":"集群模式","keywords":"","body":"集群模式 准备 3 台 Ubuntu Server 系统，并分别配置 Zookeeper 第一台主机 docker-compose.yml version: '3.1' services: zoo1: image: zookeeper restart: always environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=192.168.75.130:2888:3888 server.2=192.168.75.134:2888:3888 server.3=192.168.75.135:2888:3888 network_mode: host 验证测试 root@UbuntuBase:/usr/local/docker/zookeeper# docker exec -it zookeeper_zoo1_1 /bin/bash bash-4.3# ./bin/zkServer.sh status ZooKeeper JMX enabled by default Using config: /conf/zoo.cfg Mode: leader 第二台主机 docker-compose.yml version: '3.1' services: zoo2: image: zookeeper restart: always environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=192.168.75.130:2888:3888 server.2=192.168.75.134:2888:3888 server.3=192.168.75.135:2888:3888 network_mode: host 验证测试 root@UbuntuBase:/usr/local/docker/zookeeper# docker exec -it zookeeper_zoo2_1 /bin/bash bash-4.3# ./bin/zkServer.sh status ZooKeeper JMX enabled by default Using config: /conf/zoo.cfg Mode: follower 第三台主机 docker-compose.yml version: '3.1' services: zoo3: image: zookeeper restart: always environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=192.168.75.130:2888:3888 server.2=192.168.75.134:2888:3888 server.3=192.168.75.135:2888:3888 network_mode: host 验证测试 root@UbuntuBase:/usr/local/docker/zookeeper# docker exec -it zookeeper_zoo3_1 /bin/bash bash-4.3# ./bin/zkServer.sh status ZooKeeper JMX enabled by default Using config: /conf/zoo.cfg Mode: follower Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter10/DubboAdmin管理控制台.html":{"url":"chapter10/DubboAdmin管理控制台.html","title":"Dubbo Admin 管理控制台","keywords":"","body":"Dubbo Admin 管理控制台 管理控制台为内部裁剪版本，开源部分主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。 克隆 git clone https://github.com/dubbo/dubbo-ops.git 打包 mvn clean package 配置 编辑 dubbo-admin/WEB-INF/dubbo.properties 配置文件 dubbo.registry.address=zookeeper://192.168.75.132:2181 dubbo.admin.root.password=root dubbo.admin.guest.password=guest 启动 Tomcat 访问 Tomcat http://localhost:8080/dubbo-admin/ 登录账号 账号：root，密码：root 账号：guest，密码：guest 服务页面 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter11.html":{"url":"chapter11.html","title":"第11章 项目实战-系统后台管理","keywords":"","body":"第十一章 项目实战-系统后台管理 修改依赖管理项目 创建服务提供者 创建服务消费者 服务地址配置 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:17:28 "},"chapter11/修改依赖管理项目.html":{"url":"chapter11/修改依赖管理项目.html","title":"修改依赖管理项目","keywords":"","body":"修改依赖管理项目 增加 Dubbo 的 Starter POM 与 Zookeeper 客户端的相关依赖 项目名称 gaming-server-dependencies 增加第三方仓库 用于依赖 Alibaba 的 Dubbo Starter POM sonatype-nexus-snapshots https://oss.sonatype.org/content/repositories/snapshots false true 增加 Alibaba Dubbo Starter POM com.alibaba.boot dubbo-spring-boot-starter 1.0.0-SNAPSHOT 增加 Zookeeper 客户端依赖 com.101tec zkclient 0.10 完整的 POM 4.0.0 com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT pom gaming-server-dependencies org.springframework.boot spring-boot-starter-parent 1.5.10.RELEASE UTF-8 UTF-8 1.8 1.1.5 1.0.0-SNAPSHOT 1.2.3 1.1.5 3.3.2 23.5-jre 0.26 2.24.0 3.4.4 0.10 sonatype-nexus-snapshots https://oss.sonatype.org/content/repositories/snapshots false true com.alibaba druid-spring-boot-starter ${spring-boot-alibaba-druid.version} com.alibaba.boot dubbo-spring-boot-starter ${spring-boot-alibaba-dubbo.version} tk.mybatis mapper ${tk-mybatis.version} tk.mybatis mapper-spring-boot-starter ${spring-boot-tk-mybatis.version} com.github.pagehelper pagehelper-spring-boot-starter ${spring-boot-pagehelper.version} org.hibernate hibernate-validator ${hibernate-validator.version} org.apache.commons commons-lang3 ${commons-lang3.version} com.fasterxml.jackson.core jackson-databind ${jackson.version} com.esotericsoftware.kryo kryo ${kryo.version} de.javakaffee kryo-serializers ${kryo-serializers.version} net.sourceforge.nekohtml nekohtml ${nekohtml.version} org.projectlombok lombok ${lombok.version} com.google.guava guava ${google-guava.version} mysql mysql-connector-java ${mysql.version} com.101tec zkclient ${zkclient.version} ${project.artifactId} org.apache.maven.plugins maven-resources-plugin ${maven-resources-plugin.version} UTF-8 org.apache.maven.plugins maven-compiler-plugin ${maven-compiler-plugin.version} ${java.version} ${java.version} UTF-8 org.apache.maven.plugins maven-surefire-plugin ${maven-surefire-plugin.version} true Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter11/创建服务提供者.html":{"url":"chapter11/创建服务提供者.html","title":"创建服务提供者","keywords":"","body":"创建服务提供者 由于之前章节已经创建过提供者项目(管理后台实现项目)，在这里我们只需要做少量修改并配置 Dubbo 即可 项目名称 gaming-server-service-admin POM 4.0.0 com.ooqiu.gaming gaming-server-service-admin 1.0.0-SNAPSHOT jar gaming-server-service-admin com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT org.springframework.boot spring-boot-starter org.springframework.boot spring-boot-starter-actuator org.springframework.boot spring-boot-starter-test test com.alibaba druid-spring-boot-starter tk.mybatis mapper-spring-boot-starter com.github.pagehelper pagehelper-spring-boot-starter mysql mysql-connector-java com.alibaba.boot dubbo-spring-boot-starter com.101tec zkclient com.ooqiu.gaming gaming-server-service-admin-api 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-commons 1.0.0-SNAPSHOT org.springframework.boot spring-boot-maven-plugin com.ooqiu.gaming.server.service.admin.GamingServerServiceAdminApplication 配置 Dubbo 修改 application.yml 配置文件 dubbo: scan: base-packages: com.ooqiu.gaming.server.service.admin.api application: id: gaming-server-service-admin name: gaming-server-service-admin protocol: id: dubbo name: dubbo port: 20880 registry: id: zookeeper address: zookeeper://192.168.75.132:2181?backup=192.168.75.132:2182,192.168.75.132:2183 完整的 application.yml spring: application: name: gaming-server-service-admin datasource: druid: url: jdbc:mysql://192.168.75.132:3306/toutiao?useUnicode=true&characterEncoding=utf-8&useSSL=false username: root password: 123456 initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true driver-class-name: com.mysql.jdbc.Driver dubbo: scan: base-packages: com.ooqiu.gaming.server.service.admin.api application: id: gaming-server-service-admin name: gaming-server-service-admin protocol: id: dubbo name: dubbo port: 20880 registry: id: zookeeper address: zookeeper://192.168.75.132:2181?backup=192.168.75.132:2182,192.168.75.132:2183 mybatis: type-aliases-package: com.ooqiu.gaming.server.domain mapper-locations: classpath:mapper/*.xml 注意： 注册中心使用的是 Zookeeper ，需要指定注册中心地址为 zookeeper://zooIp:zooPort 否则内部报错，然后注册时应用等待超时。原因是没有配置注册中心协议，所以默认就是 dubbo，这样这个地址其实变为了 dubbo://, dubbo 会认为注册中心地址是一个 dubbo 服务，但其实该地址运行的是一个 Zookeeper 服务。 使用 @Service 注解声明服务提供者 package com.ooqiu.gaming.server.service.admin.api.impl; import com.alibaba.dubbo.config.annotation.Service; import com.ooqiu.gaming.server.domain.Channel; import com.ooqiu.gaming.server.service.admin.api.ChannelService; import com.ooqiu.gaming.server.service.admin.mapper.ChannelMapper; import org.springframework.beans.factory.annotation.Autowired; import java.util.List; /** * 频道管理 * Title: ChannelServiceImpl * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/2/5 1:21 */ @Service(version = \"1.0.0\") public class ChannelServiceImpl implements ChannelService { @Autowired private ChannelMapper channelMapper; @Override public List selectAll() { return channelMapper.selectAll(); } } Spring Boot Application 中启动容器 需要在 main() 方法中调用 Main.main(args) 方法启动为提供者容器 package com.ooqiu.gaming.server.service.admin; import com.alibaba.dubbo.container.Main; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(basePackages = \"com.ooqiu.gaming.server.service.admin.mapper\") public class GamingServerServiceAdminApplication { public static void main(String[] args) { SpringApplication.run(GamingServerServiceAdminApplication.class, args); Main.main(args); } } 运行成功效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:20:07 "},"chapter11/创建服务消费者.html":{"url":"chapter11/创建服务消费者.html","title":"创建服务消费者","keywords":"","body":"创建服务消费者 项目名称 gaming-server-web-admin POM 4.0.0 com.ooqiu.gaming gaming-server-web-admin 1.0.0-SNAPSHOT jar gaming-server-web-admin com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-actuator org.springframework.boot spring-boot-starter-test test net.sourceforge.nekohtml nekohtml com.alibaba.boot dubbo-spring-boot-starter com.101tec zkclient com.ooqiu.gaming gaming-server-service-admin-api 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-commons 1.0.0-SNAPSHOT org.springframework.boot spring-boot-maven-plugin com.ooqiu.gaming.server.web.admin.GamingServerWebAdminApplication 配置 Dubbo 修改 application.yml 配置文件 dubbo: application: id: gaming-server-web-admin name: gaming-server-web-admin registry: id: zookeeper address: zookeeper://192.168.75.132:2181?backup=192.168.75.132:2182,192.168.75.132:2183 scan: base-packages: com.ooqiu.gaming.server.web.admin.controller 完整的 application.yml server: port: 8100 spring: application: name: gaming-server-web-admin thymeleaf: cache: false mode: LEGACYHTML5 encoding: UTF-8 content-type: text/html dubbo: scan: base-packages: com.ooqiu.gaming.server.web.admin.controller application: id: gaming-server-web-admin name: gaming-server-web-admin registry: id: zookeeper address: zookeeper://192.168.75.132:2181?backup=192.168.75.132:2182,192.168.75.132:2183 使用 @Reference 注解注入服务提供者 package com.ooqiu.gaming.server.web.admin.controller; import com.alibaba.dubbo.config.annotation.Reference; import com.ooqiu.gaming.server.domain.Channel; import com.ooqiu.gaming.server.service.admin.api.ChannelService; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; @RestController public class ChannelController { @Reference(version = \"1.0.0\") private ChannelService channelService; @RequestMapping(value = \"hi\") public String list() { List channels = channelService.selectAll(); System.out.println(channels); return \"Hi\"; } } 运行成功效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter11/服务地址配置.html":{"url":"chapter11/服务地址配置.html","title":"服务地址配置","keywords":"","body":"服务地址配置 API 网关 服务名称 服务端口 gaming-server-api 8500 Servlet 容器 服务名称 服务端口 gaming-server-web-admin 8100 Dubbo 服务 服务名称 服务端口 gaming-server-service-admin 20880 gaming-server-service-channel 20881 gaming-server-service-article 20882 gaming-server-service-redis 20883 gaming-server-service-search 20884 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter12.html":{"url":"chapter12.html","title":"第12章 项目实战-页面布局","keywords":"","body":"第十二章 项目实战-页面布局 登录页布局 首页布局 使用 thymeleaf 模板 使用 iframe 展示功能页 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:17:36 "},"chapter12/登录页布局.html":{"url":"chapter12/登录页布局.html","title":"登录页布局","keywords":"","body":"登录页布局 Controller package com.ooqui.gaming.server.web.admin.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; @Controller public class LoginController { /** * 跳转登录页面 * @return */ @RequestMapping(value = {\"\", \"login\"}, method = RequestMethod.GET) public String login() { return \"login\"; } /** * 跳转到首页 * @return */ @RequestMapping(value = \"main\", method = RequestMethod.GET) public String main() { return \"main\"; } /** * 登录业务 * @param email 邮箱 * @param password 密码 * @return */ @RequestMapping(value = \"login\", method = RequestMethod.POST) public String login(String email, String password) { if (\"admin@admin.com\".equals(email) && \"admin\".equals(password)) { return \"redirect:main\"; } else { return \"login\"; } } } HTML 管理后台 - 登录 欢迎登录 记住我 忘记密码 ? 登录 忘记密码 ? 输入邮箱重置密码 重置密码 &nbsp;&nbsp; 取消 注意 login.js 需要屏蔽第 208 行 handleSignInFormSubmit(); Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter12/首页布局.html":{"url":"chapter12/首页布局.html","title":"首页布局","keywords":"","body":"首页布局 HTML 后台管理 | 控制面板 Nick Mark Andre mark.andre@gmail.com Section 个人信息 注销 控制面板 内容管理 频道管理 文章管理 系统设置 字典管理 控制面板 2018 &copy; by Lusifer Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter12/使用thymeleaf模板.html":{"url":"chapter12/使用thymeleaf模板.html","title":"使用 thymeleaf 模板","keywords":"","body":"使用 thymeleaf 模板 我们可以使用 thymeleaf 的模板功能将顶部 CSS 与底部 JS 封装起来，方便重用 定义模板 在 templates 目录下新建 includes 目录，并创建需要的模板文件 定义模板： 引用模板： 顶部模板 header.html 语法： 底部模板 footer.html Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter12/使用iframe展示功能页.html":{"url":"chapter12/使用iframe展示功能页.html","title":"使用 iframe 展示功能页","keywords":"","body":"使用 iframe 展示功能页 引入选项卡插件 需要使用 jquery-scrollbar 和 nth-tabs 两个插件 引用 CSS 引用 JS 添加页签包装节点 注：本项目中是添加在页面的 节点中 初始化 JS 代码 $(function () { NthTabs.home(\"/home\"); }); 调用 JS 代码 NthTabs.addTab('a', '频道管理', '/channel/list', true, true); 效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter13.html":{"url":"chapter13.html","title":"第13章 项目实战-实现频道管理功能","keywords":"","body":"第十三章 项目实战-实现频道管理功能 频道管理页面布局 定义频道管理接口 实现频道管理接口 频道管理控制器 树控件与树表格 表单页的树控件 列表页的树表格 所需工具类 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:17:48 "},"chapter13/频道管理页面布局.html":{"url":"chapter13/频道管理页面布局.html","title":"频道管理页面布局","keywords":"","body":"频道管理页面布局 列表页布局 后台管理 | 频道管理 频道管理 新增 频道名称 排序 操作 天涯明月刀 100 编辑 删除 添加下级菜单 表单页布局 后台管理 | 频道管理 频道管理 父级频道: 频道名称: 排序: 提交 返回 父级频道 &times; 根目录 取消 选择 treeview.js var TreeView = function () { var handlerInitTree = function () { $('#m_tree_1').jstree(); // 绑定节点点击事件 $('#m_tree_1').bind(\"activate_node.jstree\", function (obj, e) { var currentNode = e.node; $(\"#pid\").val(currentNode.id); $(\"#pidText\").val(currentNode.text); }); }; return { init: function () { handlerInitTree(); } } }(); jQuery(document).ready(function () { TreeView.init(); }); Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter13/定义频道管理接口.html":{"url":"chapter13/定义频道管理接口.html","title":"定义频道管理接口","keywords":"","body":"定义频道管理接口 修改项目 gaming-server-service-admin-api 定义接口 package com.ooqiu.gaming.service.admin.api; import com.ooqiu.gaming.server.domain.Channel; import java.util.List; /** * 频道接口 * Title: ChannelService * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/2/2 10:40 */ public interface ChannelService { /** * 查询所有频道 * @return */ public List selectAll(); /** * 根据 ID 查询频道 * @param id * @return */ public Channel getById(Long id); /** * 保存频道 * @param channel */ public int save(Channel channel); } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter13/实现频道管理接口.html":{"url":"chapter13/实现频道管理接口.html","title":"实现频道管理接口","keywords":"","body":"实现频道管理接口 修改项目 gaming-server-service-admin 实现接口 package com.ooqiu.gaming.service.admin.api.impl; import com.alibaba.dubbo.config.annotation.Service; import com.ooqiu.gaming.server.domain.Channel; import com.ooqiu.gaming.service.admin.api.ChannelService; import com.ooqiu.gaming.service.admin.mapper.ChannelMapper; import com.ooqui.gaming.server.commons.constant.DubboVersionConstant; import com.ooqui.gaming.server.commons.utils.IDUtils; import org.springframework.beans.factory.annotation.Autowired; import java.util.Date; import java.util.List; /** * 频道接口实现 * Title: ChannelServiceImpl * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/2/2 10:42 */ @Service(version = DubboVersionConstant.DUBBO_VERSION_GAMING_SERVER_SERVICE_ADMIN) public class ChannelServiceImpl implements ChannelService { @Autowired private ChannelMapper channelMapper; @Override public List selectAll() { return channelMapper.selectAll(); } @Override public Channel getById(Long id) { return null; } @Override public int save(Channel channel) { channel.setId(IDUtils.genId()); channel.setIsParent(\"1\"); channel.setCreateDate(new Date()); channel.setUpdateDate(new Date()); // 判断是否为父级菜单 if (channel.getPid() == null || channel.getPid() == 0L) { channel.setPid(0L); channel.setIsParent(\"0\"); } return channelMapper.insert(channel); } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter13/频道管理控制器.html":{"url":"chapter13/频道管理控制器.html","title":"频道管理控制器","keywords":"","body":"频道管理控制器 修改项目 gaming-server-web-admin Controller package com.ooqiu.gaming.server.web.admin.controller; import com.alibaba.dubbo.config.annotation.Reference; import com.ooqiu.gaming.server.domain.Channel; import com.ooqiu.gaming.service.admin.api.ChannelService; import com.ooqui.gaming.server.commons.constant.DubboVersionConstant; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import java.util.List; @Controller @RequestMapping(value = \"channel\") public class ChannelController { @Reference(version = DubboVersionConstant.DUBBO_VERSION_GAMING_SERVER_SERVICE_ADMIN) private ChannelService channelService; /** * 跳转频道列表页 * @return */ @RequestMapping(value = \"list\", method = RequestMethod.GET) public String list(Model model) { List channels = channelService.selectAll(); model.addAttribute(\"channels\", channels); return \"modules/channel/list\"; } /** * 跳转频道表单页 * @return */ @RequestMapping(value = \"form\", method = RequestMethod.GET) public String form() { return \"modules/channel/form\"; } /** * 保存频道 * @param channel * @return */ @RequestMapping(value = \"save\", method = RequestMethod.POST) public String save(Channel channel) { int result = channelService.save(channel); return \"redirect:/channel/list\"; } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter13/树控件与树表格.html":{"url":"chapter13/树控件与树表格.html","title":"树控件与树表格","keywords":"","body":"树控件与树表格 表单页的树控件 列表页的树表格 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:17:48 "},"chapter13/树控件与树表格/表单页的树控件.html":{"url":"chapter13/树控件与树表格/表单页的树控件.html","title":"表单页的树控件","keywords":"","body":"表单页的树控件 创建数据传输对象 package com.ooqiu.gaming.server.web.admin.dto; import lombok.Data; import java.io.Serializable; /** * 前端树控件 * Title: TreeView * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/2 3:48 */ @Data public class TreeView implements Serializable { private String id; private String icon; private String text; private boolean children; } 定义数据查询接口 /** * 根据父 ID 查询子类目 * @param pid * @return */ public List selectByPid(Long pid); 实现数据查询接口 @Override public List selectByPid(Long pid) { if (pid == null) { pid = 0L; } Example example = new Example(Channel.class); example.createCriteria().andEqualTo(\"pid\", pid); return channelMapper.selectByExample(example); } 控制器代码 /** * 获取频道树结构 * * @param pid * @return */ @ResponseBody @RequestMapping(value = \"tree\", method = RequestMethod.GET) public List tree(String pid) { List list = Lists.newArrayList(); if (StringUtils.isBlank(pid) || \"#\".equals(pid)) { pid = \"0\"; } List channels = channelService.selectByPid(Long.parseLong(pid)); for (Channel channel : channels) { TreeView treeView = new TreeView(); treeView.setId(String.valueOf(channel.getId())); treeView.setIcon(\"\"); treeView.setText(channel.getName()); treeView.setChildren(channel.getIsParent().equals(\"0\")); list.add(treeView); } return list; } JS 代码 var TreeView = function () { /** * 初始化树 * @param id 树节点 ID * @param url 远程树结构请求地址 */ var handlerInitTree = function (id, url) { $(\"#\" + id).jstree({ \"core\": { \"themes\": { \"responsive\": false }, \"check_callback\": true, 'data': { 'url': function (node) { return url; }, 'data': function (node) { return {\"pid\" : node.id}; } } }, \"types\": { \"default\": { \"icon\": \"fa fa-folder m--font-brand\" }, \"file\": { \"icon\": \"fa fa-file m--font-brand\" } }, \"plugins\": [\"dnd\", \"state\", \"types\"] }); $('#' + id).bind(\"activate_node.jstree\", function (obj, e) { var currentNode = e.node; $(\"#pid\").val(currentNode.id); $(\"#pidText\").val(currentNode.text); }); }; return { init: function (id, url) { handlerInitTree(id, url); } } }(); JS 调用 $(function () { TreeView.init(\"m_tree_1\", \"/channel/tree\"); }); 对应的 HTML 节点 效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter13/树控件与树表格/列表页的树表格.html":{"url":"chapter13/树控件与树表格/列表页的树表格.html","title":"列表页的树表格","keywords":"","body":"列表页的树表格 需要使用 treeTable 插件 引用 CSS 引用 JS 表格的 HTML 频道名称 排序 操作 天涯明月刀 100 编辑 删除 添加下级菜单 调用 JS 代码 $(function () { $(\"#html_table\").treeTable({expandLevel: 2, column: 0}).show(); }); 频道排序代码 树表格插件需要数据排序后才会生效，这里的排序是子节点行元素需要紧随父节点行元素 排序 /** * 频道排序，用于配合前端属性表格展示 * @param targetList 排序后的集合 * @param sourceList 数据源的集合 */ private void sortChannelList(List targetList, List sourceList) { for (Channel channel : sourceList) { // 判断是否为父节点 if (\"0\".equals(channel.getIsParent())) { targetList.add(channel); // 判断是否有子节点 for (Channel subChannel : sourceList) { if (subChannel.getPid().equals(channel.getId())) { targetList.add(subChannel); } } } } } 调用 /** * 跳转到频道列表页 * * @return */ @RequestMapping(value = \"list\", method = RequestMethod.GET) public String list(Model model) { List targetList = Lists.newArrayList(); List sourceList = channelService.selectAll(); // 频道排序 sortChannelList(targetList, sourceList); model.addAttribute(\"channels\", targetList); return \"modules/channel/list\"; } 效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter13/所需工具类.html":{"url":"chapter13/所需工具类.html","title":"所需工具类","keywords":"","body":"所需工具类 IDUtils package com.ooqui.gaming.server.commons.utils; import java.util.Random; /** * ID 生成工具 * Title: IDUtils * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/1 6:19 */ public class IDUtils { /** * id生成 */ public static long genId() { // 取当前时间的长整形值包含毫秒 long millis = System.currentTimeMillis(); // 加上两位随机数 Random random = new Random(); int end2 = random.nextInt(99); // 如果不足两位前面补0 String str = millis + String.format(\"%02d\", end2); long id = new Long(str); return id; } public static void main(String[] args) { System.out.println(genId()); } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter14.html":{"url":"chapter14.html","title":"第14章 项目实战-FastDFS 分布式文件系统","keywords":"","body":"第十四章 项目实战-搭建 FastDFS 分布式文件系统 FastDFS 简介 FastDFS 安装 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:17:59 "},"chapter14/FastDFS简介.html":{"url":"chapter14/FastDFS简介.html","title":"FastDFS 简介","keywords":"","body":"FastDFS 简介 百度百科 地址：https://baike.baidu.com/item/fastdfs/5609710?fr=aladdin FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。 FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。 简介 FastDFS服务端有两个角色：跟踪器（tracker）和存储节点（storage）。跟踪器主要做调度工作，在访问上起负载均衡的作用。 存储节点存储文件，完成文件管理的所有功能：就是这样的存储、同步和提供存取接口，FastDFS同时对文件的metadata进行管理。所谓文件的meta data就是文件的相关属性，以键值对（key valuepair）方式表示，如：width=1024，其中的key为width，value为1024。文件metadata是文件属性列表，可以包含多个键值对。 跟踪器和存储节点都可以由一台或多台服务器构成。跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。 为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。 在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。 当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。 FastDFS中的文件标识分为两个部分：卷名和文件名，二者缺一不可。 上传交互过程 client 询问 tracker 上传到的 storage，不需要附加参数 tracker 返回一台可用的 storage client 直接和 storage 通讯完成文件上传 下载交互过程 client 询问 tracker 下载文件的 storage，参数为文件标识（卷名和文件名） tracker 返回一台可用的 storage client 直接和 storage 通讯完成文件下载 需要说明的是，client 为使用 FastDFS 服务的调用方，client 也应该是一台服务器，它对 tracker 和 storage 的调用均为服务器间的调用。 FastDFS 为什么要结合 Nginx 我们在使用 FastDFS 部署一个分布式文件系统的时候，通过 FastDFS 的客户端 API 来进行文件的上传、下载、删除等操作。同时通过 FastDFS 的 HTTP 服务器来提供 HTTP 服务。但是 FastDFS 的 HTTP 服务较为简单，无法提供负载均衡等高性能的服务，我们使用 FastDFS 的 Nginx 模块来弥补这一缺陷。 FastDFS 通过 Tracker 服务器,将文件放在 Storage 服务器存储,但是同组之间的服务器需要复制文件,有延迟的问题.假设 Tracker 服务器将文件上传到了 192.168.1.80,文件ID已经返回客户端,这时,后台会将这个文件复制到 192.168.1.30,如果复制没有完成,客户端就用这个 ID 在 192.168.1.30 取文件,肯定会出现错误。这个 fastdfs-nginx-module 可以重定向连接到源服务器取文件,避免客户端由于复制延迟的问题,出现错误。 其他资源 源码地址：https://github.com/happyfish100 下载地址：http://sourceforge.net/projects/fastdfs/files/ 官方论坛：http://bbs.chinaunix.net/forum-240-1.html Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter14/FastDFS安装.html":{"url":"chapter14/FastDFS安装.html","title":"FastDFS 安装","keywords":"","body":"FastDFS 安装 我们基于 Docker 来安装 FastDFS 环境准备 libfastcommon.tar.gz fastdfs-5.11.tar.gz nginx-1.13.6.tar.gz fastdfs-nginx-module_v1.16.tar.gz 创建工作目录 在 Linux 服务器上创建 /usr/local/docker/fastdfs/fastdfs 目录 说明： /usr/local/docker/fastdfs：用于存放 docker-compose.yml 配置文件及 FastDFS 的数据卷 /usr/local/docker/fastdfs/fastdfs：用于存放 Dockerfile 镜像配置文件及 FastDFS 所需环境 docker-compose.yml version: '3.1' services: fastdfs: build: fastdfs restart: always container_name: fastdfs volumes: - /usr/local/docker/fastdfs/storage:/fastdfs/storage network_mode: host Dockerfile FROM ubuntu:xenial MAINTAINER topsale@vip.qq.com # 更新数据源 WORKDIR /etc/apt RUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse' > sources.list RUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse' >> sources.list RUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse' >> sources.list RUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse' >> sources.list RUN apt-get update # 安装依赖 RUN apt-get install make gcc libpcre3-dev zlib1g-dev --assume-yes # 复制工具包 ADD fastdfs-5.11.tar.gz /usr/local/src ADD fastdfs-nginx-module_v1.16.tar.gz /usr/local/src ADD libfastcommon.tar.gz /usr/local/src ADD nginx-1.13.6.tar.gz /usr/local/src # 安装 libfastcommon WORKDIR /usr/local/src/libfastcommon RUN ./make.sh && ./make.sh install # 安装 FastDFS WORKDIR /usr/local/src/fastdfs-5.11 RUN ./make.sh && ./make.sh install # 配置 FastDFS 跟踪器 ADD tracker.conf /etc/fdfs RUN mkdir -p /fastdfs/tracker # 配置 FastDFS 存储 ADD storage.conf /etc/fdfs RUN mkdir -p /fastdfs/storage # 配置 FastDFS 客户端 ADD client.conf /etc/fdfs # 配置 fastdfs-nginx-module ADD config /usr/local/src/fastdfs-nginx-module/src # FastDFS 与 Nginx 集成 WORKDIR /usr/local/src/nginx-1.13.6 RUN ./configure --add-module=/usr/local/src/fastdfs-nginx-module/src RUN make && make install ADD mod_fastdfs.conf /etc/fdfs WORKDIR /usr/local/src/fastdfs-5.11/conf RUN cp http.conf mime.types /etc/fdfs/ # 配置 Nginx ADD nginx.conf /usr/local/nginx/conf COPY entrypoint.sh /usr/local/bin/ ENTRYPOINT [\"/usr/local/bin/entrypoint.sh\"] WORKDIR / EXPOSE 8888 CMD [\"/bin/bash\"] entrypoint.sh #!/bin/sh /etc/init.d/fdfs_trackerd start /etc/init.d/fdfs_storaged start /usr/local/nginx/sbin/nginx -g 'daemon off;' 注：Shell 创建后是无法直接使用的，需要赋予执行的权限，使用 chmod +x entrypoint.sh 命令 各种配置文件说明 tracker.conf FastDFS 跟踪器配置，容器中路径为：/etc/fdfs，修改为： base_path=/fastdfs/tracker storage.conf FastDFS 存储配置，容器中路径为：/etc/fdfs，修改为： base_path=/fastdfs/storage store_path0=/fastdfs/storage tracker_server=192.168.75.145:22122 http.server_port=8888 client.conf FastDFS 客户端配置，容器中路径为：/etc/fdfs，修改为： base_path=/fastdfs/tracker tracker_server=192.168.75.145:22122 config fastdfs-nginx-module 配置文件，容器中路径为：/usr/local/src/fastdfs-nginx-module/src，修改为： # 修改前 CORE_INCS=\"$CORE_INCS /usr/local/include/fastdfs /usr/local/include/fastcommon/\" CORE_LIBS=\"$CORE_LIBS -L/usr/local/lib -lfastcommon -lfdfsclient\" # 修改后 CORE_INCS=\"$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/\" CORE_LIBS=\"$CORE_LIBS -L/usr/lib -lfastcommon -lfdfsclient\" mod_fastdfs.conf fastdfs-nginx-module 配置文件，容器中路径为：/usr/local/src/fastdfs-nginx-module/src，修改为： connect_timeout=10 tracker_server=192.168.75.145:22122 url_have_group_name = true store_path0=/fastdfs/storage nginx.conf Nginx 配置文件，容器中路径为：/usr/local/src/nginx-1.13.6/conf，修改为： user root; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 8888; server_name localhost; location ~/group([0-9])/M00 { ngx_fastdfs_module; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 启动容器 docker-compose up -d 测试上传 交互式进入容器 docker exec -it fastdfs /bin/bash 测试文件上传 /usr/bin/fdfs_upload_file /etc/fdfs/client.conf /usr/local/src/fastdfs-5.11/INSTALL 服务器反馈上传地址 group1/M00/00/00/wKhLi1oHVMCAT2vrAAAeSwu9TgM3976771 测试 Nginx 访问 http://192.168.75.145:8888/group1/M00/00/00/wKhLi1oHVMCAT2vrAAAeSwu9TgM3976771 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter15.html":{"url":"chapter15.html","title":"第15章 项目实战-实现文章管理功能","keywords":"","body":"第十五章 项目实战-实现文章管理功能 文章管理页面布局 PageHelper 分页查询 自定义 Thymeleaf 字典标签 使用 Java 实现 FastDFS 文件上传 安装 FastDFS 客户端 创建 FastDFS 工具类 创建 FastDFS 控制器 所需工具类 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:18:07 "},"chapter15/文章管理页面布局.html":{"url":"chapter15/文章管理页面布局.html","title":"文章管理页面布局","keywords":"","body":"文章管理页面布局 表单页 HTML 后台管理 | 文章管理 文章管理 所属频道 文章标题 文章链接 文件简介 相册 提交 返回 所属频道 &times; 关闭 选择 $(function () { TreeView.initTree(\"m_tree_1\", \"/channel/tree\", function (obj, e) { var currentNode = e.node; $(\"#channelId\").val(currentNode.id); $(\"#channelText\").val(currentNode.text); }); }); 改造后的 treeview.js var TreeView = function () { /** * 初始化树控件 * @param id 树控件的元素 ID * @param url Ajax 请求地址 * @param callback 回调函数，用于绑定树节点的点击事件 */ var handlerInitTree = function (id, url, callback) { $(\"#\" + id).jstree({ \"core\": { \"themes\": { \"responsive\": false }, // so that create works \"check_callback\": true, 'data': { 'url': function (node) { return url; }, 'data': function (node) { return {'pid': node.id}; } } }, \"types\": { \"default\": { \"icon\": \"fa fa-folder m--font-brand\" }, \"file\": { \"icon\": \"fa fa-file m--font-brand\" } }, \"state\": {\"key\": \"demo3\"}, \"plugins\": [\"dnd\", \"state\", \"types\"] }); $('#' + id).bind(\"activate_node.jstree\", function (obj, e) { callback(obj, e); }); }; return { initTree: function (id, url, callback) { handlerInitTree(id, url, callback); } } }(); 列表页 HTML 后台管理 | 文章管理 文章管理 新增 $(function () { var columns = [{ field: 'title', title: '文章标题', sortable: false, selector: false, textAlign: 'center' }, { field: 'url', title: '链接地址', sortable: false, selector: false, textAlign: 'center' }]; DataTable.initAjaxTable(\"ajax_data\", \"/article/data\", columns); }); 改造后的 datatable.js var DataTable = function () { /** * 初始化 HTML 表格 * @param id 元素 ID */ var handlerInitHtmlTable = function (id) { var datatable = $('#' + id).mDatatable({ data: { saveState: {cookie: false} }, pagination: false, sortable: false }); }; /** * 初始化 Ajax 表格 * @param id 元素 ID * @param url 数据请求地址 * @param columns 自定义数据列 */ var handlerInitAjaxTable = function (id, url, columns) { var datatable = $('#' + id).mDatatable({ // 国际化 translate: { records: { processing: '加载中，请稍候...', noRecords: '还没有任何记录' }, toolbar: { pagination: { items: { default: { first: '首页', prev: '上一页', next: '下一页', last: '尾页', more: '更多', input: '页数', select: '显示笔数' }, info: '显示第 {{start}} - {{end}} 条记录，共 {{total}} 条记录' } } } }, // 定义数据源 data: { type: 'remote', source: { read: { method: 'POST', url: url, map: function (raw) { var dataSet = raw; if (typeof raw.data !== 'undefined') { dataSet = raw.data; } return dataSet; } } }, pageSize: 10, serverPaging: true, serverFiltering: true, serverSorting: true }, // 开启分页功能 pagination: true, toolbar: { // toolbar items items: { // pagination pagination: { // page size select pageSizeSelect: [10, 20, 50] } } }, // 定义数据列 columns: columns }); }; return { initHtmlTable: function (id) { handlerInitHtmlTable(id); }, initAjaxTable: function (id, url, columns) { handlerInitAjaxTable(id, url, columns); } } }(); Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter15/PageHelper分页查询.html":{"url":"chapter15/PageHelper分页查询.html","title":"PageHelper 分页查询","keywords":"","body":"PageHelper 分页查询 定义接口 /** * 分页查询 * @param page 页码（第几页） * @param pageSize 每页显示的笔数 * @return */ public PageInfo page(int page, int pageSize); 实现接口 @Override public PageInfo page(int page, int pageSize) { Example example = new Example(Article.class); PageHelper.startPage(page, pageSize); PageInfo pageInfo = new PageInfo<>(articleMapper.selectByExample(example)); return pageInfo; } 控制器代码 /** * 分页查询 * * @return */ @ResponseBody @RequestMapping(value = \"data\") public DataTable data(HttpServletRequest request) { String strPage = request.getParameter(\"datatable[pagination][page]\"); String strPageSize = request.getParameter(\"datatable[pagination][perpage]\"); // 遍历客户端 POST 请求的参数 // Enumeration parameterNames = request.getParameterNames(); // while (parameterNames.hasMoreElements()) { // String name = parameterNames.nextElement(); // String value = request.getParameter(name); // System.out.println(\"name=\" + name + \" value=\" + value); // } int page = 1; int pageSize = 10; if (!StringUtils.isBlank(strPage)) { page = Integer.parseInt(strPage); } if (!StringUtils.isBlank(strPageSize)) { pageSize = Integer.parseInt(strPageSize); } PageInfo pageInfo = articleService.page(page, pageSize); return new DataTable(pageInfo); } 关闭数据源的自动配置 由于 gaming-server-service-admin-api、gaming-server-service-admin、gaming-server-web-admin 三个项目都需要依赖 PageHelper 插件，所以我们只需要在 gaming-server-service-admin-api 项目中添加相关依赖 com.github.pagehelper pagehelper-spring-boot-starter 但这里依赖的是 PageHelper 的 Starter POM ，该 Starter POM 会自动配置数据源，所以我们需要在 gaming-server-web-admin 项目中排除数据源的自动配置功能，修改 GamingServerWebAdminApplication package com.ooqiu.gaming.server.web.admin; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration; @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) public class GamingServerWebAdminApplication { public static void main(String[] args) { SpringApplication.run(GamingServerWebAdminApplication.class, args); } } 使用 @SpringBootApplication 注解的 exclude 参数，即可解决该问题 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter15/自定义Thymeleaf字典标签.html":{"url":"chapter15/自定义Thymeleaf字典标签.html","title":"自定义 Thymeleaf 字典标签","keywords":"","body":"自定义 Thymeleaf 字典标签 Maven org.thymeleaf thymeleaf-spring4 3.0.9.RELEASE nz.net.ultraq.thymeleaf thymeleaf-layout-dialect 2.3.0 创建方言类 package com.ooqiu.gaming.server.web.admin.config.thymeleaf.dialect; import com.ooqiu.gaming.server.web.admin.config.thymeleaf.tag.SysDictTagProcessor; import org.thymeleaf.dialect.AbstractProcessorDialect; import org.thymeleaf.processor.IProcessor; import org.thymeleaf.standard.StandardDialect; import org.thymeleaf.standard.processor.StandardXmlNsTagProcessor; import org.thymeleaf.templatemode.TemplateMode; import java.util.HashSet; import java.util.Set; /** * Thymeleaf 方言：系统用 * Title: SysDialect * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 9:34 */ public class SysDialect extends AbstractProcessorDialect { // 定义方言名称 private static final String DIALECT_NAME = \"Sys Dialect\"; public SysDialect() { // 设置自定义方言与“方言处理器”优先级相同 super(DIALECT_NAME, \"sys\", StandardDialect.PROCESSOR_PRECEDENCE); } /** * 元素处理器 * @param dialectPrefix 方言前缀 * @return */ @Override public Set getProcessors(String dialectPrefix) { Set processors = new HashSet(); // 添加自定义标签 processors.add(new SysDictTagProcessor(dialectPrefix)); processors.add(new StandardXmlNsTagProcessor(TemplateMode.HTML, dialectPrefix)); return processors; } } 创建字典标签处理器 package com.ooqiu.gaming.server.web.admin.config.thymeleaf.tag; import com.ooqiu.gaming.server.domain.Dict; import com.ooqiu.gaming.server.web.admin.utils.DubboContextUtils; import com.ooqiu.gaming.service.admin.api.DictService; import org.springframework.context.ApplicationContext; import org.thymeleaf.context.ITemplateContext; import org.thymeleaf.model.IModel; import org.thymeleaf.model.IModelFactory; import org.thymeleaf.model.IProcessableElementTag; import org.thymeleaf.processor.element.AbstractElementTagProcessor; import org.thymeleaf.processor.element.IElementTagStructureHandler; import org.thymeleaf.spring4.context.SpringContextUtils; import org.thymeleaf.templatemode.TemplateMode; import java.util.List; /** * 自定义字典标签 * Title: SysDictTagProcessor * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 10:52 */ public class SysDictTagProcessor extends AbstractElementTagProcessor { // 标签名 private static final String TAG_NAME = \"dict\"; // 优先级 private static final int PRECEDENCE = 10000; public SysDictTagProcessor(String dialectPrefix) { super( // 此处理器将仅应用于HTML模式 TemplateMode.HTML, // 要应用于名称的匹配前缀 dialectPrefix, // 标签名称：匹配此名称的特定标签 TAG_NAME, // 将标签前缀应用于标签名称 true, // 无属性名称：将通过标签名称匹配 null, // 没有要应用于属性名称的前缀 false, // 优先(内部方言自己的优先) PRECEDENCE ); } /** * 处理自定义标签 DOM 结构 * * @param iTemplateContext 模板页上下文 * @param iProcessableElementTag 待处理标签 * @param iElementTagStructureHandler 元素标签结构处理器 */ @Override protected void doProcess(ITemplateContext iTemplateContext, IProcessableElementTag iProcessableElementTag, IElementTagStructureHandler iElementTagStructureHandler) { // 获取 Spring 上下文 ApplicationContext applicationContext = SpringContextUtils.getApplicationContext(iTemplateContext); // 注入字典 DictService dictService = applicationContext.getBean(DubboContextUtils.class).getDictService(); // 从标签读取属性值，这里的值是用来作为字典的查询参数 String dictType = iProcessableElementTag.getAttributeValue(\"type\"); // 提交表单时的 name String dictName = iProcessableElementTag.getAttributeValue(\"name\"); // 元素的 class 样式 String dictClass = iProcessableElementTag.getAttributeValue(\"class\"); // 根据类型查询出字典列表 List dictList = dictService.selectByType(dictType); // 创建将替换自定义标签的 DOM 结构 IModelFactory modelFactory = iTemplateContext.getModelFactory(); IModel model = modelFactory.createModel(); // 这里是将字典的内容拼装成一个下拉框 model.add(modelFactory.createOpenElementTag(String.format(\"select name='%s' class='%s'\", dictName, dictClass))); for (Dict dict : dictList) { model.add(modelFactory.createOpenElementTag(String.format(\"option value='%s'\", dict.getValue()))); model.add(modelFactory.createText(dict.getLabel())); model.add(modelFactory.createCloseElementTag(\"option\")); } model.add(modelFactory.createCloseElementTag(\"select\")); // 利用引擎替换整合标签 iElementTagStructureHandler.replaceWith(model, false); } } 注入方言类 package com.ooqiu.gaming.server.web.admin.config.thymeleaf; import com.ooqiu.gaming.server.web.admin.config.thymeleaf.dialect.SysDialect; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * Thymeleaf 方言配置 * Title: ThymeleafDialectConfig * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 10:57 */ @Configuration public class ThymeleafDialectConfig { /** * 系统方言 * 主要作用有： * 1. 处理字典数据展示 * * @return */ @Bean public SysDialect sysDialect() { return new SysDialect(); } } HTML 中声明使用 增加命名空间配置：xmlns:sys=\"\" 使用标签 文章类型 关于无法在标签处理类中注入 Dubbo 服务的解决办法 我们可以使用“曲线救国”的方式创建一个 Spring 的 @Component 组件，通过该组件实例化 Dubbo 服务即可 package com.ooqiu.gaming.server.web.admin.utils; import com.alibaba.dubbo.config.annotation.Reference; import com.ooqiu.gaming.service.admin.api.DictService; import com.ooqui.gaming.server.commons.constant.DubboVersionConstant; import org.springframework.stereotype.Component; /** * Dubbo 上下文工具 * 主要作用是在其它类里无法注入 Dubbo 服务时使用 * Title: DubboContextUtils * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 13:10 */ @Component public class DubboContextUtils { @Reference(version = DubboVersionConstant.DUBBO_VERSION_GAMING_SERVER_SERVICE_ADMIN) private DictService dictService; public DictService getDictService() { return dictService; } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter15/使用Java实现FastDFS文件上传.html":{"url":"chapter15/使用Java实现FastDFS文件上传.html","title":"使用 Java 实现 FastDFS 文件上传","keywords":"","body":"使用 Java 实现 FastDFS 文件上传 安装 FastDFS 客户端 创建 FastDFS 工具类 创建 FastDFS 控制器 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:18:07 "},"chapter15/使用Java实现FastDFS文件上传/安装FastDFS客户端.html":{"url":"chapter15/使用Java实现FastDFS文件上传/安装FastDFS客户端.html","title":"安装 FastDFS 客户端","keywords":"","body":"安装 FastDFS 客户端 克隆源码 git clone https://github.com/happyfish100/fastdfs-client-java.git 从源码安装 mvn clean install 在项目中添加依赖 gaming-server-dependencies org.csource fastdfs-client-java ${fastdfs.version} gaming-server-web-admin org.csource fastdfs-client-java Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter15/使用Java实现FastDFS文件上传/创建FastDFS工具类.html":{"url":"chapter15/使用Java实现FastDFS文件上传/创建FastDFS工具类.html","title":"创建 FastDFS 工具类","keywords":"","body":"创建 FastDFS 工具类 项目名称 gaming-server-web-admin 定义文件存储服务接口 package com.ooqiu.gaming.server.web.admin.config.fastdfs; /** * 文件存储服务接口 * Title: StorageService * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 21:30 */ public interface StorageService { /** * 上传文件 * * @param data 文件的二进制内容 * @param extName 扩展名 * @return 上传成功后返回生成的文件id；失败，返回null */ public String upload(byte[] data, String extName); /** * 删除文件 * * @param fileId 被删除的文件id * @return 删除成功后返回0，失败后返回错误代码 */ public int delete(String fileId); } 实现文件存储服务接口 package com.ooqiu.gaming.server.web.admin.config.fastdfs; import org.csource.common.NameValuePair; import org.csource.fastdfs.ClientGlobal; import org.csource.fastdfs.StorageClient1; import org.csource.fastdfs.StorageServer; import org.csource.fastdfs.TrackerClient; import org.csource.fastdfs.TrackerGroup; import org.csource.fastdfs.TrackerServer; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Value; import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; /** * 文件存储服务实现 * Title: FastDFSStorageService * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 21:31 */ public class FastDFSStorageService implements StorageService, InitializingBean { private static final Logger logger = LoggerFactory.getLogger(FastDFSStorageService.class); private TrackerClient trackerClient; @Value(\"${storage.fastdfs.tracker_server}\") private String trackerServer; @Override public String upload(byte[] data, String extName) { TrackerServer trackerServer = null; StorageServer storageServer = null; StorageClient1 storageClient1 = null; try { NameValuePair[] meta_list = null; // new NameValuePair[0]; trackerServer = trackerClient.getConnection(); if (trackerServer == null) { logger.error(\"getConnection return null\"); } storageServer = trackerClient.getStoreStorage(trackerServer); storageClient1 = new StorageClient1(trackerServer, storageServer); String fileid = storageClient1.upload_file1(data, extName, meta_list); logger.debug(\"uploaded file \", fileid); return fileid; } catch (Exception ex) { logger.error(\"Upload fail\", ex); return null; } finally { if (storageServer != null) { try { storageServer.close(); } catch (IOException e) { e.printStackTrace(); } } if (trackerServer != null) { try { trackerServer.close(); } catch (IOException e) { e.printStackTrace(); } } storageClient1 = null; } } @Override public int delete(String fileId) { // System.out.println(\"deleting ....\"); TrackerServer trackerServer = null; StorageServer storageServer = null; StorageClient1 storageClient1 = null; int index = fileId.indexOf('/'); String groupName = fileId.substring(0, index); try { trackerServer = trackerClient.getConnection(); if (trackerServer == null) { logger.error(\"getConnection return null\"); } storageServer = trackerClient.getStoreStorage(trackerServer, groupName); storageClient1 = new StorageClient1(trackerServer, storageServer); int result = storageClient1.delete_file1(fileId); return result; } catch (Exception ex) { logger.error(\"Delete fail\", ex); return 1; } finally { if (storageServer != null) { try { storageServer.close(); } catch (IOException e) { e.printStackTrace(); } } if (trackerServer != null) { try { trackerServer.close(); } catch (IOException e) { e.printStackTrace(); } } storageClient1 = null; } } @Override public void afterPropertiesSet() throws Exception { File confFile = File.createTempFile(\"fastdfs\", \".conf\"); PrintWriter confWriter = new PrintWriter(new FileWriter(confFile)); confWriter.println(\"tracker_server=\" + trackerServer); confWriter.close(); ClientGlobal.init(confFile.getAbsolutePath()); confFile.delete(); TrackerGroup trackerGroup = ClientGlobal.g_tracker_group; trackerClient = new TrackerClient(trackerGroup); logger.info(\"Init FastDFS with tracker_server : {}\", trackerServer); } } 文件存储服务工厂类 package com.ooqiu.gaming.server.web.admin.config.fastdfs; import org.springframework.beans.factory.FactoryBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.beans.factory.config.AutowireCapableBeanFactory; import java.util.HashMap; import java.util.Map; /** * 文件存储服务工厂类 * Title: StorageFactory * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 21:35 */ public class StorageFactory implements FactoryBean { @Autowired private AutowireCapableBeanFactory acbf; /** * 存储服务的类型，目前仅支持fastdfs */ @Value(\"${storage.type}\") private String type; private Map> classMap; public StorageFactory() { classMap = new HashMap<>(); classMap.put(\"fastdfs\", FastDFSStorageService.class); } @Override public StorageService getObject() throws Exception { Class clazz = classMap.get(type); if (clazz == null) { throw new RuntimeException(\"Unsupported storage type [\" + type + \"], valid are \" + classMap.keySet()); } StorageService bean = clazz.newInstance(); acbf.autowireBean(bean); acbf.initializeBean(bean, bean.getClass().getSimpleName()); return bean; } @Override public Class getObjectType() { return StorageService.class; } @Override public boolean isSingleton() { return true; } } 注入文件存储服务工厂类 package com.ooqiu.gaming.server.web.admin.config.fastdfs; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * Java 配置方式定义 StorageFactory 的 Bean 使其可以被依赖注入 * Title: FastDFSConfiguration * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 21:40 */ @Configuration public class FastDFSConfiguration { @Bean public StorageFactory storageFactory(){ return new StorageFactory(); } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter15/使用Java实现FastDFS文件上传/创建FastDFS控制器.html":{"url":"chapter15/使用Java实现FastDFS文件上传/创建FastDFS控制器.html","title":"创建 FastDFS 控制器","keywords":"","body":"创建 FastDFS 控制器 项目名称 gaming-server-web-admin 增加 FastDFS 相关配置 在 application.yml 中增加 FastDFS 相关配置 # FastDFS Begin fastdfs.base.url: http://192.168.75.132:8888/ storage: type: fastdfs fastdfs: tracker_server: 192.168.75.132:22122 # FastDFS End 控制器代码 package com.ooqiu.gaming.server.web.admin.controller; import com.google.common.collect.Maps; import com.ooqiu.gaming.server.web.admin.config.fastdfs.StorageService; import com.ooqui.gaming.server.commons.utils.MapperUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; import java.util.HashMap; import java.util.Map; /** * 文件上传控制器 * Title: UploadController * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 21:44 */ @Controller public class UploadController { @Value(\"${fastdfs.base.url}\") private String FASTDFS_BASE_URL; @Autowired private StorageService storageService; @ResponseBody @RequestMapping(\"upload\") public String upload(MultipartFile uploadFile, MultipartFile wangEditorH5File) { if (uploadFile != null) { String oName = uploadFile.getOriginalFilename(); String extName = oName.substring(oName.indexOf(\".\") + 1); HashMap map = new HashMap<>(); try { String uploadUrl = storageService.upload(uploadFile.getBytes(), extName); map.put(\"success\", \"上传成功\"); map.put(\"url\", FASTDFS_BASE_URL + uploadUrl); } catch (IOException e) { map.put(\"error\", 1); map.put(\"message\", \"上传失败\"); } return MapperUtils.mapToJson(map); } else if (wangEditorH5File != null) { String oName = wangEditorH5File.getOriginalFilename(); String extName = oName.substring(oName.indexOf(\".\") + 1); Map map = Maps.newHashMap(); try { String uploadUrl = storageService.upload(wangEditorH5File.getBytes(), extName); String url = FASTDFS_BASE_URL + uploadUrl; // 上传成功 map.put(\"errno\", 0); map.put(\"data\", new String[]{url}); } catch (IOException e) { // 上传失败 map.put(\"errno\", 1); map.put(\"message\", \"服务端错误\"); } return MapperUtils.mapToJson(map); } return \"\"; } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter15/实现前端文件上传.html":{"url":"chapter15/实现前端文件上传.html","title":"实现前端文件上传","keywords":"","body":"实现前端文件上传 文件上传控件 HTML 图片1 拖拽文件到这里或点击上传 仅支持图片 图片2 拖拽文件到这里或点击上传 仅支持图片 图片3 拖拽文件到这里或点击上传 仅支持图片 JS 调用 /** * 初始化上传组件 */ function initDropzone() { // mDropzoneOne 为元素 ID Dropzone.options.mDropzoneOne = { // 后台文件上传参数名 paramName: \"uploadFile\", // 最大上传文件数 maxFiles: 1, // 最大上传文件尺寸（MB） maxFilesize: 10, // 增加删除链接 addRemoveLinks: true, // 指定上传文件类型 acceptedFiles: \"image/*\", // 文件类型验证处理 accept: function (file, done) { if (file.name == \"justinbieber.jpg\") { done(\"Naha, you don't.\"); } else { done(); } }, // 文件上传成功处理 success: function (file, imageInfo) { $(\"#image1\").val(imageInfo.url); } }; Dropzone.options.mDropzoneTwo = { // 后台文件上传参数名 paramName: \"uploadFile\", // 最大上传文件数 maxFiles: 1, // 最大上传文件尺寸（MB） maxFilesize: 10, // 增加删除链接 addRemoveLinks: true, // 指定上传文件类型 acceptedFiles: \"image/*\", // 文件类型验证处理 accept: function (file, done) { if (file.name == \"justinbieber.jpg\") { done(\"Naha, you don't.\"); } else { done(); } }, // 文件上传成功处理 success: function (file, imageInfo) { $(\"#image2\").val(imageInfo.url); } }; Dropzone.options.mDropzoneThree = { // 后台文件上传参数名 paramName: \"uploadFile\", // 最大上传文件数 maxFiles: 1, // 最大上传文件尺寸（MB） maxFilesize: 10, // 增加删除链接 addRemoveLinks: true, // 指定上传文件类型 acceptedFiles: \"image/*\", // 文件类型验证处理 accept: function (file, done) { if (file.name == \"justinbieber.jpg\") { done(\"Naha, you don't.\"); } else { done(); } }, // 文件上传成功处理 success: function (file, imageInfo) { $(\"#image3\").val(imageInfo.url); } }; } 富文本控件 需要使用 wangEditor3 插件 HTML 文章详情 在此处输入内容 JS 调用 /** * 初始化富文本控件 */ function initEditor() { var editor = new window.wangEditor(\"#articleDesc\"); // 配置服务器端地址 editor.customConfig.uploadImgServer = '/upload'; // 后台文件上传参数名 editor.customConfig.uploadFileName = 'wangEditorH5File'; // 监控变化，同步更新到 textarea var articleDescText = $('#articleDescText'); editor.customConfig.onchange = function (html) { articleDescText.val(html); }; editor.create(); // 初始化 textarea 的值 // articleDescText.val(editor.txt.html()); } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter15/所需工具类.html":{"url":"chapter15/所需工具类.html","title":"所需工具类","keywords":"","body":"所需工具类 MapperUtils package com.ooqui.gaming.server.commons.utils; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.ObjectMapper; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * Jackson 工具类 * Title: MapperUtils * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 21:50 */ public class MapperUtils { private final static ObjectMapper objectMapper = new ObjectMapper(); public static ObjectMapper getInstance() { return objectMapper; } /** * 转换为 JSON 字符串 * * @param obj * @return * @throws Exception */ public static String obj2json(Object obj) throws Exception { return objectMapper.writeValueAsString(obj); } /** * 转换为 JSON 字符串，忽略空值 * * @param obj * @return * @throws Exception */ public static String obj2jsonIgnoreNull(Object obj) throws Exception { ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); return mapper.writeValueAsString(obj); } /** * 转换为 JavaBean * * @param jsonString * @param clazz * @return * @throws Exception */ public static T json2pojo(String jsonString, Class clazz) throws Exception { objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true); return objectMapper.readValue(jsonString, clazz); } /** * 字符串转换为 Map * * @param jsonString * @return * @throws Exception */ public static Map json2map(String jsonString) throws Exception { ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); return mapper.readValue(jsonString, Map.class); } /** * 字符串转换为 Map */ public static Map json2map(String jsonString, Class clazz) throws Exception { Map> map = objectMapper.readValue(jsonString, new TypeReference>() { }); Map result = new HashMap(); for (Map.Entry> entry : map.entrySet()) { result.put(entry.getKey(), map2pojo(entry.getValue(), clazz)); } return result; } /** * 深度转换 JSON 成 Map * * @param json * @return */ public static Map json2mapDeeply(String json) throws Exception { return json2MapRecursion(json, objectMapper); } /** * 把 JSON 解析成 List，如果 List 内部的元素存在 jsonString，继续解析 * * @param json * @param mapper 解析工具 * @return * @throws Exception */ private static List json2ListRecursion(String json, ObjectMapper mapper) throws Exception { if (json == null) { return null; } List list = mapper.readValue(json, List.class); for (Object obj : list) { if (obj != null && obj instanceof String) { String str = (String) obj; if (str.startsWith(\"[\")) { obj = json2ListRecursion(str, mapper); } else if (obj.toString().startsWith(\"{\")) { obj = json2MapRecursion(str, mapper); } } } return list; } /** * 把 JSON 解析成 Map，如果 Map 内部的 Value 存在 jsonString，继续解析 * * @param json * @param mapper * @return * @throws Exception */ private static Map json2MapRecursion(String json, ObjectMapper mapper) throws Exception { if (json == null) { return null; } Map map = mapper.readValue(json, Map.class); for (Map.Entry entry : map.entrySet()) { Object obj = entry.getValue(); if (obj != null && obj instanceof String) { String str = ((String) obj); if (str.startsWith(\"[\")) { List list = json2ListRecursion(str, mapper); map.put(entry.getKey(), list); } else if (str.startsWith(\"{\")) { Map mapRecursion = json2MapRecursion(str, mapper); map.put(entry.getKey(), mapRecursion); } } } return map; } /** * 将 JSON 数组转换为集合 * * @param jsonArrayStr * @param clazz * @return * @throws Exception */ public static List json2list(String jsonArrayStr, Class clazz) throws Exception { JavaType javaType = getCollectionType(ArrayList.class, clazz); List list = (List) objectMapper.readValue(jsonArrayStr, javaType); return list; } /** * 获取泛型的 Collection Type * * @param collectionClass 泛型的Collection * @param elementClasses 元素类 * @return JavaType Java类型 * @since 1.0 */ public static JavaType getCollectionType(Class collectionClass, Class... elementClasses) { return objectMapper.getTypeFactory().constructParametricType(collectionClass, elementClasses); } /** * 将 Map 转换为 JavaBean * * @param map * @param clazz * @return */ public static T map2pojo(Map map, Class clazz) { return objectMapper.convertValue(map, clazz); } /** * 将 Map 转换为 JSON * * @param map * @return */ public static String mapToJson(Map map) { try { return objectMapper.writeValueAsString(map); } catch (Exception e) { e.printStackTrace(); } return \"\"; } /** * 将 JSON 对象转换为 JavaBean * * @param obj * @param clazz * @return */ public static T obj2pojo(Object obj, Class clazz) { return objectMapper.convertValue(obj, clazz); } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter16.html":{"url":"chapter16.html","title":"第16章 项目实战-使用 HBuilder 创建客户端","keywords":"","body":"第十六章 项目实战-使用 HBuilder 创建客户端 创建移动 APP 项目 运行移动 APP 项目 使用阿里巴巴矢量图标库 实现底部状态栏切换 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:18:19 "},"chapter16/创建移动APP项目.html":{"url":"chapter16/创建移动APP项目.html","title":"创建移动 APP 项目","keywords":"","body":"创建移动 APP 项目 HBuilder 官网 http://dcloud.io/index.html 安装 HBuilder 略 创建移动 APP 项目 点击 文件 -> 新建 -> 移动App，创建一个 MUI 项目 项目默认的目录结构 修改目录结构 结构说明： ├─assets // 统一的资源文件目录 │ ├─apps // 项目所需的资源文件目录 │ │ ├─css │ │ ├─img │ │ └─js │ └─global // 通用的资源文件目录 │ ├─css │ │ mui.css │ │ mui.min.css │ ├─fonts // 字体文件目录 │ │ mui.ttf │ └─js │ mui.js │ mui.min.js Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter16/运行移动APP项目.html":{"url":"chapter16/运行移动APP项目.html","title":"运行移动 APP 项目","keywords":"","body":"运行移动 APP 项目 HTML 我的头条 首页 电话 邮件 设置 mui.init(); 真机运行 点击 运行 -> 真机运行 -> HBuilder基座运行 真机运行效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter16/使用阿里巴巴矢量图标库.html":{"url":"chapter16/使用阿里巴巴矢量图标库.html","title":"使用阿里巴巴矢量图标库","keywords":"","body":"使用阿里巴巴矢量图标库 图标库地址 http://www.iconfont.cn/ 创建项目 点击 图标管理 -> 我的项目 新建项目 选择图标 下载图标 使用图标 修改 iconfont.css 默认的 CSS @font-face {font-family: \"iconfont\"; src: url('iconfont.eot?t=1520261222831'); /* IE9*/ src: url('iconfont.eot?t=1520261222831#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAAcwAAsAAAAACkwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFZW7knXY21hcAAAAYAAAAB8AAAByKEo4QtnbHlmAAAB/AAAAxoAAAO8dn26k2hlYWQAAAUYAAAALwAAADYQpjbLaGhlYQAABUgAAAAcAAAAJAfeA4dobXR4AAAFZAAAABMAAAAYF+kAAGxvY2EAAAV4AAAADgAAAA4DlgJwbWF4cAAABYgAAAAfAAAAIAEVAF1uYW1lAAAFqAAAAUUAAAJtPlT+fXBvc3QAAAbwAAAAQAAAAFrj1K70eJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2Bk/sM4gYGVgYOpk+kMAwNDP4RmfM1gxMjBwMDEwMrMgBUEpLmmMDgwVDx/ydzwv4EhhrmBoQEozAiSAwA2Bw1aeJzFkcENhDAMBMcQEEKUcpWcrh7Eg8JohA8FYFEFt07gQQVsNFF2ZcVRDDRALT4igc0YoVGp5bymz3niKz/QUek87Yuvvvlxnkqf7pap+l7hKt2VoqO1vCZ7r/VTQ95/l4s5TBd64r4U9Gf4Wog5+VaIWflRoPkDHkwkl3icTZNPaBxVHMff9/2ZmZ1sZubNzM7sn2yy/6ftJqPZP7No7LaUgra0xSIovUiLlx6q4KUlTSnxoFSiUC85JEVkU/BgA17qKULp0TZSDz3Ui4jptVi86tS3rgYfj++DL9/34/N7f4gg5MWvbIfliUcOkEVynLxJCLQ2ahYtoxr1YtpGripyoW+xqB5V9XotZocR1jQ/6CS9Vqjpmg0Ls+hWO0kU0wj93pAuoROUgUKp+JbbnHHZTZj5aPbj9CQdITdXn7GHC+mJ+SN+p+IZV7KuW3DdzwxNCINSblt4PwwyImNq6W1hF3M7cwfpHLKFqHjq3HSl5F640fug3AwzwOoqvFLF+vqILEo1rxUDzy3ozrSRL07XGz6u7E3lvWy59RtRg6pef2H3WIME5HVCPC1qJQMknVDBW4jQqulqRb3WOoyYanrOV+cQI5K9pBPkpB92+0PVVpjrBkn/X9PCeXsqw0wszxwrYNlkft5MPzUCI/1EZOiDR7ZEOz4A1/qhEUPOSm+bnjl/ln5rGG5Zsnl8BcssGUg8L901Sr4qtMB5+pDT9Ki0190iCv66qrFQw8u2lHb6yMblxaWlxcvQLCxMrEabEKZ6+4l9xI6SPGmQRN2hAregzyJUqgVhNxkMMegO0VTLxI2hQi+hZSGYU0cQjkOswkYrKyOGd8+890WJZgwueeX7Fboy+usZXbt4cY1O9EP37FIu45jMCPonLCG5pJWrW4xtXT33eb26eclwKJxrt6gy9vfQtXTwxvIhmzNHCrt56ZgDc3wvUOz32X3WJvOEiGiI/j77GDpW/HXl7HNrfhh0w6AzBNtZT17hT+/cecqVXnhbvRmpn35nY5fz3Q2leG2gaUz7UpdTmNl49ebp7T0h9rZVHIfGEKLFdjc2f+T84eapGz3d0flIzzpjJq6YHrNvFNMUCcnBMRkmSAojBvsfj9dsqT+gyyAMBsGgmQwS0Q8puftciOd3J7r1hPMnW/+o/4IYjuCAqXOdgZhAqrpv72e/+/3Pn/8LK8X124IZXE/vZVUc7JZuTq/+cV0h/g1Zw7u5AAB4nGNgZGBgAOKCmVzf4vltvjJwszCAwLXDlWkI+v8hFgZmByCXg4EJJAoANs8KvAB4nGNgZGBgbvjfwBDDwgACQJKRARWwAQBHDAJveJxjYWBgYH7JwMDCgIoBEp8BAQAAAAAAAHYA5AFCAYwB3gAAeJxjYGRgYGBjCGRgZQABJiDmAkIGhv9gPgMAEUgBcwB4nGWPTU7DMBCFX/oHpBKqqGCH5AViASj9EatuWFRq911036ZOmyqJI8et1ANwHo7ACTgC3IA78EgnmzaWx9+8eWNPANzgBx6O3y33kT1cMjtyDRe4F65TfxBukF+Em2jjVbhF/U3YxzOmwm10YXmD17hi9oR3YQ8dfAjXcI1P4Tr1L+EG+Vu4iTv8CrfQ8erCPuZeV7iNRy/2x1YvnF6p5UHFockikzm/gple75KFrdLqnGtbxCZTg6BfSVOdaVvdU+zXQ+ciFVmTqgmrOkmMyq3Z6tAFG+fyUa8XiR6EJuVYY/62xgKOcQWFJQ6MMUIYZIjK6Og7VWb0r7FDwl57Vj3N53RbFNT/c4UBAvTPXFO6stJ5Ok+BPV8bUnV0K27LnpQ0kV7NSRKyQl7WtlRC6gE2ZVeOEXpc0Yk/KGdI/wAJWm7IAAAAeJxjYGKAAC4G7ICNkYmRmZGFkZWRjZGdgbGCJSM/N5UjtzI+JzM9o4SnODWxKDkDwuEuy0xJzYewGRgAVqYPUQ==') format('woff'), url('iconfont.ttf?t=1520261222831') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url('iconfont.svg?t=1520261222831#iconfont') format('svg'); /* iOS 4.1- */ } .iconfont { font-family:\"iconfont\" !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .icon-home:before { content: \"\\e6b8\"; } .icon-my_light:before { content: \"\\e7d5\"; } .icon-search_light:before { content: \"\\e7da\"; } .icon-video_light:before { content: \"\\e7e9\"; } 修改后的 CSS 为保证和 mui 目录结构统一，建议将字体文件放在 fonts 目录下，这样我们需要修改 @font-face 下的 url 属性； 只兼容 iOS 和 Android 版本的话，我们仅需要 ttf 格式的字体即可，其它字体可以删除；同时，我们也仅需保留-webkit前缀语法，-moz前缀部分可以删除； @font-face { font-family: \"iconfont\"; src: url('iconfont.eot?t=1520261222831'); src: url('iconfont.eot?t=1520261222831#iefix') format('embedded-opentype'), url('data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAAcwAAsAAAAACkwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFZW7knXY21hcAAAAYAAAAB8AAAByKEo4QtnbHlmAAAB/AAAAxoAAAO8dn26k2hlYWQAAAUYAAAALwAAADYQpjbLaGhlYQAABUgAAAAcAAAAJAfeA4dobXR4AAAFZAAAABMAAAAYF+kAAGxvY2EAAAV4AAAADgAAAA4DlgJwbWF4cAAABYgAAAAfAAAAIAEVAF1uYW1lAAAFqAAAAUUAAAJtPlT+fXBvc3QAAAbwAAAAQAAAAFrj1K70eJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2Bk/sM4gYGVgYOpk+kMAwNDP4RmfM1gxMjBwMDEwMrMgBUEpLmmMDgwVDx/ydzwv4EhhrmBoQEozAiSAwA2Bw1aeJzFkcENhDAMBMcQEEKUcpWcrh7Eg8JohA8FYFEFt07gQQVsNFF2ZcVRDDRALT4igc0YoVGp5bymz3niKz/QUek87Yuvvvlxnkqf7pap+l7hKt2VoqO1vCZ7r/VTQ95/l4s5TBd64r4U9Gf4Wog5+VaIWflRoPkDHkwkl3icTZNPaBxVHMff9/2ZmZ1sZubNzM7sn2yy/6ftJqPZP7No7LaUgra0xSIovUiLlx6q4KUlTSnxoFSiUC85JEVkU/BgA17qKULp0TZSDz3Ui4jptVi86tS3rgYfj++DL9/34/N7f4gg5MWvbIfliUcOkEVynLxJCLQ2ahYtoxr1YtpGripyoW+xqB5V9XotZocR1jQ/6CS9Vqjpmg0Ls+hWO0kU0wj93pAuoROUgUKp+JbbnHHZTZj5aPbj9CQdITdXn7GHC+mJ+SN+p+IZV7KuW3DdzwxNCINSblt4PwwyImNq6W1hF3M7cwfpHLKFqHjq3HSl5F640fug3AwzwOoqvFLF+vqILEo1rxUDzy3ozrSRL07XGz6u7E3lvWy59RtRg6pef2H3WIME5HVCPC1qJQMknVDBW4jQqulqRb3WOoyYanrOV+cQI5K9pBPkpB92+0PVVpjrBkn/X9PCeXsqw0wszxwrYNlkft5MPzUCI/1EZOiDR7ZEOz4A1/qhEUPOSm+bnjl/ln5rGG5Zsnl8BcssGUg8L901Sr4qtMB5+pDT9Ki0190iCv66qrFQw8u2lHb6yMblxaWlxcvQLCxMrEabEKZ6+4l9xI6SPGmQRN2hAregzyJUqgVhNxkMMegO0VTLxI2hQi+hZSGYU0cQjkOswkYrKyOGd8+890WJZgwueeX7Fboy+usZXbt4cY1O9EP37FIu45jMCPonLCG5pJWrW4xtXT33eb26eclwKJxrt6gy9vfQtXTwxvIhmzNHCrt56ZgDc3wvUOz32X3WJvOEiGiI/j77GDpW/HXl7HNrfhh0w6AzBNtZT17hT+/cecqVXnhbvRmpn35nY5fz3Q2leG2gaUz7UpdTmNl49ebp7T0h9rZVHIfGEKLFdjc2f+T84eapGz3d0flIzzpjJq6YHrNvFNMUCcnBMRkmSAojBvsfj9dsqT+gyyAMBsGgmQwS0Q8puftciOd3J7r1hPMnW/+o/4IYjuCAqXOdgZhAqrpv72e/+/3Pn/8LK8X124IZXE/vZVUc7JZuTq/+cV0h/g1Zw7u5AAB4nGNgZGBgAOKCmVzf4vltvjJwszCAwLXDlWkI+v8hFgZmByCXg4EJJAoANs8KvAB4nGNgZGBgbvjfwBDDwgACQJKRARWwAQBHDAJveJxjYWBgYH7JwMDCgIoBEp8BAQAAAAAAAHYA5AFCAYwB3gAAeJxjYGRgYGBjCGRgZQABJiDmAkIGhv9gPgMAEUgBcwB4nGWPTU7DMBCFX/oHpBKqqGCH5AViASj9EatuWFRq911036ZOmyqJI8et1ANwHo7ACTgC3IA78EgnmzaWx9+8eWNPANzgBx6O3y33kT1cMjtyDRe4F65TfxBukF+Em2jjVbhF/U3YxzOmwm10YXmD17hi9oR3YQ8dfAjXcI1P4Tr1L+EG+Vu4iTv8CrfQ8erCPuZeV7iNRy/2x1YvnF6p5UHFockikzm/gple75KFrdLqnGtbxCZTg6BfSVOdaVvdU+zXQ+ciFVmTqgmrOkmMyq3Z6tAFG+fyUa8XiR6EJuVYY/62xgKOcQWFJQ6MMUIYZIjK6Og7VWb0r7FDwl57Vj3N53RbFNT/c4UBAvTPXFO6stJ5Ok+BPV8bUnV0K27LnpQ0kV7NSRKyQl7WtlRC6gE2ZVeOEXpc0Yk/KGdI/wAJWm7IAAAAeJxjYGKAAC4G7ICNkYmRmZGFkZWRjZGdgbGCJSM/N5UjtzI+JzM9o4SnODWxKDkDwuEuy0xJzYewGRgAVqYPUQ==') format('woff'), url('iconfont.ttf?t=1520261222831') format('truetype'), url('iconfont.svg?t=1520261222831#iconfont') format('svg'); } .iconfont { font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale; } .icon-home:before { content: \"\\e6b8\"; } .icon-my_light:before { content: \"\\e7d5\"; } .icon-search_light:before { content: \"\\e7da\"; } .icon-video_light:before { content: \"\\e7e9\"; } 将字体文件复制到项目 集成 MUI 将 iconfont.css 及 iconfont.ttf 两个文件分别拷贝到 mui 工程 css 及 fonts 目录下，然后即可在 mui 中引用刚生成的字体图标，我们以选项卡为例，代码如下： 资讯 视频 发现 我的 效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter16/实现底部选项卡切换.html":{"url":"chapter16/实现底部选项卡切换.html","title":"实现底部选项卡切换","keywords":"","body":"实现底部选项卡切换 帮助 http://ask.dcloud.net.cn/article/650 HTML 我的头条 资讯 视频 发现 我的 JS var Main = function() { // 设置默认打开首页显示的子页序号； var index = 0; // 把子页的路径写在数组里面 var subpages = ['news.html', 'video.html']; /** * 初始化首页 */ var handlerInitMain = function() { mui.init(); mui.plusReady(function() { handlerInitWebview(); handlerBindChangeTabEvent(); }); } /** * 初始化 Webview */ var handlerInitWebview = function() { // 获取当前页面所属的 Webview 窗口对象 var self = plus.webview.currentWebview(); for(var i = 0; i Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter17.html":{"url":"chapter17.html","title":"第17章 项目实战-创建 API 网关","keywords":"","body":"第十七章 项目实战-创建 API 网关 API Gateway 简介 创建频道管理接口项目 创建频道管理实现项目 创建文章管理接口项目 创建文章管理实现项目 创建 API 网关项目 项目配置 RESTful 风格 Swagger2 生成接口文档 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:18:27 "},"chapter17/APIGateway简介.html":{"url":"chapter17/APIGateway简介.html","title":"API Gateway 简介","keywords":"","body":"API Gateway 简介 以下内容摘自《微服务：从设计到部署》 当您选择将应用程序构建成为一组微服务时，您需要决定应用程序客户端将如何与微服务进行交互。单体应用程序只有一组端点（endpoint），通常使用复制（replicated）结合负载均衡来分配流量。 然而，在微服务架构中，每个微服务都暴露一组通常比较细颗粒的端点。在本文中，我们将研究如何改进客户端通信，并提出一个使用 API 网关的方案。 我们假设您正在为一个购物应用开发一个原生移动客户端。您可能需要实现一个产品详细信息页面，用于展示给定商品的信息。正如下图所示，当我们在亚马逊的安卓移动应用中滚动产品明细页时，它将会呈现给我们 这是一个智能手机应用，产品详细信息页面展示了许多信息。不仅有基本的产品信息，如名称、描述和价格，页面还展示了： 购物车中的物品数量 订单历史 客户评价 低库存警告 配送选项 各种推荐，包括了购买此产品的客户购买的其他产品 选择性购买选项 在使用单体应用架构的情况下，移动客户端通过对应用程序进行单个 REST 调用来检索此数据，例如： GET api.company.com/productdetails/productId 负载均衡器将请求路由到几个相同应用程序实例中的其中一个。之后，应用程序查询各个数据库表并返回响应给客户端。相比之下，当使用微服务架构时，产品详细页面上展示的数据来自多个微服务。以下是一些微服务，可能拥有给定产品页面展示的数据： 订单服务 — 订单历史 目录（catalog）服务 — 基本的产品信息，如产品名称、图片和价格 评价服务 — 客户评价 库存服务 — 低库存警告 配送服务 — 配送选项、期限和费用，由配送方的 API 单独提供 推荐服务 — 推荐类目 我们需要决定移动客户端如何访问这些服务。让我们来看看有哪些方法。 客户端与微服务直接通信 理论上，客户端可以直接向每个微服务发送请求。每个微服务都有一个公开的端点： https://serviceName.api.company.name 该 URL 将映射到用于跨可用实例分发请求的微服务负载均衡器。为了检索特定的产品页面信息，移动客户端将向上述的每个微服务发送请求。 不幸的是，这种方式存在着挑战与限制。第一个问题是客户端的需求与每个微服务暴露的细粒度的 API 不匹配。在此示例中，客户端需要进行七次单独请求。如果在更加复杂的应用中，它可能需要做更多的工作。例如，Amazon 展示了在产品页面渲染中如何牵涉到数百个微服务。虽然客户端可以通过 LAN 发送许多请求，但在公共互联网下效率低下，在移动网络必然是不切实际。 客户端直接调用微服务存在的另一个问题是有些可能使用了非 web 友好协议。一个服务可能使用了 Thrift 二进制 RPC，而另一个则可能使用 AMQP 消息协议。这两个协议无论是对浏览器还是防火墙都是不友好的，最好是在内部使用。应用程序在防火墙之外应该使用 HTTP 或者 WebSocket 之类的协议。 这种方法的另一个缺点是它难以重构微服务。随着时间推移，我们可能会想改变系统划分服务。例如，我们可能会合并两个服务或者将服务拆分为两个或者多个。然而，如果客户端直接与服务进行通信，实施这类的重构将变得非常困难。 由于存在这些问题，很少有客户端直接与微服务进行通信。 使用 API 网关 通常更好的方法是使用 API 网关。API 网关是一个服务器，是系统的单入口点。它类似于面向对象设计模式中的门面（Facade）模式。API 网关封装了内部系统架构，并针对每个客户端提供一个定制 API。它还可用于认证、监控、负载均衡、缓存和静态响应处理。 API 网关负责请求路由、组合和协议转换。所有的客户端请求首先要通过 API 网关，之后请求被路由到适当的服务。API 网关通常会通过调用多个微服务和聚合结果来处理一个请求。它可以在 Web 协议（如 HTTP 和 WebSocket）和用于内部的非 Web 友好协议之间进行转换。 API 还可以为每个客户端提供一个定制 API。它通常会为移动客户端暴露一个粗粒度的 API。例如，考虑一下产品详细信息场景。API 网关可以提供一个端点 /productdetails?productid=xxx，如上图所示，一个使用了 API 网关的微服务。允许移动客户端通过一个单独的请求来检索所有产品详细信息。API 网关通过调用各种服务（产品信息、推荐、评价等）并组合结果。 一个很好的 API 网关案例是 Netflix API 网关。Netflix 流媒体服务可用于数百种不同类型的设备，包括电视机、机顶盒、智能手机、游戏机和平板电脑等。起初，Netflix 尝试为他们的流媒体服务提供一个通用的 API。后来，他们发现由于设备种类繁多，并且他们各自有着不同需求，所以并不是能很好地运作。如今，他们使用了 API 网关，通过运行特定设备适配代码来为每个设备提供一个定制 API。 API 网关的优点与缺点 正如您所料，使用 API 网关同样存在好处与坏处。使用 API 网关的主要好处是它封装了应用程序的内部结构。客户端只需要与网关通信，而不必调用特定的服务。API 网关为每种类型的客户端提供了特定的 API，减少了客户端与应用程序之间的往返次数。同时，它还简化了客户端的代码。 API 网关也存在一些缺点，它是另一个高度可用的组件，需要开发、部署和管理。另外，还有一个风险是 API 网关可能会成为开发瓶颈。开发人员必须更新 API 网关以暴露每个微服务的端点。 重要的是更新 API 网关的过程应尽可能地放缓一些。否则，开发人员将被迫排队等待网关更新。尽管 API 网关存在这些缺点，但对于大多数的真实应用来说，使用 API 是合理的。 实施 API 网关 我们已经了解了使用 API 网关的动机与权衡。接下来让我们看看您需要考虑的各种设计问题。 性能与可扩展性 只有少数公司能达到 Netflix 的运营规模，每天需要处理数十亿的请求。然而，对于大多数应用来说，API 网关的性能和可扩展性是相当重要的。因此，在一个支持异步、非阻塞 I/O 平台上构建 API 网关是很有必要的。可以使用不同的技术来实现一个可扩展的 API 网关。在 JVM 上，您可以使用基于 NIO 的框架，如 Netty、Vertx、Spring Reactor 或者 JBoss Undertow。一个流行的非 JVM 选择是使用 Node.js，它是一个建立在 Chrome 的 JavaScript 引擎之上的平台。 使用响应式编程模型 API 网关通过简单地把他们（请求）路由到适当的后端服务来处理一些请求。它通过调用多个后端服务并聚合结果来处理其他请求。对于某些请求，如产品详细信息请求，对后端服务请求而言是彼此独立的。为了把响应时间缩短到最小，API 网关应该并发执行独立请求。 然而，有时候，请求是相互依赖的。首先，API 网关可能需要在将请求路由到后端服务之前，通过调用验证服务来验证请求。同样，为了从客户的愿望清单中获取产品信息，API 网关首先必须检索包含该信息的客户资料，然后检索每个产品的信息。另一个有趣的 API 组合案例是 Netflix 视频网格。 使用传统的异步回调方式来编写 API 组合代码会很快使你陷入回调地狱。代码将会变得杂乱、难以理解并且容易出错。一个更好的方式是使用响应式方法以声明式编写 API 网关代码。响应式抽象的例子包括 Scala 的 Future、Java 8 中的 CompletableFuture 和 JavaScript 中的 Promise。还有 Reactive Extensions（也称为 Rx 或 ReactiveX），最初由 Microsoft 为 .NET 平台开发。Netflix 为 JVM 创建了 RxJava，专门应用于其 API 网关。还有用于 JavaScript 的 RxJS，它可以在浏览器和 Node.js 中运行。使用响应式方式可让您能够编写出简单而高效的 API 网关代码。 服务调用 一个基于微服务的应用程序是一个分布式系统，必须使用一个进程间（inter-process）通信机制。有两种进程间通信方案。一是使用基于消息的异步机制。某些实现采用了消息代理，如 JMS 和 AMQP。其他采用无代理的方式直接与服务通信，如 Zeromq。 另一种类型的进程间通信采用了同步机制，如 HTTP 和 Thrift。系统通常会同时使用异步和同步方式。甚至可以为每种方式应用多个实现。因此，API 网关需要支持各种通信机制。 服务发现 API 网关需要知道与其通信的每个微服务的位置（IP 地址和端口）。在传统应用程序中，您可以将这些位置硬编码，但在现代基于云的微服务应用程序中，找到所需的位置不是一件简单的事情。 基础设施服务（比如消息代理）通常都有一个可以通过系统环境变量来指定的静态位置。但是，要确定应用程序服务的位置并不是那么容易。 应用服务可以动态分配位置。此外，由于自动扩缩和升级，一个服务的整组实例可以动态变更。因此，API 网关与系统中的任何其他服务客户端一样，需要使用系统的服务发现机制：服务端发现或客户端发现。第四章中更详细地描述了服务发现。现在需要注意的是，如果系统使用客户端发现，API 网关必须能够查询服务注册中心，该注册中心是所有微服务实例及其位置的数据库。 处理局部故障 实施 API 网关时必须解决的另一个问题是局部故障问题。当一个服务调用另一个响应缓慢或者不可用的服务时，所有分布式系统都会出现此问题。API 网关不应该无期限地等待下游服务。但是，如何处理故障问题取决于特定的方案和哪些服务发生故障。例如，如果推荐服务在获取产品详细信息时没有响应，API 网关应将其余的产品详细信息返回给客户端，因为它们对用户仍然有用。建议可以是空的，也可以用其他代替，例如硬编码的十强名单。然而，如果产品信息服务没有响应，那么 API 网关应该向客户端返回错误。 如果可以，API 网关还可以返回缓存数据。例如，由于产品价格变化不大，当价格服务不可用时，API 网关可以返回被缓存的价格数据。数据可以由 API 网关缓存或存储在外部缓存中，如 Redis 或 Memcached。API 网关通过返回默认数据或缓存数据，确保系统发生故障时最小程度上影响到用户体验。 Netflix Hystrix 是一个非常有用的库，用于编写调用远程服务代码。Hystrix 可以使超出指定阈值的调用超时。它实现了断路器模式，防止客户端不必要地等待无响应的服务。如果服务的错误率超过指定阈值，Hystrix 将会跳闸，所有请求将在指定的时间内立即失败。Hystrix 允许您在请求失败时定义回退操作，例如从缓存读取或返回默认值。如果您正在使用 JVM，那么您一定要考虑使用 Hystrix。如果您是在非 JVM 环境中运行，则应使用同等作用的库。 总结 对于大多数基于微服务的应用程序来说，实现一个 API 网关是很有意义的，API 网关充当着系统的单入口点，并且负责请求路由，组合和协议转换。它为每个应用程序客户端提供了一个自定义 API。API 网关还可以通过返回缓存或默认数据来掩盖后端服务故障。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter17/创建频道管理接口项目.html":{"url":"chapter17/创建频道管理接口项目.html","title":"创建频道管理接口项目","keywords":"","body":"创建频道管理接口项目 项目名称 gaming-server-service-channel-api POM 4.0.0 com.ooqiu.gaming gaming-server-service-channel-api 1.0.0-SNAPSHOT jar gaming-server-service-channel-api com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-domain 1.0.0-SNAPSHOT com.github.pagehelper pagehelper-spring-boot-starter 定义接口 package com.ooqiu.gaming.service.channel.api; import com.ooqiu.gaming.server.domain.Channel; import java.util.List; public interface ChannelService { /** * 查询全部频道 * @return */ public List selectAll(); } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter17/创建频道管理实现项目.html":{"url":"chapter17/创建频道管理实现项目.html","title":"创建频道管理实现项目","keywords":"","body":"创建频道管理实现项目 项目名称 gaming-server-service-channel POM 4.0.0 com.ooqiu.gaming gaming-server-service-channel 1.0.0-SNAPSHOT jar gaming-server-service-channel com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT org.springframework.boot spring-boot-starter org.springframework.boot spring-boot-starter-actuator org.springframework.boot spring-boot-starter-test test com.alibaba druid-spring-boot-starter tk.mybatis mapper-spring-boot-starter mysql mysql-connector-java com.alibaba.boot dubbo-spring-boot-starter com.101tec zkclient com.ooqiu.gaming gaming-server-service-channel-api 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-commons 1.0.0-SNAPSHOT org.springframework.boot spring-boot-maven-plugin com.ooqiu.gaming.service.channel.GamingServerServiceChannelApplication 实现接口 package com.ooqiu.gaming.service.channel.api.impl; import com.alibaba.dubbo.config.annotation.Service; import com.ooqiu.gaming.server.domain.Channel; import com.ooqiu.gaming.service.channel.api.ChannelService; import com.ooqiu.gaming.service.channel.mapper.ChannelMapper; import com.ooqui.gaming.server.commons.constant.DubboVersionConstant; import org.springframework.beans.factory.annotation.Autowired; import java.util.List; @Service(version = DubboVersionConstant.DUBBO_VERSION_GAMING_SERVER_SERVICE_CHANNEL) public class ChannelServiceImpl implements ChannelService { @Autowired private ChannelMapper channelMapper; @Override public List selectAll() { return channelMapper.selectAll(); } } Application package com.ooqiu.gaming.service.channel; import com.alibaba.dubbo.container.Main; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(basePackages = \"com.ooqiu.gaming.service.channel.mapper\") public class GamingServerServiceChannelApplication { public static void main(String[] args) { SpringApplication.run(GamingServerServiceChannelApplication.class); Main.main(args); } } application.yml spring: application: name: gaming-server-service-channel datasource: druid: url: jdbc:mysql://192.168.75.132:3306/toutiao?useUnicode=true&characterEncoding=utf-8&useSSL=false username: root password: 123456 initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true driver-class-name: com.mysql.jdbc.Driver mybatis: type-aliases-package: com.ooqiu.gaming.server.domain mapper-locations: classpath:mapper/*.xml dubbo: scan: base-packages: com.ooqiu.gaming.service.channel.api application: id: gaming-server-service-channel name: gaming-server-service-channel protocol: id: dubbo name: dubbo registry: id: zookeeper address: zookeeper://192.168.75.132:2181?backup=192.168.75.132:2182,192.168.75.132:2183 特别注意 Dubbo 配置中有一个 BUG（2.6.0），无法识别 application.yml 配置中的 dubbo.protocol.port 配置，但可以识别 application.properties 中的配置，所以我们需要新建一个 application.properties 配置文件，并配置 Dubbo 的端口 dubbo.protocol.port=20881 其他 复制 ChannelMapper 和 ChannelMapper.xml 文件复制到约定目录中 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter17/创建文章管理接口项目.html":{"url":"chapter17/创建文章管理接口项目.html","title":"创建文章管理接口项目","keywords":"","body":"创建文章管理接口项目 项目名称 gaming-server-service-article-api POM 4.0.0 com.ooqiu.gaming gaming-server-service-article-api 1.0.0-SNAPSHOT jar gaming-server-service-article-api com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-domain 1.0.0-SNAPSHOT com.github.pagehelper pagehelper-spring-boot-starter 定义接口 package com.ooqiu.gaming.service.article.api; import com.github.pagehelper.PageInfo; import com.ooqiu.gaming.server.domain.Article; public interface ArticleService { /** * 查询全部文章 * * @param pageNum 页码 * @param pageSize 笔数 * @return */ public PageInfo selectAll(int pageNum, int pageSize); /** * 根据频道查询文章 * * @param pageNum 页码 * @param pageSize 笔数 * @param channelId 频道 ID * @return */ public PageInfo selectByChannel(int pageNum, int pageSize, long channelId); /** * 根据类别查询文章 * * @param pageNum 页码 * @param pageSize 笔数 * @param type 文章类别：1/文章，2/视频 * @return */ public PageInfo selectByType(int pageNum, int pageSize, long type); } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter17/创建文章管理实现项目.html":{"url":"chapter17/创建文章管理实现项目.html","title":"创建文章管理实现项目","keywords":"","body":"创建文章管理实现项目 项目名称 gaming-server-service-article POM 4.0.0 com.ooqiu.gaming gaming-server-service-article 1.0.0-SNAPSHOT jar gaming-server-service-article com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT org.springframework.boot spring-boot-starter org.springframework.boot spring-boot-starter-actuator org.springframework.boot spring-boot-starter-test test com.alibaba druid-spring-boot-starter tk.mybatis mapper-spring-boot-starter mysql mysql-connector-java com.alibaba.boot dubbo-spring-boot-starter com.101tec zkclient com.ooqiu.gaming gaming-server-service-article-api 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-commons 1.0.0-SNAPSHOT org.springframework.boot spring-boot-maven-plugin com.ooqiu.gaming.service.article.GamingServerServiceArticleApplication 实现接口 package com.ooqiu.gaming.service.article.api.impl; import com.alibaba.dubbo.config.annotation.Service; import com.github.pagehelper.PageHelper; import com.github.pagehelper.PageInfo; import com.ooqiu.gaming.server.domain.Article; import com.ooqiu.gaming.service.article.api.ArticleService; import com.ooqiu.gaming.service.article.mapper.ArticleMapper; import com.ooqui.gaming.server.commons.constant.DubboVersionConstant; import org.springframework.beans.factory.annotation.Autowired; import tk.mybatis.mapper.entity.Example; @Service(version = DubboVersionConstant.DUBBO_VERSION_GAMING_SERVER_SERVICE_ARTICLE) public class ArticleServiceImpl implements ArticleService { @Autowired private ArticleMapper articleMapper; @Override public PageInfo selectAll(int pageNum, int pageSize) { Example example = new Example(Article.class); PageHelper.startPage(pageNum, pageSize); PageInfo pageInfo = new PageInfo<>(articleMapper.selectByExample(example)); return pageInfo; } @Override public PageInfo selectByChannel(int pageNum, int pageSize, long channelId) { Example example = new Example(Article.class); example.createCriteria().andEqualTo(\"channelId\", channelId); PageHelper.startPage(pageNum, pageSize); PageInfo pageInfo = new PageInfo<>(articleMapper.selectByExample(example)); return pageInfo; } @Override public PageInfo selectByType(int pageNum, int pageSize, long type) { Example example = new Example(Article.class); example.createCriteria().andEqualTo(\"type\", type); PageHelper.startPage(pageNum, pageSize); PageInfo pageInfo = new PageInfo<>(articleMapper.selectByExample(example)); return pageInfo; } } Application package com.ooqiu.gaming.service.article; import com.alibaba.dubbo.container.Main; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(basePackages = \"com.ooqiu.gaming.service.article.mapper\") public class GamingServerServiceArticleApplication { public static void main(String[] args) { SpringApplication.run(GamingServerServiceArticleApplication.class); Main.main(args); } } application.yml spring: application: name: gaming-server-service-article datasource: druid: url: jdbc:mysql://192.168.75.132:3306/toutiao?useUnicode=true&characterEncoding=utf-8&useSSL=false username: root password: 123456 initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true driver-class-name: com.mysql.jdbc.Driver mybatis: type-aliases-package: com.ooqiu.gaming.server.domain mapper-locations: classpath:mapper/*.xml dubbo: scan: base-packages: com.ooqiu.gaming.service.article.api application: id: gaming-server-service-article name: gaming-server-service-article protocol: id: dubbo name: dubbo registry: id: zookeeper address: zookeeper://192.168.75.132:2181?backup=192.168.75.132:2182,192.168.75.132:2183 application.properties dubbo.protocol.port=20882 其他 复制 ArticleMapper 和 ArticleMapper.xml 文件复制到约定目录中 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter17/创建API网关项目.html":{"url":"chapter17/创建API网关项目.html","title":"创建 API 网关项目","keywords":"","body":"创建 API 网关项目 项目配置 RESTful 风格 Swagger2 生成接口文档 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:18:27 "},"chapter17/创建API网关项目/项目配置.html":{"url":"chapter17/创建API网关项目/项目配置.html","title":"项目配置","keywords":"","body":"项目配置 项目名称 gaming-server-api POM 4.0.0 com.ooqiu.gaming gaming-server-api 1.0.0-SNAPSHOT jar gaming-server-api com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-actuator org.springframework.boot spring-boot-starter-test test com.alibaba.boot dubbo-spring-boot-starter com.101tec zkclient io.springfox springfox-swagger2 io.springfox springfox-swagger-ui com.ooqiu.gaming gaming-server-service-channel-api 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-service-article-api 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-commons 1.0.0-SNAPSHOT org.springframework.boot spring-boot-maven-plugin com.ooqiu.gaming.server.api.GamingServerApiApplication application.yml server: port: 8500 spring: application: name: gaming-server-api dubbo: scan: base-packages: com.ooqui.gaming.server.api application: id: gaming-server-api name: gaming-server-api registry: id: zookeeper address: zookeeper://192.168.75.132:2181?backup=192.168.75.132:2182,192.168.75.132:2183 # RESTFul 风格路径 rest: path: api: v1: api/v1 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter17/创建API网关项目/RESTFul风格.html":{"url":"chapter17/创建API网关项目/RESTFul风格.html","title":"RESTful 风格","keywords":"","body":"RESTful 风格 一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 风格路径配置 在 application.yml 配置文件中增加 RESTful 风格路径 # RESTful 风格路径 rest: path: api: v1: api/v1 创建与风格路径匹配的包和控制器 package com.ooqiu.gaming.server.api.controller.v1 Controller @RestController @RequestMapping(value = \"${rest.path.api.v1}/channel\") public class ChannelControllerV1 {} Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter17/创建API网关项目/Swagger2生成接口文档.html":{"url":"chapter17/创建API网关项目/Swagger2生成接口文档.html","title":"Swagger2 生成接口文档","keywords":"","body":"Swagger2 生成接口文档 手写文档存在的问题 文档需要更新的时候，需要再次发送一份给前端，也就是文档更新交流不及时。 接口返回结果不明确 不能直接在线测试接口，通常需要使用工具，比如：Postman 接口文档太多，不好管理 使用 Swagger 解决问题 Swagger 也就是为了解决这个问题，当然也不能说 Swagger 就一定是完美的，当然也有缺点，最明显的就是代码移入性比较强。 Maven io.springfox springfox-swagger2 2.8.0 io.springfox springfox-swagger-ui 2.8.0 Swagger2 配置类 注意：RequestHandlerSelectors.basePackage(\"com.ooqiu.gaming.server.api.controller\") 为 Controller 包路径，不然生成的文档扫描不到接口 package com.ooqiu.gaming.server.api.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; /** * Swagger2 配置类 * Title: Swagger2Configuration * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/7 3:35 */ @Configuration public class Swagger2Configuration { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.ooqiu.gaming.server.api.controller\")) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"我的头条 API 文档\") .description(\"我的头条 API 网关接口，http://www.funtl.com\") .termsOfServiceUrl(\"http://www.funtl.com\") .version(\"1.0.0\") .build(); } } Application Application.class 加上注解 @EnableSwagger2 表示开启 Swagger package com.ooqiu.gaming.server.api; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration; import springfox.documentation.swagger2.annotations.EnableSwagger2; @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) @EnableSwagger2 public class GamingServerApiApplication { public static void main(String[] args) { SpringApplication.run(GamingServerApiApplication.class, args); } } 控制器代码 频道控制器 package com.ooqiu.gaming.server.api.controller.v1; import com.alibaba.dubbo.config.annotation.Reference; import com.ooqiu.gaming.server.domain.Channel; import com.ooqiu.gaming.service.channel.api.ChannelService; import com.ooqui.gaming.server.commons.constant.DubboVersionConstant; import io.swagger.annotations.ApiOperation; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import java.util.List; /** * 频道接口 * Title: ChannelControllerV1 * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/7 3:22 */ @RestController @RequestMapping(value = \"${rest.path.api.v1}/channel\") public class ChannelControllerV1 { @Reference(version = DubboVersionConstant.DUBBO_VERSION_GAMING_SERVER_SERVICE_CHANNEL) private ChannelService channelService; /** * 获取全部频道 * * @return */ @ApiOperation(value = \"获取频道列表\", notes = \"获取全部频道列表\") @RequestMapping(value = \"data\", method = RequestMethod.GET) private List data() { return channelService.selectAll(); } } 文章控制器 package com.ooqiu.gaming.server.api.controller.v1; import com.alibaba.dubbo.config.annotation.Reference; import com.github.pagehelper.PageInfo; import com.ooqiu.gaming.server.domain.Article; import com.ooqiu.gaming.service.article.api.ArticleService; import com.ooqui.gaming.server.commons.constant.DubboVersionConstant; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiImplicitParams; import io.swagger.annotations.ApiOperation; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import java.util.List; /** * 文章接口 * Title: ArticleControllerV1 * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/7 3:22 */ @RestController @RequestMapping(value = \"${rest.path.api.v1}/article\") public class ArticleControllerV1 { @Reference(version = DubboVersionConstant.DUBBO_VERSION_GAMING_SERVER_SERVICE_ARTICLE) private ArticleService articleService; /** * 获取文章列表 * @param pageNum 页码 * @param pageSize 笔数 * @return */ @ApiOperation(value = \"获取文章列表\", notes = \"获取文章分页列表\") @ApiImplicitParams({ @ApiImplicitParam(name = \"pageNum\", value = \"页码\", required = true, dataType = \"int\", paramType = \"path\"), @ApiImplicitParam(name = \"pageSize\", value = \"笔数\", required = true, dataType = \"int\", paramType = \"path\") }) @RequestMapping(value = \"data/list/{pageNum}/{pageSize}\", method = RequestMethod.GET) public List data( @PathVariable(\"pageNum\") int pageNum, @PathVariable(\"pageSize\") int pageSize) { PageInfo pageInfo = articleService.selectAll(pageNum, pageSize); return pageInfo.getList(); } /** * 获取频道列表 * @param pageNum 页码 * @param pageSize 笔数 * @param channelId 频道 ID * @return */ @ApiOperation(value = \"获取文章列表\", notes = \"根据频道获取文章分页列表\") @ApiImplicitParams({ @ApiImplicitParam(name = \"pageNum\", value = \"页码\", required = true, dataType = \"int\", paramType = \"path\"), @ApiImplicitParam(name = \"pageSize\", value = \"笔数\", required = true, dataType = \"int\", paramType = \"path\"), @ApiImplicitParam(name = \"channelId\", value = \"频道 ID\", required = true, dataType = \"long\", paramType = \"path\") }) @RequestMapping(value = \"data/channel/{channelId}/{pageNum}/{pageSize}\", method = RequestMethod.GET) public List data( @PathVariable(value = \"pageNum\", required = true) int pageNum, @PathVariable(value = \"pageSize\", required = true) int pageSize, @PathVariable(value = \"channelId\", required = true) long channelId) { PageInfo pageInfo = articleService.selectByChannel(pageNum, pageSize, channelId); return pageInfo.getList(); } /** * 获取频道列表 * @param pageNum 页码 * @param pageSize 笔数 * @param type 文章类型 * @return */ @ApiOperation(value = \"获取文章列表\", notes = \"根据类型获取文章分页列表\") @ApiImplicitParams({ @ApiImplicitParam(name = \"pageNum\", value = \"页码\", required = true, dataType = \"int\", paramType = \"path\"), @ApiImplicitParam(name = \"pageSize\", value = \"笔数\", required = true, dataType = \"int\", paramType = \"path\"), @ApiImplicitParam(name = \"type\", value = \"文章类型\", required = true, dataType = \"String\", paramType = \"path\") }) @RequestMapping(value = \"data/type/{type}/{pageNum}/{pageSize}\", method = RequestMethod.GET) public List data( @PathVariable(value = \"pageNum\", required = true) int pageNum, @PathVariable(value = \"pageSize\", required = true) int pageSize, @PathVariable(value = \"type\", required = true) String type) { PageInfo pageInfo = articleService.selectByType(pageNum, pageSize, type); return pageInfo.getList(); } } 查看 API 文档 访问地址：http://localhost:8500/swagger-ui.html Swagger 注解说明 Swagger 通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息的等等。 @Api：修饰整个类，描述 Controller 的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiProperty：用对象接收参数时，描述对象的一个字段 @ApiResponse：HTTP 响应其中 1 个描述 @ApiResponses：HTTP 响应整体描述 @ApiIgnore：使用该注解忽略这个API @ApiError：发生错误返回的信息 @ApiImplicitParam：一个请求参数 @ApiImplicitParams：多个请求参数 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter18.html":{"url":"chapter18.html","title":"第18章 项目实战-客户端与服务端通信","keywords":"","body":"第十八章 客户端与服务端通信 服务端关键代码 客户端关键代码 解决跨域问题 SpringBoot 配置 CORS Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:18:36 "},"chapter18/服务端关键代码.html":{"url":"chapter18/服务端关键代码.html","title":"服务端关键代码","keywords":"","body":"服务端关键代码 项目名称 gaming-server-api 创建自定义响应结构 package com.ooqiu.gaming.server.api.dto; import lombok.Data; import java.io.Serializable; /** * 自定义数据返回结构体 * Title: BaseResult * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/8 14:33 */ @Data public class BaseResult implements Serializable { // 状态码 private int status; // 自定义消息 private String msg; // 请求的数据 private Object data; /** * 成功的请求 * * @param data * @return */ public static BaseResult success(Object data) { BaseResult baseResult = new BaseResult(); baseResult.setStatus(200); baseResult.setMsg(\"请求成功\"); baseResult.setData(data); return baseResult; } /** * 失败的请求 * @param status 状态码 * @param msg 消息 * @return */ public static BaseResult fail(int status, String msg) { BaseResult baseResult = new BaseResult(); baseResult.setStatus(status); baseResult.setMsg(msg); return baseResult; } } 控制器返回响应结构代码 /** * 获取全部频道 * @return */ @ApiOperation(value = \"获取频道列表\", notes = \"获取全部频道列表\") @RequestMapping(value = \"data\", method = RequestMethod.GET) public BaseResult data() { List data = Lists.newArrayList(); List channels = channelService.selectAll(); for (Channel channel : channels) { ChannelDTO dto = new ChannelDTO(); BeanUtils.copyProperties(channel, dto); data.add(dto); } return BaseResult.success(data); } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter18/客户端关键代码.html":{"url":"chapter18/客户端关键代码.html","title":"客户端关键代码","keywords":"","body":"客户端关键代码 封装数据结构 新建一个 result.js 文件 /** * 后台的数据结构 * @param {Object} status 状态码 * @param {Object} msg 消息 * @param {Object} data 数据 */ function BaseResult(status, msg, data) { var result = new Object(); result.status = status; result.msg = msg; result.data = data; return result; } /** * 频道 * @param {Object} data */ function Channel(data) { var channel = new Object(); // ID channel.id = data.id; // 频道名称 channel.name = data.name; return channel; } 封装 Ajax 请求 新建一个 utils.js 文件 var Utils = function() { // 主机地址 var HOST_URL = \"http://192.168.155.1:8500/\"; /** * Ajax 请求 - GET * @param {Object} url 请求地址 * @param {Object} params 请求参数 * @param {Function} callback 请求成功之后的回调函数 */ var handlerGetRequest = function(url, params, callback) { handlerAjaxRequest(\"get\", url, params, callback); } /** * Ajax 请求 - POST * @param {Object} url 请求地址 * @param {Object} params 请求参数 * @param {Function} callback 请求成功之后的回调函数 */ var handlerPostRequest = function(url, params, callback) { handlerAjaxRequest(\"post\", url, params, callback); } /** * Ajax 请求 * @param {Object} type 请求类型 * @param {Object} url 请求地址 * @param {Object} params 请求参数 * @param {Object} callback 成功后的回调函数 */ var handlerAjaxRequest = function(type, url, params, callback){ mui.ajax(HOST_URL + url, { data: params, dataType: 'json', //服务器返回json格式数据 type: type, //HTTP请求类型 timeout: 10000, //超时时间设置为10秒； headers: { 'Content-Type': 'application/json' }, success: function(data) { var status = data.status; var msg = data.msg; // 请求成功 if (status == 200) { callback(data); } // 请求失败 else { mui.toast(msg); } }, error: function(xhr, type, errorThrown) { // 异常处理 mui.toast(\"检测到您的网络有问题，请稍后再试...\"); } }); } return { getRequest: function(url, params, callback) { handlerGetRequest(url, params, callback); }, postRequest: function(url, params, callback) { handlerPostRequest(url, params, callback); } } }(); 调用 Ajax 请求的例子 Utils.getRequest(\"api/v1/channel/data\", null, function(data) { var result = BaseResult(data.status, data.msg, data.data); var channelArray = new Array(); mui.each(result.data, function(index, item) { var channel = Channel(item); channelArray.push(channel); }); console.log(channelArray.length); }); Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter18/解决跨域问题.html":{"url":"chapter18/解决跨域问题.html","title":"解决跨域问题","keywords":"","body":"解决跨域问题 跨域问题 在浏览器端进行 Ajax 请求时会出现跨域问题，那么什么是跨域，如何解决跨域呢？先看浏览器端出现跨域问题的现象，如下图所示 测试跨域问题的代码如下 测试 Ajax 请求 function ajaxRequest() { $.ajax({ type: \"get\", url: \"http://localhost:8500/api/v1/channel/data\", async: true, success: function(data) { console.log(data.status); } }); } 什么是跨域问题？ 跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 施加的安全限制。 什么是同源？ 所谓同源是指，域名，协议，端口均相同 http://www.lusifer.cc --> http://admin.lusifer.cc 跨域 http://www.lusifer.cc --> http://www.lusifer.cc 非跨域 http://www.lusifer.cc --> http://www.lusifer.cc:8080 跨域 http://www.lusifer.cc --> https://www.lusifer.cc 跨域 使用 CORS（跨资源共享）解决跨域问题 CORS 是一个 W3C 标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 CORS 简介 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信 与 JSONP 的比较 CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。 JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter18/SpringBoot配置CORS.html":{"url":"chapter18/SpringBoot配置CORS.html","title":"SpringBoot 配置 CORS","keywords":"","body":"SpringBoot 配置 CORS 使用 Java 配置的方式 package com.ooqiu.gaming.server.api.config; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; /** * 跨域配置 * Title: CorsConfiguration * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/8 22:56 */ @Configuration public class CORSConfiguration extends WebMvcConfigurerAdapter { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\").allowedOrigins(\"*\") .allowedMethods(\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\") .allowCredentials(false).maxAge(3600); } } 使用注解的方式 @CrossOrigin(origins = \"*\", maxAge = 3600) 解决跨域后的效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter19.html":{"url":"chapter19.html","title":"第19章 项目实战-Redis 为数据添加缓存","keywords":"","body":"Redis 为数据添加缓存 Redis 简介 Redis HA 方案 Redis Sentinel 集群部署 Redis 客户端与常用命令 Spring Boot 集成 Redis 创建 Redis 服务接口项目 创建 Redis 服务实现项目 Redis 实例案例 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:18:44 "},"chapter19/Redis简介.html":{"url":"chapter19/Redis简介.html","title":"Redis 简介","keywords":"","body":"Redis 简介 什么是 Redis Redis 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止 Redis 支持的键值数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型 Redis 的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 分布式集群架构中的 session 分离 聊天室的在线好友列表 任务队列（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒） Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter19/RedisHA方案.html":{"url":"chapter19/RedisHA方案.html","title":"Redis HA 方案","keywords":"","body":"Redis HA 方案 HA(High Available，高可用性群集)机集群系统简称，是保证业务连续性的有效解决方案，一般有两个或两个以上的节点，且分为活动节点及备用节点。通常把正在执 行业务的称为活动节点，而作为活动节点的一个备份的则称为备用节点。当活动节点出现问题，导致正在运行的业务（任务）不能正常运行时，备用节点此时就会侦测到，并立即接续活动节点来执行业务。从而实现业务的不中断或短暂中断。 Redis 一般以主/从方式部署（这里讨论的应用从实例主要用于备份，主实例提供读写）该方式要实现 HA 主要有如下几种方案： keepalived： 通过 keepalived 的虚拟 IP，提供主从的统一访问，在主出现问题时， 通过 keepalived 运行脚本将从提升为主，待主恢复后先同步后自动变为主，该方案的好处是主从切换后，应用程序不需要知道(因为访问的虚拟 IP 不变)，坏处是引入 keepalived 增加部署复杂性，在有些情况下会导致数据丢失 zookeeper： 通过 zookeeper 来监控主从实例， 维护最新有效的 IP， 应用通过 zookeeper 取得 IP，对 Redis 进行访问，该方案需要编写大量的监控代码 sentinel： 通过 Sentinel 监控主从实例，自动进行故障恢复，该方案有个缺陷：因为主从实例地址( IP & PORT )是不同的，当故障发生进行主从切换后，应用程序无法知道新地址，故在 Jedis2.2.2 中新增了对 Sentinel 的支持，应用通过 redis.clients.jedis.JedisSentinelPool.getResource() 取得的 Jedis 实例会及时更新到新的主实例地址 注意： sentinel 是解决 HA 问题的，cluster 是解决主从复制问题的，不重复，并且经常一起用 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter19/RedisSentinel集群部署.html":{"url":"chapter19/RedisSentinel集群部署.html","title":"Redis Sentinel 集群部署","keywords":"","body":"Redis Sentinel 集群部署 Redis Sentinel 是官方推荐的高可用性解决方案。它是 Redis 集群的监控管理工具，可以提供节点监控、通知、自动故障恢复和客户端配置发现服务。 创建工作目录 在 Linux 服务器上创建 /usr/local/docker/redis/sentinel 目录 说明： /usr/local/docker/redis：用于存放 docker-compose.yml 配置文件 /usr/local/docker/redis/sentinel：用于存放 Dockerfile 镜像配置文件 docker-compose.yml version: '3.1' services: master: image: redis:3 ports: - 6379:6379 slave: image: redis:3 ports: - 6380:6379 command: redis-server --slaveof redis-master 6379 links: - master:redis-master sentinel: build: sentinel ports: - 26379:26379 environment: - SENTINEL_DOWN_AFTER=5000 - SENTINEL_FAILOVER=5000 links: - master:redis-master - slave Dockerfile FROM redis:3 MAINTAINER Lusifer EXPOSE 26379 ADD sentinel.conf /etc/redis/sentinel.conf RUN chown redis:redis /etc/redis/sentinel.conf ENV SENTINEL_QUORUM 2 ENV SENTINEL_DOWN_AFTER 30000 ENV SENTINEL_FAILOVER 180000 COPY sentinel-entrypoint.sh /usr/local/bin/ RUN chmod +x /usr/local/bin/sentinel-entrypoint.sh ENTRYPOINT [\"sentinel-entrypoint.sh\"] sentinel.conf # Example sentinel.conf can be downloaded from http://download.redis.io/redis-stable/sentinel.conf port 26379 dir /tmp sentinel monitor mymaster redis-master 6379 $SENTINEL_QUORUM sentinel down-after-milliseconds mymaster $SENTINEL_DOWN_AFTER sentinel parallel-syncs mymaster 1 sentinel failover-timeout mymaster $SENTINEL_FAILOVER sentinel-entrypoint.sh #!/bin/sh sed -i \"s/\\$SENTINEL_QUORUM/$SENTINEL_QUORUM/g\" /etc/redis/sentinel.conf sed -i \"s/\\$SENTINEL_DOWN_AFTER/$SENTINEL_DOWN_AFTER/g\" /etc/redis/sentinel.conf sed -i \"s/\\$SENTINEL_FAILOVER/$SENTINEL_FAILOVER/g\" /etc/redis/sentinel.conf exec docker-entrypoint.sh redis-server /etc/redis/sentinel.conf --sentinel Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter19/Redis客户端与常用命令.html":{"url":"chapter19/Redis客户端与常用命令.html","title":"Redis 客户端与常用命令","keywords":"","body":"Redis 客户端与常用命令 桌面客户端 FastoRedis Redis Desktop Manager 常用命令 命令参考：http://doc.redisfans.com/ 连接命令 AUTH password：验证密码是否正确 ECHO message：打印字符串 PING：查看服务是否运行 QUIT：关闭当前连接 SELECT index：切换到指定的数据库 服务器命令 CLIENT LIST：获取连接到服务器的客户端连接列表 CLIENT KILL [ip:port] [ID client-id]：关闭客户端连接 TIME：返回当前服务器时间 CONFIG SET parameter value：修改 redis 配置参数，无需重启 DBSIZE：返回当前数据库的 key 的数量 DEBUG SEGFAULT：让 Redis 服务崩溃 FLUSHALL：删除所有数据库的所有 key FLUSHDB：删除当前数据库的所有 key INFO [section]：获取 Redis 服务器的各种信息和统计数值 LASTSAVE：返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示 MONITOR：实时打印出 Redis 服务器接收到的命令，调试用 keys 命令 EXISTS key：检查给定的 key 是否存在 TYPE key：返回 key 所存储的值的类型 字符串命令 SET key value GET key MGET KEY1 KEY2：获取一个或者多个给定 key 的值 MSET key value [key value ...]：同时设置一个或多个 key-value 对 APPEND key value：* 如果 key 已经存在并且是一个字符串， APPEND 命令将 指定value 追加到改 key 原来的值（value）的末尾 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter19/SpringBoot集成Redis.html":{"url":"chapter19/SpringBoot集成Redis.html","title":"Spring Boot 集成 Redis","keywords":"","body":"Spring Boot 集成 Redis 创建 Redis 服务接口项目 创建 Redis 服务实现项目 Redis 实例案例 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-05-23 12:18:44 "},"chapter19/SpringBoot集成Redis/创建Redis服务接口项目.html":{"url":"chapter19/SpringBoot集成Redis/创建Redis服务接口项目.html","title":"创建 Redis 服务接口项目","keywords":"","body":"创建 Redis 服务接口项目 项目名称 gaming-server-service-redis-api POM 4.0.0 com.ooqiu.gaming gaming-server-service-redis-api 1.0.0-SNAPSHOT jar gaming-server-service-redis-api 定义接口 package com.ooqiu.gaming.service.redis.api; /** * Redis 服务接口 * Title: RedisService * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/9 1:26 */ public interface RedisService { public Object get(String key); public void set(String key, Object value); /** * 带过期时间 * @param key * @param value * @param seconds 过期时间/秒 */ public void set(String key, Object value, long seconds); } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter19/SpringBoot集成Redis/创建Redis服务实现项目.html":{"url":"chapter19/SpringBoot集成Redis/创建Redis服务实现项目.html","title":"创建 Redis 服务实现项目","keywords":"","body":"创建 Redis 服务实现项目 项目名称 gaming-server-service-redis POM 增加 redis 依赖 org.springframework.boot spring-boot-starter-data-redis 完整 POM 4.0.0 com.ooqiu.gaming gaming-server-service-redis 1.0.0-SNAPSHOT jar gaming-server-service-redis com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT org.springframework.boot spring-boot-starter org.springframework.boot spring-boot-starter-data-redis org.springframework.boot spring-boot-starter-actuator org.springframework.boot spring-boot-starter-test test com.alibaba.boot dubbo-spring-boot-starter com.101tec zkclient com.ooqiu.gaming gaming-server-service-redis-api 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-commons 1.0.0-SNAPSHOT org.springframework.boot spring-boot-maven-plugin com.ooqiu.gaming.service.redis.GamingServerServiceRedisApplication 实现接口 package com.ooqiu.gaming.service.redis.api.impl; import com.alibaba.dubbo.config.annotation.Service; import com.ooqiu.gaming.service.redis.api.RedisService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import java.util.concurrent.TimeUnit; @Service(version = \"1.0.0\") public class RedisServiceImpl implements RedisService { @Autowired private RedisTemplate redisTemplate; @Override public Object get(String key) { return redisTemplate.opsForValue().get(key); } @Override public void set(String key, Object value) { redisTemplate.opsForValue().set(key, value); } @Override public void set(String key, Object value, long seconds) { redisTemplate.opsForValue().set(key, value, seconds, TimeUnit.SECONDS); } } Application package com.ooqiu.gaming.service.redis; import com.alibaba.dubbo.container.Main; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class GamingServerServiceRedisApplication { public static void main(String[] args) { SpringApplication.run(GamingServerServiceRedisApplication.class, args); Main.main(args); } } application.yml spring: application: name: gaming-server-service-redis redis: database: 0 # 单机使用，对应服务器ip host: 192.168.75.134 # 密码，如果没有设置可不配 # password: # 单机使用，对应端口号 port: 6379 # 池配置 pool: max-idle: 8 min-idle: 0 max-active: 8 max-wait: -1 # HA 环境，上生产时使用 # sentinel: # master: mymaster # 多个节点用“,”分割 # nodes: 192.168.75.134:26379 dubbo: scan: base-packages: com.ooqiu.gaming.service.redis.api application: id: gaming-server-service-redis name: gaming-server-service-redis protocol: id: dubbo name: dubbo registry: id: zookeeper address: zookeeper://192.168.75.132:2181?backup=192.168.75.132:2182,192.168.75.132:2183 application.properties dubbo.protocol.port=20883 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter19/SpringBoot集成Redis/Redis使用案例.html":{"url":"chapter19/SpringBoot集成Redis/Redis使用案例.html","title":"Redis 使用案例","keywords":"","body":"Redis 使用案例 为频道增加缓存功能 项目名称 gaming-server-service-channel 增加依赖 com.ooqiu.gaming gaming-server-service-redis-api 1.0.0-SNAPSHOT 关键代码 @Reference(version = DubboVersionConstant.DUBBO_VERSION_GAMING_SERVER_SERVICE_REDIS) private RedisService redisService; @Override public List selectAll() { try { // 查询缓存 String json = (String) redisService.get(\"channelList\"); if (StringUtils.isNotBlank(json)) { return MapperUtils.json2list(json, Channel.class); } // 没有缓存数据则查询数据库 else { List list = channelMapper.selectAll(); redisService.set(\"channelList\", MapperUtils.obj2json(list), 3600); return list; } } catch (Exception e) { return null; } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20.html":{"url":"chapter20.html","title":"第20章 项目实战-Solr 全文搜索引擎","keywords":"","body":"第二十章 项目实战-Solr 全文搜索引擎 Solr 简介 Solr 基础 Solr 部署 Solr 分词 Solr 使用 Solr 功能界面 Solr 分析功能 Solr 维护功能 Solr 查询功能 Spring Boot 集成 Solr 创建 Solr 搜索接口项目 创建 Solr 搜索实现项目 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/Solr简介.html":{"url":"chapter20/Solr简介.html","title":"Solr 简介","keywords":"","body":"Solr 简介 Solr 是一个开源搜索平台，用于构建搜索应用程序。它建立在 Lucene (全文搜索引擎)之上。Solr 是企业级的，快速的和高度可扩展的。使用 Solr 构建的应用程序非常复杂，可提供高性能。 为了在 CNET 网络的公司网站上添加搜索功能，Yonik Seely 于 2004 年创建了 Solr。并在 2006 年 1 月，它成为 Apache 软件基金会下的一个开源项目。并于2016年发布最新版本 Solr 6.0，支持并行SQL查询的执行。 Solr 可以和 Hadoop 一起使用。由于 Hadoop 处理大量数据，Solr 帮助我们从这么大的源中找到所需的信息。不仅限于搜索，Solr 也可以用于存储目的。像其他 NoSQL 数据库一样，它是一种非关系数据存储和处理技术。 总之，Solr 是一个可扩展的，可部署，搜索/存储引擎，优化搜索大量以文本为中心的数据。 Apache Solr 特点 Solr 是 Lucene 的 Java API 的包装。因此，使用 Solr，可以利用 Lucene 的所有功能。 Restful APIs − 要与 Solr 通信，并非一定需要有 Java 编程技能。相反，您可以使用 RESTful 服务与它通信。可使用文件格式(如XML，JSON和.CSV)在 Solr 中作为输入文档，并以相同的文件格式获取结果。 全文搜索 - Solr 提供了全文搜索所需的所有功能，例如令牌，短语，拼写检查，通配符和自动完成。 企业准备 - 根据企业/组织的需要，Solr 可以部署在任何类型的系统(大或小)，如独立，分布式，云等。 灵活和可扩展 - 通过扩展 Java 类并相应配置，可以轻松地定制 Solr 的组件。 NoSQL数据库 - Solr 也可以用作大数据量级的 NOSQL 数据库，可以沿着集群分布搜索任务。 管理界面 - Solr 提供了一个易于使用，用户友好，功能强大的用户界面，使用它可以执行所有可能的任务，如管理日志，添加，删除，更新和搜索文档。 高度可扩展 - 在使用 Solr 与 Hadoop 时，我们可以通过添加副本来扩展其容量。 以文本为中心并按相关性排序 - Solr 主要用于搜索文本文档，结果根据与用户查询的相关性按顺序传送。 与 Lucene 不同，在使用 Apache Solr 时，可不需要具有 Java 编程技能。它提供了一个完整的准备部署服务，以构建一个自动完成的搜索框，Lucene 是不提供的。 使用 Solr 可以扩展，分配和管理大规模(大数据)应用程序的索引。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/Solr基础.html":{"url":"chapter20/Solr基础.html","title":"Solr 基础","keywords":"","body":"Solr 基础 搜索引擎是指一个庞大的互联网资源数据库，如网页，新闻组，程序，图像等。它有助于在万维网上定位信息。用户可以通过以关键字或短语的形式将查询传递到搜索引擎中来搜索信息。然后搜索引擎搜索其数据库并向用户返回相关链接。 搜索引擎组件 一般来说，搜索引擎有三个基本组件 Web爬虫 - Web爬虫也称为蜘蛛或机器人。 它是一个收集网络信息的软件组件。 数据库 - Web上的所有信息都存储在数据库中。它们包含大量的Web资源。 搜索接口 - 此组件是用户和数据库之间的接口。它帮助用户搜索数据库。 搜索引擎是如何工作的？ 任何搜索应用程序都需要执行以下一些或全部操作 步骤 标题或名称 描述 1 获取原始内容 任何搜索应用程序的第一步是收集要进行搜索的目标内容 2 构建文档 从原始内容构建文档，让搜索应用程序可以很容易地理解和解释 3 分析文档 在索引开始之前，将对文档进行分析 4 索引文档 当文档被构建和分析后，下一步是对它们建立索引，以便可以基于特定键而不是文档的全部内容来检索该文档。索引类似于在书开始页或末尾处的目录索引，其中常见单词以其页码显示，使得这些单词可以快速跟踪，而不是搜索整本书 5 用于搜索的用户接口 当索引数据库就绪，应用程序可以执行搜索操作。 为了帮助用户进行搜索，应用必须提供用户接口，用户可以在其中输入文本并启动搜索过程 6 构建查询 当用户做出搜索文本的请求，应用程序应该使用该文本来准备查询对象，然后可以使用该查询对象来查询索引数据库以获得相关的细节 7 搜索查询 使用查询对象，检查索引数据库以获取相关详细信息和内容文档 8 渲染结果 当收到所需的结果，应用程序应决定如何使用其用户界面向用户显示结果 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/Solr部署.html":{"url":"chapter20/Solr部署.html","title":"Solr 部署","keywords":"","body":"Solr 部署 docker-compose.yml version: '3.1' services: solr: image: solr restart: always container_name: solr ports: - 8983:8983 部署成功效果图 访问地址：http://192.168.75.135:8983/ Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/Solr分词.html":{"url":"chapter20/Solr分词.html","title":"Solr 分词","keywords":"","body":"Solr 分词 什么是分词技术？ 分词技术就是搜索引擎针对用户提交查询的关键词串进行的查询处理后根据用户的关键词串用各种匹配方法进行分词的一种技术。 中文分词算法分类 基于字符串匹配 基于字符串匹配，即扫描字符串，如果发现字符串的子串和词相同，就算匹配，这类分词通常会加入一些启发式规则，比如“正向/反向最大匹配”,“长词优先”等策略，这类算法优点是速度块，都是O(n)时间复杂度，实现简单，效果尚可。缺点，就是对歧义和未登录词处理不好 歧义的列子：歧义的例子很简单\"长春市/长春/药店\" \"长春/市长/春药/店\" 未登录：即词典中没有出现的词，当然也就处理不好 ikanalyzer, paoding 等就是基于字符串匹配的分词 基于统计以及机器学习的分词方式 这类分词基于人工标注的词性和统计特征，对中文进行建模，即根据观测到的数据（标注好的语料）对模型参数进行估计，即训练。在分词阶段再通过模型计算各种分词出现的概率，将概率最大的分词结果作为最终结果。常见的序列标注模型有 HMM 和 CRF。 这类分词算法能很好处理歧义和未登录词问题，效果比前一类效果好，但是需要大量的人工标注数据，以及较慢的分词速度。 IKAnalyzer 简介 IKAnalyzer 是一个开源的，基于 java 语言开发的轻量级的中文分词工具包，基于文本匹配，不需要投入大量人力进行训练和标注可以自定词典，方便加入特定领域的词语，能分出多粒度的结果 部署 Solr 并安装 IKAnalyzer 创建工作目录 在 Linux 服务器上创建 /usr/local/docker/solr/ikanalyzer 目录 说明： /usr/local/docker/solr：用于存放 docker-compose.yml 配置文件 /usr/local/docker/solr/ikanalyzer：用于存放 Dockerfile 镜像配置文件 docker-compose.yml version: '3.1' services: solr: build: ikanalyzer restart: always container_name: solr ports: - 8983:8983 volumes: - /usr/local/docker/solr/solrdata:/opt/solrdata Dockerfile FROM solr MAINTAINER Lusifer # 创建 Core WORKDIR /opt/solr/server/solr RUN mkdir ik_core WORKDIR /opt/solr/server/solr/ik_core RUN echo 'name=ik_core' > core.properties RUN mkdir data RUN cp -r ../configsets/sample_techproducts_configs/conf/ . # 安装中文分词 WORKDIR /opt/solr/server/solr-webapp/webapp/WEB-INF/lib ADD ik-analyzer-solr5-5.x.jar . ADD solr-analyzer-ik-5.1.0.jar . WORKDIR /opt/solr/server/solr-webapp/webapp/WEB-INF ADD ext.dic . ADD stopword.dic . ADD IKAnalyzer.cfg.xml . # 增加分词配置 COPY managed-schema /opt/solr/server/solr/ik_core/conf WORKDIR /opt/solr 部署成功效果图 访问地址：http://192.168.75.135:8983/ Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/Solr使用.html":{"url":"chapter20/Solr使用.html","title":"Solr 使用","keywords":"","body":"Solr 使用 Solr 功能界面 Solr 分析功能 Solr 维护功能 Solr 查询功能 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/Solr使用/Solr功能界面.html":{"url":"chapter20/Solr使用/Solr功能界面.html","title":"Solr 功能界面","keywords":"","body":"Solr 功能界面 Dashboard Logging Core Admin Thread Dump Core Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/Solr使用/Solr分析功能.html":{"url":"chapter20/Solr使用/Solr分析功能.html","title":"Solr 分析功能","keywords":"","body":"Solr 分析功能 修改 managed-schema 配置业务系统字段 需要用到的业务字段如下： 文章 ID 文章来源 文章标题 文章简介 文章链接 文章图片 由于 Solr 中自带 id 字段所以无需添加，其它字段需要手动添加 Solr 字段 # 字段域 # 复制域（Solr 的搜索优化功能，将多个字段域复制到一个域里，提高查询效率） 复制配置到容器并重启 # 复制到容器 docker cp managed-schema solr:/opt/solr/server/solr/ik_core/conf # 重启容器 docker-compose restart 分词效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/Solr使用/Solr维护功能.html":{"url":"chapter20/Solr使用/Solr维护功能.html","title":"Solr 维护功能","keywords":"","body":"Solr 维护功能 维护功能即对数据库的 CRUD 操作 添加索引库 {\"id\":152034732415540, \"article_source\":\"我的头条\", \"article_title\":\"《H1Z1》在Steam正式发行后突遭大量差评 锁IP旧事再被提起\"} 测试查询 删除索引库 设置文档类型为 XML 根据 ID 删除 152034732415540 根据查询删除 *:* Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/Solr使用/Solr查询功能.html":{"url":"chapter20/Solr使用/Solr查询功能.html","title":"Solr 查询功能","keywords":"","body":"Solr 查询功能 查询条件 说明： q：查询条件，*:* 为查询所有域，单独查询某个域如：article_title:h1z1 fq: 过滤条件 sort：排序条件 start,rows：分页条件 fl：字段列表返回域，如只希望返回 id df：默认搜索域，如之前配置的复制域 article_keywords 高亮显示 说明：上图意为在默认搜索域 article_keywords 中搜索关键字 正式 并指定需要高亮显示的结果域 article_title 以 红色 显示 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/SpringBoot集成Solr.html":{"url":"chapter20/SpringBoot集成Solr.html","title":"Spring Boot 集成 Solr","keywords":"","body":"Spring Boot 集成 Solr 创建 Solr 搜索接口项目 创建 Solr 搜索实现项目 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/SpringBoot集成Solr/创建Solr搜索接口项目.html":{"url":"chapter20/SpringBoot集成Solr/创建Solr搜索接口项目.html","title":"创建 Solr 搜索接口项目","keywords":"","body":"创建 Solr 搜索接口项目 项目名称 gaming-server-service-search-api POM 4.0.0 com.ooqiu.gaming gaming-server-service-search-api 1.0.0-SNAPSHOT jar gaming-server-service-search-api com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-domain 1.0.0-SNAPSHOT Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/SpringBoot集成Solr/创建Solr搜索实现项目.html":{"url":"chapter20/SpringBoot集成Solr/创建Solr搜索实现项目.html","title":"创建 Solr 搜索实现项目","keywords":"","body":"创建 Solr 搜索实现项目 项目名称 gaming-server-service-search POM 增加 Solr 依赖 org.springframework.boot spring-boot-starter-data-solr 完整 POM 4.0.0 com.ooqiu.gaming gaming-server-service-search 1.0.0-SNAPSHOT jar gaming-server-service-search com.ooqiu.gaming gaming-server-dependencies 1.0.0-SNAPSHOT org.springframework.boot spring-boot-starter org.springframework.boot spring-boot-starter-data-solr org.springframework.boot spring-boot-starter-actuator org.springframework.boot spring-boot-starter-test test com.alibaba druid-spring-boot-starter tk.mybatis mapper-spring-boot-starter mysql mysql-connector-java com.alibaba.boot dubbo-spring-boot-starter com.101tec zkclient com.ooqiu.gaming gaming-server-service-search-api 1.0.0-SNAPSHOT com.ooqiu.gaming gaming-server-commons 1.0.0-SNAPSHOT org.springframework.boot spring-boot-maven-plugin com.ooqiu.gaming.service. Application package com.ooqiu.gaming.service.search; import com.alibaba.dubbo.container.Main; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(basePackages = \"com.ooqiu.gaming.service.search.mapper\") public class GamingServerServiceSearchApplication { public static void main(String[] args) { SpringApplication.run(GamingServerServiceSearchApplication.class, args); Main.main(args); } } application.yml spring: application: name: gaming-server-service-search data: solr: host: http://192.168.75.135:8983/solr datasource: druid: url: jdbc:mysql://192.168.75.132:3306/toutiao?useUnicode=true&characterEncoding=utf-8&useSSL=false username: root password: 123456 initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true driver-class-name: com.mysql.jdbc.Driver dubbo: scan: base-packages: com.ooqiu.gaming.service.search.api application: id: gaming-server-service-search name: gaming-server-service-search protocol: id: dubbo name: dubbo registry: id: zookeeper address: zookeeper://192.168.75.132:2181?backup=192.168.75.132:2182,192.168.75.132:2183 application.properties dubbo.protocol.port=20884 Solr 测试类 主要用于初始化索引库 package com.ooqiu.gaming.service.search.test; import com.ooqiu.gaming.server.domain.Article; import com.ooqiu.gaming.service.search.mapper.ArticleMapper; import org.apache.solr.client.solrj.SolrClient; import org.apache.solr.client.solrj.SolrQuery; import org.apache.solr.client.solrj.SolrServerException; import org.apache.solr.client.solrj.response.QueryResponse; import org.apache.solr.common.SolrDocument; import org.apache.solr.common.SolrDocumentList; import org.apache.solr.common.SolrInputDocument; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import java.io.IOException; import java.util.List; import java.util.Map; @SpringBootTest @RunWith(SpringRunner.class) public class SolrTest { @Autowired private SolrClient solrClient; @Autowired private ArticleMapper articleMapper; /** * 添加索引库 */ @Test public void addDocument() throws IOException, SolrServerException { // 创建文档对象 SolrInputDocument document = new SolrInputDocument(); // 向文档中添加域 document.addField(\"id\", 152034783404107L); document.addField(\"article_title\", \"腾讯游戏安全中心：《绝地求生》《H1Z1》外挂举报已收到 静待国服上线\"); // 将文档添加到索引库 solrClient.add(document); // 提交 solrClient.commit(\"ik_core\"); } /** * 删除索引库 */ @Test public void delDocument() throws IOException, SolrServerException { solrClient.deleteByQuery(\"*:*\"); solrClient.commit(\"ik_core\"); } /** * 初始化索引库 */ @Test public void initDocument() throws IOException, SolrServerException { List articles = articleMapper.selectAll(); for (Article article : articles) { SolrInputDocument document = new SolrInputDocument(); document.addField(\"id\", article.getId()); document.addField(\"article_title\", article.getTitle()); document.addField(\"article_source\", article.getSource()); document.addField(\"article_introduction\", article.getIntroduction()); document.addField(\"article_url\", article.getUrl()); document.addField(\"article_cover\", article.getCover()); solrClient.add(document); solrClient.commit(\"ik_core\"); } } /** * 查询索引库 */ @Test public void queryDocument() throws IOException, SolrServerException { // 创建查询对象 SolrQuery query = new SolrQuery(); // 设置查询条件 query.setQuery(\"演示\"); // 设置分页 query.setStart(0); query.setRows(10); // 设置默认搜索域 query.set(\"df\", \"article_keywords\"); // 设置高亮显示 query.setHighlight(true); query.addHighlightField(\"article_title\"); query.setHighlightSimplePre(\"\"); query.setHighlightSimplePost(\"\"); // 执行查询操作 QueryResponse queryResponse = solrClient.query(\"ik_core\", query); // 查询结果集 SolrDocumentList results = queryResponse.getResults(); // 获取高亮显示 Map>> highlighting = queryResponse.getHighlighting(); // 遍历结果集 for (SolrDocument result : results) { String articleTitle = \"\"; // 获取高亮显示 List list = highlighting.get(result.get(\"id\")).get(\"article_title\"); if (list != null && list.size() > 0) { articleTitle = list.get(0); } else { articleTitle = (String) result.get(\"article_title\"); } System.out.println(articleTitle); } } } 实现接口 package com.ooqiu.gaming.service.search.api.impl; import com.alibaba.dubbo.config.annotation.Service; import com.google.common.collect.Lists; import com.ooqiu.gaming.service.search.api.SearchService; import com.ooqiu.gaming.service.search.domain.SearchResult; import org.apache.solr.client.solrj.SolrClient; import org.apache.solr.client.solrj.SolrQuery; import org.apache.solr.client.solrj.SolrServerException; import org.apache.solr.client.solrj.response.QueryResponse; import org.apache.solr.common.SolrDocument; import org.apache.solr.common.SolrDocumentList; import org.springframework.beans.factory.annotation.Autowired; import java.io.IOException; import java.util.List; import java.util.Map; @Service(version = DubboVersionConstant.DUBBO_VERSION_GAMING_SERVER_SERVICE_SEARCH) public class SearchServiceImpl implements SearchService { @Autowired private SolrClient solrClient; @Override public List search(String queryString, int page, int rows) { List searchResults = Lists.newArrayList(); // 创建查询对象 SolrQuery query = new SolrQuery(); // 设置查询条件 query.setQuery(queryString); // 设置分页条件 query.setStart((page - 1) * rows); query.setRows(rows); // 设置默认搜索域 query.set(\"df\", \"article_keywords\"); // 设置高亮显示 query.setHighlight(true); query.addHighlightField(\"article_title\"); query.setHighlightSimplePre(\"\"); query.setHighlightSimplePost(\"\"); try { // 执行查询操作 QueryResponse queryResponse = solrClient.query(\"ik_core\", query); SolrDocumentList solrDocuments = queryResponse.getResults(); Map>> highlighting = queryResponse.getHighlighting(); for (SolrDocument solrDocument : solrDocuments) { SearchResult result = new SearchResult(); result.setId((String) solrDocument.get(\"id\")); result.setArticle_cover((String) solrDocument.get(\"article_cover\")); result.setArticle_introduction((String) solrDocument.get(\"article_introduction\")); result.setArticle_source((String) solrDocument.get(\"article_source\")); result.setArticle_url((String) solrDocument.get(\"article_url\")); String articleTile = \"\"; List list = highlighting.get(solrDocument.get(\"id\")).get(\"article_title\"); if (list != null && list.size() > 0) { articleTile = list.get(0); } else { articleTile = (String) solrDocument.get(\"article_title\"); } result.setArticle_title(articleTile); searchResults.add(result); } } catch (SolrServerException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return searchResults; } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter20/SpringBoot集成Solr/API网关中增加搜索功能.html":{"url":"chapter20/SpringBoot集成Solr/API网关中增加搜索功能.html","title":"API 网关中增加搜索功能","keywords":"","body":"API 网关中增加搜索功能 增加依赖 com.ooqiu.gaming gaming-server-service-search-api 1.0.0-SNAPSHOT 控制器代码 package com.ooqiu.gaming.server.api.controller.v1; import com.alibaba.dubbo.config.annotation.Reference; import com.ooqiu.gaming.server.api.dto.BaseResult; import com.ooqiu.gaming.service.search.api.SearchService; import com.ooqiu.gaming.service.search.domain.SearchResult; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiOperation; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import java.util.List; /** * 搜索 * Title: SearchControllerV1 * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/3/13 8:02 */ @RestController @RequestMapping(value = \"${rest.path.api.v1}/search\") public class SearchControllerV1 { @Reference(version = DubboVersionConstant.DUBBO_VERSION_GAMING_SERVER_SERVICE_SEARCH) private SearchService searchService; /** * 搜索 * @param query * @return */ @ApiOperation(value = \"搜索\", notes = \"搜索\") @ApiImplicitParam(name = \"query\", value = \"关键字\", required = true, dataType = \"String\", paramType = \"path\") @RequestMapping(value = \"{query}\", method = RequestMethod.GET) public BaseResult search(@PathVariable(required = true) String query) { List searchResults = searchService.search(query, 1, 10); return BaseResult.success(searchResults); } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter21.html":{"url":"chapter21.html","title":"第21章 项目部署与负载均衡","keywords":"","body":"第二十一章 项目部署与负载均衡 项目部署 Spring Boot 启用 Profile Docker 私服搭建 项目的容器化部署 Nginx 负载均衡 Nginx 简介 Nginx 部署 Nginx 虚拟主机 Nginx 反向代理 Nginx 负载均衡 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter21/项目部署.html":{"url":"chapter21/项目部署.html","title":"项目部署","keywords":"","body":"项目部署 Spring Boot 启用 Profile Docker 私服搭建 项目的容器化部署 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter21/项目部署/SpringBoot启用Profile.html":{"url":"chapter21/项目部署/SpringBoot启用Profile.html","title":"Spring Boot 启用 Profile","keywords":"","body":"Spring Boot 启用 Profile 在实际开发中，生产环境与测试环境的配置不同，我们需要在上线时手动修改相关的配置信息。但 Spring 为我们提供了 Profile 功能，我们只需要在项目启动时添加一个虚拟机参数，激活对应的 Profile 环境即可 创建不同环境的配置文件 开发环境配置 application-dev.yml 生产环境配置 application-prod.yml 启动命令 增加 JVM 参数 --spring.profiles.active=dev java -jar gaming-server-api-1.0.0-SNAPSHOT.jar --spring.profiles.active=dev 启动效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter21/项目部署/Docker私服搭建.html":{"url":"chapter21/项目部署/Docker私服搭建.html","title":"Docker 私服搭建","keywords":"","body":"Docker 私服搭建 简介 官方的 Docker Hub 是一个用于管理公共镜像的地方，我们可以在上面找到我们想要的镜像，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么你就需要 Docker Registry，它可以用来存储和管理自己的镜像。 服务端 docker-compose.yml version: '3.1' services: registry: image: registry restart: always container_name: registry ports: - 5000:5000 volumes: - /usr/local/docker/registry/data:/var/lib/registry 测试服务端 浏览器访问：http://192.168.75.136:5000/v2/ 终端访问：curl http://192.168.75.136:5000/v2/ 客户端 修改配置文件 vi /lib/systemd/system/docker.service 增加配置属性 --insecure-registry 192.168.75.136:5000 重启服务 systemctl daemon-reload service docker restart 测试镜像上传 ## 拉取一个镜像 docker pull nginx ## 查看全部镜像 docker images ## 标记本地镜像并指向目标仓库（ip:port/image_name:tag，该格式为标记版本号） docker tag nginx 192.168.75.136:5000/nginx ## 提交镜像到仓库 docker push 192.168.75.136:5000/nginx 查看私服镜像 查看全部镜像 curl -XGET http://192.168.75.136:5000/v2/_catalog 查看指定镜像 curl -XGET http://192.168.75.136:5000/v2/nginx/tags/list 测试拉取私服镜像 先删除镜像 docker rmi nginx docker rmi 192.168.75.136:5000/nginx 拉取镜像 docker pull 192.168.75.136:5000/nginx Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter21/项目部署/项目的容器化部署.html":{"url":"chapter21/项目部署/项目的容器化部署.html","title":"项目的容器化部署","keywords":"","body":"项目的容器化部署 本地运行 本地运行很简单我们使用 java -jar 命令即可 容器化部署流程 为每个需要部署的项目配置 Dockerfile 将 Dockerfile 和打包好的 Jar 文件上传至打包服务器 基于 Dockerfile 将 Jar 文件打包进镜像 将打包的镜像上传至私服 在生产环境中拉取私服上最新的服务镜像 启动镜像容器 Dockerfile 配置案例 此处以项目 gaming-server-service-redis 为例，在项目根目录创建 docker/Dockerfile 文件 FROM openjdk:8-jre MAINTAINER Lusifer ENV APP_VERSION 1.0.0-SNAPSHOT ENV DOCKERIZE_VERSION v0.6.0 RUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ && tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ && rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz RUN mkdir /app WORKDIR /app COPY gaming-server-service-redis-$APP_VERSION.jar /app/app.jar ENTRYPOINT [\"dockerize\", \"-timeout\", \"5m\", \"-wait\", \"tcp://192.168.75.134:6379\", \"java\", \"-Djava.security.egd=file:/dev/./urandom\", \"-jar\", \"/app/app.jar\"] EXPOSE 20883 注：dockerize 是一个小工具，可用于在启动容器之前等待其他需要先行启动的服务 构建 Docker 镜像 docker build -t 192.168.75.136:5000/gaming-server-service-redis:latest . 上传镜像到私服 docker push 192.168.75.136:5000/gaming-server-service-redis 拉取镜像并启动容器 version: '3.1' services: gaming-server-service-redis: image: 192.168.75.136:5000/gaming-server-service-redis restart: always container_name: gaming-server-service-redis ports: - 20883:20883 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter21/Nginx.html":{"url":"chapter21/Nginx.html","title":"Nginx","keywords":"","body":"Nginx 负载均衡 Nginx 简介 Nginx 部署 Nginx 虚拟主机 Nginx 反向代理 Nginx 负载均衡 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter21/Nginx负载均衡/Nginx简介.html":{"url":"chapter21/Nginx负载均衡/Nginx简介.html","title":"Nginx 简介","keywords":"","body":"Nginx 简介 什么是 Nginx Nginx 是一款高性能的 HTTP 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师 Igor Sysoev 所开发，官方测试 Nginx 能够支支撑5万并发链接，并且 CPU、内存等资源消耗却非常低，运行非常稳定。 Nginx 的应用场景 HTTP 服务器：Nginx 是一个 HTTP 服务可以独立提供 HTTP 服务。可以做网页静态服务器。 虚拟主机：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 Nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter21/Nginx负载均衡/Nginx部署.html":{"url":"chapter21/Nginx负载均衡/Nginx部署.html","title":"Nginx 部署","keywords":"","body":"Nginx 部署 docker-compose.yml version: '3.1' services: nginx: restart: always image: nginx container_name: nginx ports: - 80:80 volumes: - /usr/local/docker/nginx/default.conf:/etc/nginx/conf.d/default.conf - /usr/local/docker/nginx/nginx.conf:/etc/nginx/nginx.conf - /usr/local/docker/nginx/html:/usr/share/nginx Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter21/Nginx负载均衡/Nginx虚拟主机.html":{"url":"chapter21/Nginx负载均衡/Nginx虚拟主机.html","title":"Nginx 虚拟主机","keywords":"","body":"Nginx 虚拟主机 什么是虚拟主机 Nginx 配置文件的结构 基于 IP 的虚拟主机配置 基于端口的虚拟主机配置 基于域名的虚拟主机配置 什么是虚拟主机 虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供 www 服务，这样就可以实现一台主机对外提供多个 web 服务，每个虚拟主机之间是独立的，互不影响的。 通过 Nginx 可以实现虚拟主机的配置，Nginx 支持三种类型的虚拟主机配置 基于 IP 的虚拟主机 基于域名的虚拟主机 基于端口的虚拟主机 Nginx 配置文件的结构 # ... events { # ... } http { # ... server{ # ... } # ... server{ # ... } } 注：每个 server 就是一个虚拟主机 基于 IP 的虚拟主机配置 Linux 操作系统允许添加 IP 别名，IP 别名就是在一块物理网卡上绑定多个 lP 地址。这样就能够在使用单一网卡的同一个服务器上运行多个基于 IP 的虚拟主机。 需求 一台 Nginx 服务器绑定两个 IP：192.168.75.145、192.168.75.245 访问不同的 IP 请求不同的 HTML 目录，即： 访问 http://192.168.75.145 将访问 html145 目录下的 html 网页 访问 http://192.168.75.245 将访问 html245 目录下的 html 网页 创建目录及文件 在 /usr/local/docker/nginx/html 目录下创建 html145 和 html245 两个目录，并分辨创建两个 index.html 文件 绑定多 IP ifconfig ens33:0 192.168.75.245 broadcast 192.168.75.255 netmask 255.255.255.0 配置虚拟主机 修改 /usr/local/docker/nginx 目录下的 nginx.conf 配置文件： worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 配置虚拟主机 192.168.75.145 server { # 监听的ip和端口，配置 192.168.75.145:80 listen 80; # 虚拟主机名称这里配置ip地址 server_name 192.168.75.145; # 所有的请求都以/开始，所有的请求都可以匹配此 location location / { # 使用 root 指令指定虚拟主机目录即网页存放目录 # 比如访问 http://ip/index.html 将找到 /usr/local/docker/nginx/html/html145/index.html # 比如访问 http://ip/item/index.html 将找到 /usr/local/docker/nginx/html/html145/item/index.html root /usr/share/nginx/html145; # 指定欢迎页面，按从左到右顺序查找 index index.html index.htm; } } # 配置虚拟主机 192.168.75.245 server { listen 80; server_name 192.168.75.245; location / { root /usr/share/nginx/html245; index index.html index.htm; } } } 基于端口的虚拟主机配置 需求 Nginx 对外提供 80 和 8080 两个端口监听服务 请求 80 端口则请求 html80 目录下的 html 请求 8080 端口则请求 html8080 目录下的 html 创建目录及文件 在 /usr/local/docker/nginx/html 目录下创建 html80 和 html8080 两个目录，并分辨创建两个 index.html 文件 配置虚拟主机 修改 /usr/local/docker/nginx 目录下的 nginx.conf 配置文件： worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 配置虚拟主机 192.168.75.145 server { # 监听的ip和端口，配置 192.168.75.145:80 listen 80; # 虚拟主机名称这里配置ip地址 server_name 192.168.75.145; # 所有的请求都以/开始，所有的请求都可以匹配此 location location / { # 使用 root 指令指定虚拟主机目录即网页存放目录 # 比如访问 http://ip/index.html 将找到 /usr/local/docker/nginx/html/html145/index.html # 比如访问 http://ip/item/index.html 将找到 /usr/local/docker/nginx/html/html145/item/index.html root /usr/share/nginx/html80; # 指定欢迎页面，按从左到右顺序查找 index index.html index.htm; } } # 配置虚拟主机 192.168.75.245 server { listen 8080; server_name 192.168.75.245; location / { root /usr/share/nginx/html8080; index index.html index.htm; } } } 注意： 别忘记将容器的 8080 端口映射到宿主机，否则无法访问 8080 端口 基于域名的虚拟主机配置 需求 两个域名指向同一台 Nginx 服务器，用户访问不同的域名显示不同的网页内容 两个域名是 admin.ooqiu.com 和 service.ooqiu.com Nginx 服务器使用虚拟机 192.168.75.145 配置 Windows Hosts 文件 通过 host 文件指定 admin.ooqiu.com 和 service.ooqiu.com 对应 192.168.75.145 虚拟机： 修改 window 的 hosts 文件：（C:\\Windows\\System32\\drivers\\etc） 创建目录及文件 在 /usr/local/docker/nginx/html 目录下创建 htmladmin 和 htmlservice 两个目录，并分辨创建两个 index.html 文件 配置虚拟主机 user nginx; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name admin.ooqiu.com; location / { root /usr/share/nginx/htmladmin; index index.html index.htm; } } server { listen 80; server_name service.ooqiu.com; location / { root /usr/share/nginx/htmlservice; index index.html index.htm; } } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter21/Nginx负载均衡/Nginx反向代理.html":{"url":"chapter21/Nginx负载均衡/Nginx反向代理.html","title":"Nginx 反向代理","keywords":"","body":"Nginx 反向代理 什么是反向代理 通常的代理服务器，只用于代理内部网络对 Internet 的连接请求，客户机必须指定代理服务器,并将本来要直接发送到 Web 服务器上的 HTTP 请求发送到代理服务器中由代理服务器向 Internet 上的 Web 服务器发起请求，最终达到客户机上网的目的。 而反向代理（Reverse Proxy）方式是指以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 Nginx 反向代理 Tomcat 需求 两个 tomcat 服务通过 nginx 反向代理 nginx 服务器：192.168.75.145:80 tomcat1 服务器：192.168.75.145:9090 tomcat2 服务器：192.168.75.145:9091 启动 Tomcat 容器 启动两个 Tomcat 容器，映射端口为 9090 和 9091，docker-compose.yml 如下： version: '3' services: tomcat1: image: tomcat container_name: tomcat1 ports: - 9090:8080 tomcat2: image: tomcat container_name: tomcat2 ports: - 9091:8080 配置 Nginx 反向代理 修改 /usr/local/docker/nginx 目录下的 nginx.conf 配置文件： user nginx; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 配置一个代理即 tomcat1 服务器 upstream tomcat_server1 { server 192.168.75.145:9090; } # 配置一个代理即 tomcat2 服务器 upstream tomcat_server2 { server 192.168.75.145:9091; } # 配置一个虚拟主机 server { listen 80; server_name admin.ooqiu.com; location / { # 域名 admin.ooqiu.com 的请求全部转发到 tomcat_server1 即 tomcat1 服务上 proxy_pass http://tomcat_server1; # 欢迎页面，按照从左到右的顺序查找页面 index index.jsp index.html index.htm; } } server { listen 80; server_name service.ooqiu.com; location / { # 域名 service.ooqiu.com 的请求全部转发到 tomcat_server2 即 tomcat2 服务上 proxy_pass http://tomcat_server2; index index.jsp index.html index.htm; } } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter21/Nginx负载均衡/Nginx负载均衡.html":{"url":"chapter21/Nginx负载均衡/Nginx负载均衡.html","title":"Nginx 负载均衡","keywords":"","body":"Nginx 负载均衡配置 什么是负载均衡 负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 负载均衡，英文名称为 Load Balance，其意思就是分摊到多个操作单元上进行执行，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 Nginx 实现负载均衡 nginx 作为负载均衡服务器，用户请求先到达 nginx，再由 nginx 根据负载配置将请求转发至 tomcat 服务器 nginx 负载均衡服务器：192.168.75.145:80 tomcat1 服务器：192.168.75.145:9090 tomcat2 服务器：192.168.75.145:9091 Nginx 配置负载均衡 修改 /usr/local/docker/nginx 目录下的 nginx.conf 配置文件： user nginx; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream tomcat_server_pool{ server 192.168.75.145:9090 weight=10; server 192.168.75.145:9091 weight=10; } server { listen 80; server_name admin.ooqiu.com; location / { proxy_pass http://tomcat_server_pool; index index.jsp index.html index.htm; } } } 相关配置说明 # 定义负载均衡设备的 Ip及设备状态 upstream myServer { server 127.0.0.1:9090 down; server 127.0.0.1:8080 weight=2; server 127.0.0.1:6060; server 127.0.0.1:7070 backup; } 在需要使用负载的 Server 节点下添加 proxy_pass http://myServer; upstream：每个设备的状态: down：表示当前的 server 暂时不参与负载 weight：默认为 1.weight 越大，负载的权重就越大。 max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回 proxy_next_upstream 模块定义的错误 fail_timeout:max_fails 次失败后，暂停的时间。 backup：其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器。所以这台机器压力会最轻 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22.html":{"url":"chapter22.html","title":"第22章 持续集成与持续交付","keywords":"","body":"第二十二章 持续集成与持续交付 持续集成的基本概念 持续集成的操作流程 GitLab 持续集成 GitLab CI GitLab Runner 实战持续集成 持续集成的实现思路 Maven 私服搭建 Jenkins 持续交付 Jenkins 简介 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/持续集成的基本概念.html":{"url":"chapter22/持续集成的基本概念.html","title":"持续集成的基本概念","keywords":"","body":"持续集成的基本概念 互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）。 持续集成 持续集成指的是，频繁地（一天多次）将代码集成到主干。它的好处主要有两个： 快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。 Martin Fowler 说过，\"持续集成并不能消除 Bug，而是让它们非常容易发现和改正。\" 持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。 与持续集成相关的，还有两个概念，分别是持续交付和持续部署。 持续交付 持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。 持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。 持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。 持续部署 持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。 持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。 持续部署的前提是能自动化完成测试、构建、部署等步骤。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/持续集成的操作流程.html":{"url":"chapter22/持续集成的操作流程.html","title":"持续集成的操作流程","keywords":"","body":"持续集成的操作流程 根据持续集成的设计，代码从提交到生产，整个过程有以下几步。 提交 流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。 测试（第一轮） 代码仓库对 commit 操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。 测试的种类： 单元测试：针对函数或模块的测试 集成测试：针对整体产品的某个功能的测试，又称功能测试 端对端测试：从用户界面直达数据库的全链路测试 第一轮至少要跑单元测试。 构建 通过第一轮测试，代码就可以合并进主干，就算可以交付了。 交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。 常用的构建工具如下： Jenkins Travis Codeship Strider Jenkins 和 Strider 是开源软件，Travis 和 Codeship 对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。 测试（第二轮） 构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。 第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。 需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。 部署 通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。 生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有Ansible，Chef，Puppet等。 回滚 一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/GitLab持续集成.html":{"url":"chapter22/GitLab持续集成.html","title":"GitLab 持续集成","keywords":"","body":"GitLab 持续集成 GitLab CI GitLab Runner Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/GitLab持续集成/GitLabCI.html":{"url":"chapter22/GitLab持续集成/GitLabCI.html","title":"GitLab CI","keywords":"","body":"GitLab CI 简介 从 GitLab 8.0 开始，GitLab CI 就已经集成在 GitLab 中，我们只要在项目中添加一个 .gitlab-ci.yml 文件，然后添加一个 Runner，即可进行持续集成。 而且随着 GitLab 的升级，GitLab CI 变得越来越强大。 概念 Pipeline 一次 Pipeline 其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。 任何提交或者 Merge Request 的合并都可以触发 Pipeline，如下图所示： +------------------+ +----------------+ | | trigger | | | Commit / MR +---------->+ Pipeline | | | | | +------------------+ +----------------+ Stages Stages 表示构建阶段，说白了就是上面提到的流程。我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点： 所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始 只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功 如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败 因此，Stages 和 Pipeline 的关系就是： +--------------------------------------------------------+ | | | Pipeline | | | | +-----------+ +------------+ +------------+ | | | Stage 1 |---->| Stage 2 |----->| Stage 3 | | | +-----------+ +------------+ +------------+ | | | +--------------------------------------------------------+ Jobs Jobs 表示构建工作，表示某个 Stage 里面执行的工作。我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点： 相同 Stage 中的 Jobs 会并行执行 相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功 如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败 所以，Jobs 和 Stage 的关系图就是： +------------------------------------------+ | | | Stage 1 | | | | +---------+ +---------+ +---------+ | | | Job 1 | | Job 2 | | Job 3 | | | +---------+ +---------+ +---------+ | | | +------------------------------------------+ Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/GitLab持续集成/GitLabRunner.html":{"url":"chapter22/GitLab持续集成/GitLabRunner.html","title":"GitLab Runner","keywords":"","body":"GitLab Runner 简介 理解了上面的基本概念之后，有没有觉得少了些什么东西 —— 由谁来执行这些构建任务呢？ 答案就是 GitLab Runner 了！ 想问为什么不是 GitLab CI 来运行那些构建任务？ 一般来说，构建任务都会占用很多的系统资源 (譬如编译代码)，而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候，GitLab 的性能会大幅下降。 GitLab CI 最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 来做拉！ 因为 GitLab Runner 可以安装到不同的机器上，所以在构建任务运行期间并不会影响到 GitLab 的性能 安装 在目标主机上安装 GitLab Runner，这里的目标主机指你要部署的服务器 Ubuntu 安装脚本： curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bash sudo apt-get update sudo apt-get install gitlab-ci-multi-runner 注册 Runner 安装好 GitLab Runner 之后，我们只要启动 Runner 然后和 GitLab CI 绑定： [root@iZbp1fmnx8oyubksjdk7leZ gitbook]# gitlab-ci-multi-runner register Running in system-mode. Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/): http://192.168.75.146:8080/ Please enter the gitlab-ci token for this runner: 1Lxq_f1NRfCfeNbE5WRh Please enter the gitlab-ci description for this runner: [iZbp1fmnx8oyubksjdk7leZ]: deploy-gaming Please enter the gitlab-ci tags for this runner (comma separated): deploy Whether to run untagged builds [true/false]: [false]: true Whether to lock Runner to current project [true/false]: [false]: Registering runner... succeeded runner=P_zfkhTb Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh: shell Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 说明： gitlab-ci-multi-runner register：执行注册命令 Please enter the gitlab-ci coordinator URL：输入 ci 地址 Please enter the gitlab-ci token for this runner：输入 ci token Please enter the gitlab-ci description for this runner：输入 runner 名称 Please enter the gitlab-ci tags for this runner：设置 tag Whether to run untagged builds：这里选择 true ，代码上传后会能够直接执行 Whether to lock Runner to current project：直接回车，不用输入任何口令 Please enter the executor：选择 runner 类型，这里我们选择的是 shell CI 的地址和令牌，在 项目 --> 设置 --> CI/CD --> Runner 设置： .gitlab-ci.yml 在项目工程下编写 .gitlab-ci.yml 配置文件： stages: - install_deps - test - build - deploy_test - deploy_production cache: key: ${CI_BUILD_REF_NAME} paths: - node_modules/ - dist/ # 安装依赖 install_deps: stage: install_deps only: - develop - master script: - npm install # 运行测试用例 test: stage: test only: - develop - master script: - npm run test # 编译 build: stage: build only: - develop - master script: - npm run clean - npm run build:client - npm run build:server # 部署测试服务器 deploy_test: stage: deploy_test only: - develop script: - pm2 delete app || true - pm2 start app.js --name app # 部署生产服务器 deploy_production: stage: deploy_production only: - master script: - bash scripts/deploy/deploy.sh 上面的配置把一次 Pipeline 分成五个阶段： 安装依赖(install_deps) 运行测试(test) 编译(build) 部署测试服务器(deploy_test) 部署生产服务器(deploy_production) 设置 Job.only 后，只有当 develop 分支和 master 分支有提交的时候才会触发相关的 Jobs。 节点说明： stages：定义构建阶段，这里只有一个阶段 deploy deploy：构建阶段 deploy 的详细配置也就是任务配置 script：需要执行的 shell 脚本 only：这里的 master 指在提交到 master 时执行 tags：与注册 runner 时的 tag 匹配 其它配置 为保证能够正常集成，我们还需要一些其它配置： 安装完 GitLab Runner 后系统会增加一个 gitlab-runner 账户，我们将它加进 root 组： gpasswd -a gitlab-runner root 配置需要操作目录的权限，比如你的 runner 要在 gaming 目录下操作： chmod 775 gaming 由于我们的 shell 脚本中有执行 git pull 的命令，我们直接设置以 ssh 方式拉取代码： su gitlab-runner ssh-keygen -t rsa -C \"你在 GitLab 上的邮箱地址\" cd cd .ssh cat id_rsa.pub 复制 id_rsa.pub 中的秘钥到 GitLab： 通过 ssh 的方式将代码拉取到本地 测试集成效果 所有操作完成后 push 代码到服务器，查看是否成功： passed 表示执行成功 其他命令 删除注册信息： gitlab-ci-multi-runner unregister --name \"名称\" 查看注册列表： gitlab-ci-multi-runner list Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/GitLab持续集成/GitLab-Runner-Docker.html":{"url":"chapter22/GitLab持续集成/GitLab-Runner-Docker.html","title":"GitLab Runner Docker","keywords":"","body":"GitLab Runner Docker 为了配置方便，我们使用 docker 来部署 GitLab Runner 环境准备 创建工作目录 /usr/local/docker/runner 创建构建目录 /usr/local/docker/runner/environment 下载 jdk-8u152-linux-x64.tar.gz 并复制到 /usr/local/docker/runner/environment Dockerfile 在 /usr/local/docker/runner/environment 目录下创建 Dockerfile FROM gitlab/gitlab-runner MAINTAINER Lusifer # 修改软件源 RUN echo 'deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse' > /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse' >> /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse' >> /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse' >> /etc/apt/sources.list && \\ apt-get update -y && \\ apt-get clean # 安装 Docker RUN apt-get -y install apt-transport-https ca-certificates curl software-properties-common && \\ curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - && \\ add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" && \\ apt-get update -y && \\ apt-get install -y docker-ce COPY docker.service /lib/systemd/system/docker.service # 安装 Docker Compose WORKDIR /usr/local/bin RUN wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-compose RUN chmod +x docker-compose # 安装 Java RUN mkdir -p /usr/local/java WORKDIR /usr/local/java COPY jdk-8u152-linux-x64.tar.gz /usr/local/java RUN tar -zxvf jdk-8u152-linux-x64.tar.gz && \\ rm -fr jdk-8u152-linux-x64.tar.gz # 安装 Maven RUN mkdir -p /usr/local/maven WORKDIR /usr/local/maven RUN wget https://raw.githubusercontent.com/topsale/resources/master/maven/apache-maven-3.5.3-bin.tar.gz # COPY apache-maven-3.5.3-bin.tar.gz /usr/local/maven RUN tar -zxvf apache-maven-3.5.3-bin.tar.gz && \\ rm -fr apache-maven-3.5.3-bin.tar.gz COPY settings.xml /usr/local/maven/apache-maven-3.5.3/conf/settings.xml # 配置环境变量 ENV JAVA_HOME /usr/local/java/jdk1.8.0_152 ENV MAVEN_HOME /usr/local/maven/apache-maven-3.5.3 ENV PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin WORKDIR / docker.service 在 /usr/local/docker/runner/environment 目录下创建 docker.service，用于配置加速器和仓库地址 --registry-mirror=加速器地址 --insecure-registry 仓库地址 [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target docker.socket firewalld.service Wants=network-online.target Requires=docker.socket [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker ExecStart=/usr/bin/dockerd -H fd:// --registry-mirror=https://jxus37ac.mirror.aliyuncs.com --insecure-registry 192.168.75.128:5000 ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=1048576 # Having non-zero Limit*s causes performance problems due to accounting overhead # in the kernel. We recommend using cgroups to do container-local accounting. LimitNPROC=infinity LimitCORE=infinity # Uncomment TasksMax if your systemd version supports it. # Only systemd 226 and above support this version. #TasksMax=infinity TimeoutStartSec=0 # set delegate yes so that systemd does not reset the cgroups of docker containers Delegate=yes # kill only the docker process, not all processes in the cgroup KillMode=process # restart the docker process if it exits prematurely Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target settings.xml 在 /usr/local/docker/runner/environment 目录下创建 settings.xml，用于配置 maven 仓库地址 com.your.plugins --> optional true http proxyuser proxypass proxy.host.net 80 local.net|some.host.com --> deploymentRepo repouser repopwd --> siteServer /path/to/private/key optional; leave empty if not used. --> maven-snapshots maven-snapshots http://192.168.75.128:8081/repository/maven-snapshots/ maven-snapshots maven-public maven-public http://192.168.75.128:8081/repository/maven-public/ central maven-snapshots maven-snapshots http://192.168.75.128:8081/repository/maven-snapshots/ false true maven-public maven-public http://192.168.75.128:8081/repository/maven-public/ true false maven-snapshots maven-public docker-compose.yml 在 /usr/local/docker/runner 目录下创建 docker-compose.yml version: '3.1' services: gitlab-runner: build: environment restart: always container_name: gitlab-runner privileged: true volumes: - /usr/local/docker/runner/config:/etc/gitlab-runner - /var/run/docker.sock:/var/run/docker.sock 注册 Runner docker exec -it gitlab-runner gitlab-runner register # 输入 GitLab 地址 Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/): http://192.168.75.146:8080/ # 输入 GitLab Token Please enter the gitlab-ci token for this runner: 1Lxq_f1NRfCfeNbE5WRh # 输入 Runner 的说明 Please enter the gitlab-ci description for this runner: 可以为空 # 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci Please enter the gitlab-ci tags for this runner (comma separated): deploy # 这里选择 true ，可以用于代码上传后直接执行 Whether to run untagged builds [true/false]: true # 这里选择 false，可以直接回车，默认为 false Whether to lock Runner to current project [true/false]: false # 选择 runner 执行器，这里我们选择的是 shell Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh: shell 项目配置 Dockerfile FROM openjdk:8-jre MAINTAINER Lusifer ENV APP_VERSION 1.0.0-SNAPSHOT ENV DOCKERIZE_VERSION v0.6.0 RUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ && tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ && rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz RUN mkdir /app WORKDIR /app COPY leeshop-server-service-admin-$APP_VERSION.jar /app/app.jar ENTRYPOINT [\"dockerize\", \"-timeout\", \"5m\", \"-wait\", \"tcp://192.168.75.128:3306\", \"java\", \"-Djava.security.egd=file:/dev/./urandom\", \"-jar\", \"/app/app.jar\"] EXPOSE 20880 docker-compose.yml version: '3.1' services: leeshop-server-service-admin: restart: always image: 192.168.75.128:5000/leeshop-server-service-admin container_name: leeshop-server-service-admin network_mode: \"host\" .gitlab-ci.yml stages: - build - push - deploy - clean build: stage: build script: - $MAVEN_HOME/bin/mvn clean package - cp target/leeshop-server-service-admin-1.0.0-SNAPSHOT.jar docker/ - cd docker - docker build -t 192.168.75.128:5000/leeshop-server-service-admin . push: stage: push script: - docker push 192.168.75.128:5000/leeshop-server-service-admin deploy: stage: deploy script: - cd docker - docker-compose down - docker pull 192.168.75.128:5000/leeshop-server-service-admin - docker-compose up -d clean: stage: clean script: - docker rmi $(docker images -q -f dangling=true) Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/实战持续集成.html":{"url":"chapter22/实战持续集成.html","title":"实战持续集成","keywords":"","body":"实战持续集成 Maven 私服搭建 持续集成的实现思路 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/实战持续集成/Maven私服搭建.html":{"url":"chapter22/实战持续集成/Maven私服搭建.html","title":"Maven 私服搭建","keywords":"","body":"Maven 私服搭建 简介 在使用 Maven 打包项目时我们需要依赖自己或其他同事开发的项目，这些项目在 Maven 中央仓库里是不存在的，我们也不能每次都是以通过编译源码的方式将这些依赖安装到本地仓库中，此时就需要 Maven 私服来帮我解决项目依赖的管理问题 docker-compose.yml version: '3.1' services: nexus: restart: always image: shifudao/nexus3 container_name: nexus ports: - 8081:8081 volumes: - /usr/local/docker/nexus/data:/nexus-data 登录控制台 地址：http://192.168.75.136:8081/ 用户名：admin 密码：admin123 设置代理仓库 pom.xml 中增加配置 maven-snapshots maven-snapshots http://192.168.75.136:8081/repository/maven-snapshots/ true false 部署管理 pom.xml 中增加配置 nexus Nexus Snapshot http://192.168.75.136:8081/repository/maven-snapshots/ nexus Nexus Releases http://192.168.75.136:8081/repository/maven-releases/ 配置 Maven 服务器认证 nexus admin admin123 部署工程到私服 mvn deploy 部署成功效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/实战持续集成/持续集成的实现思路.html":{"url":"chapter22/实战持续集成/持续集成的实现思路.html","title":"持续集成的实现思路","keywords":"","body":"持续集成的实现思路 利用 GitLab 的 Runner 功能 安装 GitLab Runner 所需要的环境 提交代码到仓库，仓库通知 Runner Runner 自动拉取代码 通过 .gitlab-ci.yml 触发脚本，构建、打包、制作镜像、上传镜像、通知目标服务器 目标服务器拉取最新镜像并重新启动容器 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/Jenkins持续交付.html":{"url":"chapter22/Jenkins持续交付.html","title":"Jenkins 持续交付","keywords":"","body":"Jenkins 持续交付 Jenkins 简介 Jenkins 部署 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/Jenkins持续交付/Jenkins简介.html":{"url":"chapter22/Jenkins持续交付/Jenkins简介.html","title":"Jenkins 简介","keywords":"","body":"Jenkins 简介 Jenkins 是一个开源软件项目，是基于 Java 开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"chapter22/Jenkins持续交付/Jenkins部署.html":{"url":"chapter22/Jenkins持续交付/Jenkins部署.html","title":"Jenkins 部署","keywords":"","body":"Jenkins 部署 Lusifer 123456 docker-compose.yml version: '3.1' services: jenkins: restart: always image: jenkins container_name: jenkins ports: - 8080:8080 - 50000:50000 environment: TZ: Asia/Shanghai volumes: - /usr/local/docker/jenkins/data:/var/jenkins_home 设置数据卷目录权限 chown -R 1000 /usr/local/docker/jenkins/data 部署成功效果图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录.html":{"url":"附录.html","title":"附录","keywords":"","body":"附录 Maven Maven 简介 Maven 安装配置 Maven 本地资源库 Maven 中央仓库 Maven 依赖机制 Maven POM Maven 插件 Maven 快照 Maven 常用命令 Maven 简单的 Web 应用 Fiddler Fiddler 简介 Fiddler 捕获 HTTPS 会话 Fiddler 基本界面 Fiddler HTTP 统计 Fiddler 命令行工具 Fiddler 会话管理 Fiddler 手机抓包 RabbitMQ 消息队列的流派 Actor 模型 RabbitMQ 简介 RabbitMQ 安装 RabbitMQ WEB-UI RabbitMQ 创建生产者 RabbitMQ 创建消费者 单点登录 单点登录系统机制 多系统登录的复杂性 单点登录系统流程 部署图及实现原理 单点登录实战 IDEA 插件 JRebel JRebel 简介 IDEA 安装 JRebel 插件 IDEA 插件 Lombok Lombok 简介 IDEA 安装 Lombok 插件 趣头条分析 产品分析报告 数据结构分析-配置相关 数据结构分析-头条模块 数据库设计 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/maven.html":{"url":"附录/maven.html","title":"Maven","keywords":"","body":"Maven Maven 简介 Maven 安装配置 Maven 本地资源库 Maven 中央仓库 Maven 依赖机制 Maven POM Maven 插件 Maven 快照 Maven 常用命令 Maven 简单的 Web 应用 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/maven/Maven简介.html":{"url":"附录/maven/Maven简介.html","title":"Maven 简介","keywords":"","body":"Maven 简介 Maven 是一个项目管理和综合工具。Maven 提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven 使用标准的目录结构和默认构建生命周期。 在多个开发团队环境时，Maven 可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven 让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。 Maven 提供了开发人员的方式来管理： Builds Documentation Reporting Dependencies SCMs Releases Distribution mailing list 概括地说，Maven 简化和标准化项目建设过程。处理编译，分配，文档，团队协作和其他任务的无缝连接。 Maven 增加可重用性并负责建立相关的任务。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/maven/Maven安装配置.html":{"url":"附录/maven/Maven安装配置.html","title":"Maven 安装配置","keywords":"","body":"Maven 安装配置 想要安装 Apache Maven 在 Windows 系统上, 需要下载 Maven 的 zip 文件，并将其解压到你想安装的目录，并配置 Windows 环境变量。 注意：请尽量使用 JDK 1.8 及以上版本 JDK 和 JAVA_HOME 确保已安装JDK，并 “JAVA_HOME” 变量已加入到 Windows 环境变量。 下载 Apache Mave 下载地址：http://maven.apache.org/download.cgi 下载 Maven 的 zip 文件，例如： apache-maven-3.5.2-bin.zip，将它解压到你要安装 Maven 的文件夹。假设你解压缩到文件夹 – D:\\apache-maven-3.5.2 注意：在这一步，只是文件夹和文件，安装不是必需的。 添加 MAVEN_HOME 添加 MAVEN_HOME 环境变量到 Windows 环境变量，并将其指向你的 Maven 文件夹。 添加到环境变量 - PATH 验证 使用命令：mvn -version 输出： C:\\Users\\Lusifer>mvn -version Apache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T15:58:13+08:00) Maven home: D:\\apache-maven-3.5.2\\bin\\.. Java version: 1.8.0_152, vendor: Oracle Corporation Java home: C:\\Program Files\\Java\\jdk1.8.0_152\\jre Default locale: zh_CN, platform encoding: GBK OS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"windows\" Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/maven/Maven本地资源库.html":{"url":"附录/maven/Maven本地资源库.html","title":"Maven 本地资源库","keywords":"","body":"Maven 本地资源库 Maven的本地资源库是用来存储所有项目的依赖关系(插件jar和其他文件，这些文件被Maven下载)到本地文件夹。很简单，当你建立一个Maven项目，所有相关文件将被存储在你的Maven本地仓库。 默认情况下，Maven的本地资源库默认为 .m2 目录文件夹： Unix/Mac OS X – ~/.m2 Windows – C:\\Documents and Settings{your-username}.m2 更新Maven的本地库 通常情况下，可改变默认的 .m2 目录下的默认本地存储库文件夹到其他更有意义的名称，例如， maven-repo找到 {M2_HOME}\\conf\\setting.xml, 更新 localRepository 到其它名称。 保存文件 执行之后，新的 Maven 本地存储库现在改为 D:/apache-maven-3.5.2/repo Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/maven/Maven中央仓库.html":{"url":"附录/maven/Maven中央仓库.html","title":"Maven 中央仓库","keywords":"","body":"Maven 中央仓库 当你建立一个 Maven 的项目，Maven 会检查你的 pom.xml 文件，以确定哪些依赖下载。首先，Maven 将从本地资源库获得 Maven 的本地资源库依赖资源，如果没有找到，然后把它会从默认的 Maven 中央存储库 – http://repo1.maven.org/maven2/ 查找下载。 使用 MVNrepository 搜索：https://mvnrepository.com/ Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/maven/Maven依赖机制.html":{"url":"附录/maven/Maven依赖机制.html","title":"Maven 依赖机制","keywords":"","body":"Maven 依赖机制 在 Maven 依赖机制的帮助下自动下载所有必需的依赖库，并保持版本升级。让我们看一个案例研究，以了解它是如何工作的。假设你想使用 Log4j 作为项目的日志。这里你要做什么？ 传统方式 访问 http://logging.apache.org/log4j/ 下载 Log4j 的 jar 库 复制 jar 到项目类路径 手动将其包含到项目的依赖 所有的管理需要一切由自己做 如果有 Log4j 版本升级，则需要重复上述步骤一次。 Maven 的方式 你需要知道 log4j 的 Maven 坐标，例如： log4j log4j 1.2.17 它会自动下载 log4j 的 1.2.17 版本库 声明 Maven 的坐标转换成 pom.xml 文件 log4j log4j 1.2.17 当 Maven 编译或构建，log4j 的 jar 会自动下载，并把它放到 Maven 本地存储库 所有由 Maven 管理 解释说明 看看有什么不同？那么到底在Maven发生了什么？当建立一个Maven的项目，pom.xml文件将被解析，如果看到 log4j 的 Maven 坐标，然后 Maven 按此顺序搜索 log4j 库： 在 Maven 的本地仓库搜索 log4j 在 Maven 中央存储库搜索 log4j 在 Maven 远程仓库搜索 log4j(如果在 pom.xml 中定义) Maven 依赖库管理是一个非常好的工具，为您节省了大量的工作 log4j.properties log4j.rootLogger=INFO, console, file log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=%d %p [%c] - %m%n log4j.appender.file=org.apache.log4j.DailyRollingFileAppender log4j.appender.file.File=logs/log.log log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.A3.MaxFileSize=1024KB log4j.appender.A3.MaxBackupIndex=10 log4j.appender.file.layout.ConversionPattern=%d %p [%c] - %m%n Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/maven/MavenPOM.html":{"url":"附录/maven/MavenPOM.html","title":"Maven POM","keywords":"","body":"Maven POM POM 代表项目对象模型。它是 Maven 中工作的基本单位，这是一个 XML 文件。它始终保存在该项目基本目录中的 pom.xml 文件。 POM 包含的项目是使用 Maven 来构建的，它用来包含各种配置信息。 POM 也包含了目标和插件。在执行任务或目标时，Maven 会使用当前目录中的 POM。它读取POM得到所需要的配置信息，然后执行目标。部分的配置可以在 POM 使用如下： project dependencies plugins goals build profiles project version developers mailing list 创建一个POM之前，应该要先决定项目组(groupId)，它的名字(artifactId)和版本，因为这些属性在项目仓库是唯一标识的。 POM 的例子 4.0.0 com.lusifer project 1.0 要注意的是，每个项目只有一个POM文件 所有的 POM 文件要项目元素必须有三个必填字段: groupId，artifactId，version 在库中的项目符号是：groupId:artifactId:version pom.xml 的根元素是 project，它有三个主要的子节点。 节点 描述 groupId 这是项目组的编号，这在组织或项目中通常是独一无二的。 例如，一家银行集团com.company.bank拥有所有银行相关项目。 artifactId 这是项目的ID。这通常是项目的名称。 例如，consumer-banking。 除了groupId之外，artifactId还定义了artifact在存储库中的位置。 version 这是项目的版本。与groupId一起使用，artifact在存储库中用于将版本彼此分离。 例如：com.company.bank:consumer-banking:1.0，com.company.bank:consumer-banking:1.1 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/maven/Maven插件.html":{"url":"附录/maven/Maven插件.html","title":"Maven 插件","keywords":"","body":"Maven 插件 Maven 是一个执行插件的框架，每一个任务实际上是由插件完成的。Maven 插件通常用于： 创建 jar 文件 创建 war 文件 编译代码文件 进行代码单元测试 创建项目文档 创建项目报告 一个插件通常提供了一组目标，可使用以下语法来执行： mvn [plugin-name]:[goal-name] 例如，一个 Java 项目可以使用 Maven 编译器插件来编译目标，通过运行以下命令编译 mvn compiler:compile 插件类型 Maven 提供以下两种类型插件： 类型 描述 构建插件 在生成过程中执行，并在 pom.xml 中的 元素进行配置 报告插件 在网站生成期间执行，在 pom.xml 中的,元素进行配置 以下是一些常见的插件列表： 插件 描述 clean 编译后的清理目标，删除目标目录 compiler 编译 Java 源文件 surefile 运行JUnit单元测试，创建测试报告 jar 从当前项目构建 JAR 文件 war 从当前项目构建 WAR 文件 javadoc 产生用于该项目的 Javadoc antrun 从构建所述的任何阶段运行一组 Ant 任务 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/maven/Maven快照.html":{"url":"附录/maven/Maven快照.html","title":"Maven 快照","keywords":"","body":"Maven 快照 大型应用软件一般由多个模块组成，一般它是多个团队开发同一个应用程序的不同模块，这是比较常见的场景。例如，一个团队正在对应用程序的应用程序，用户界面项目(app-ui.jar:1.0) 的前端进行开发，他们使用的是数据服务工程 (data-service.jar:1.0)。 现在，它可能会有这样的情况发生，工作在数据服务团队开发人员快速地开发 bug 修复或增强功能，他们几乎每隔一天就要释放出库到远程仓库。 现在，如果数据服务团队上传新版本后，会出现下面的问题： 数据服务团队应该发布更新时每次都告诉应用程序UI团队，他们已经发布更新了代码。 UI团队需要经常更新自己 pom.xml 以获得更新应用程序的版本。 为了处理这类情况，引入快照的概念，并发挥作用。 什么是快照？ 快照（SNAPSHOT ）是一个特殊版本，指出目前开发拷贝。不同于常规版本，Maven 每生成一个远程存储库都会检查新的快照版本。 现在，数据服务团队将在每次发布代码后更新快照存储库为：data-service:1.0-SNAPSHOT 替换旧的 SNAPSHOT jar。 快照与版本 在使用版本时，如果 Maven 下载所提到的版本为 data-service:1.0，那么它永远不会尝试在库中下载已经更新的版本1.0。要下载更新的代码，data-service的版本必须要升级到1.1。 在使用快照（SNAPSHOT）时，Maven会在每次应用程序UI团队建立自己的项目时自动获取最新的快照（data-service:1.0-SNAPSHOT）。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/maven/Maven常用命令.html":{"url":"附录/maven/Maven常用命令.html","title":"Maven 常用命令","keywords":"","body":"Maven 常用命令 清除产生的项目 mvn clean 编译源代码 mvn compile 打包 mvn package 只打包不测试（跳过测试） mvn -dmaven.test.skip=true 安装到本地仓库 mvn install 源码打包 mvn source:jar 或 mvn source:jar-no-fork Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/maven/Maven简单的Web应用.html":{"url":"附录/maven/Maven简单的Web应用.html","title":"Maven 简单的 Web 应用","keywords":"","body":"Maven 简单的 Web 应用 创建 webapp 目录 在 src/main 目录下创建 webapp 目录 创建 WEB-INF 目录 在 src/main/webapp 目录下创建 WEB-INF 目录 创建 web.xml 文件 在 src/main/webapp/WEB-INF 目录下创建 web.xml 文件 Maven Study 创建 Servlet package com.lusifer.maven.servlet; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; public class MavenServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { PrintWriter writer = resp.getWriter(); writer.println(\"Hello Maven Servlet\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 引入 J2EE 依赖 javax.servlet javax.servlet-api 3.1.0 provided javax.servlet.jsp jsp-api 2.2 provided 配置 Servlet MavenServlet com.lusifer.maven.servlet.MavenServlet MavenServlet /maven 配置 Tomcat Run -> Edit Configurations... 运行测试 创建 index.jsp 在 src/main/webapp 目录下创建 index.jsp 文件 Maven Hello Maven JSP Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/fiddler.html":{"url":"附录/fiddler.html","title":"Fiddler","keywords":"","body":"Fiddler Fiddler 简介 Fiddler 捕获 HTTPS 会话 Fiddler 基本界面 Fiddler HTTP 统计 Fiddler 命令行工具 Fiddler 会话管理 Fiddler 手机抓包 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/Fiddler/Fiddler简介.html":{"url":"附录/Fiddler/Fiddler简介.html","title":"Fiddler 简介","keywords":"","body":"Fiddler 简介 什么是 Fiddler Fiddler 是一个 http 协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的 http 通讯，设置断点，查看所有的进出 Fiddler 的数据。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露 http 通讯还提供了一个用户友好的格式。 为什么使用 Fiddler FireBug：虽然可以抓包，但是对于分析 http 请求的详细信息，不够强大。模拟 http 请求的功能也不够，且 firebug 常常是需要“无刷新修改”，如果刷新了页面，所有的修改都不会保存。 WireShark：是通用的抓包工具，但是比较庞大，对于只需要抓取 http 请求的应用来说，似乎有些大材小用。 HttpWatch：也是比较常用的 http 抓包工具，但是只支持 IE 和 firefox 浏览器(其他浏览器可能会有相应的插件)，对于想要调试 chrome 浏览器的 http 请求，似乎稍显无力，而 Fiddler 是一个使用本地 127.0.0.1:8888 的 HTTP 代理，任何能够设置 HTTP 代理为 127.0.0.1:8888 的浏览器和应用程序都可以使用 Fiddler。 Fiddler 简介 Fiddler 是位于客户端和服务器端的 HTTP 代理，也是目前最常用的 http 抓包工具之一，它能够记录客户端和服务器之间的所有 HTTP 请求，可以针对特定的 HTTP 请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是 web 调试的利器。 既然是代理，也就是说：客户端的所有请求都要先经过 Fiddler，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过 Fiddler 然后发送到客户端，基于这个原因，Fiddler支持所有可以设置 http 代理为 127.0.0.1:8888 的浏览器和应用程序。使用了 Fiddler 之后，web 客户端和服务器的请求如下所示： Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/Fiddler/Fiddler捕获HTTPS会话.html":{"url":"附录/Fiddler/Fiddler捕获HTTPS会话.html","title":"Fiddler 捕获 HTTPS 会话","keywords":"","body":"Fiddler 捕获 HTTPS 会话 默认下，Fiddler 不会捕获 HTTPS 会话，需要设置下, 打开 Fiddler Tools --> Fiddler Options --> HTTPS 选中 Checkbox，弹出如下的对话框，点击 “Yes” 安装证书 忽略 HTTPS 错误 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/Fiddler/Fiddler基本界面.html":{"url":"附录/Fiddler/Fiddler基本界面.html","title":"Fiddler 基本界面","keywords":"","body":"Fiddler 基本界面 Inspectors 下有很多查看 Request 或者 Response 的消息。其中 Raw 可以查看完整的消息，Headers 只查看消息中的 header，JSON 返回响应的 JSON 数据，如下图： Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/Fiddler/FiddlerHTTP统计.html":{"url":"附录/Fiddler/FiddlerHTTP统计.html","title":"Fiddler HTTP 统计","keywords":"","body":"Fiddler HTTP 统计 通过陈列出所有的 HTTP 通信量，Fiddler 可以很容易的向您展示哪些文件生成了您当前请求的页面。使用 Statistics 页签，用户可以通过选择多个会话来得来这几个会话的总的信息统计，比如多个请求和传输的字节数。选择第一个请求和最后一个请求，可获得整个页面加载所消耗的总体时间。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/Fiddler/Fiddler命令行工具.html":{"url":"附录/Fiddler/Fiddler命令行工具.html","title":"Fiddler 命令行工具","keywords":"","body":"Fiddler 命令行工具 Fiddler 的左下角有一个命令行工具叫做 QuickExec，允许你直接输入命令，常用命令，如： help：打开官方的使用页面介绍，所有的命令都会列出来 cls：清屏(Ctrl + X) select：选择会话的命令 ?.png：用来选择 png 后缀的图片 bpu：截获 Request Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/Fiddler/Fiddler会话管理.html":{"url":"附录/Fiddler/Fiddler会话管理.html","title":"Fiddler 会话管理","keywords":"","body":"Fiddler 会话管理 过滤会话 每次使用 Fiddler, 打开一个网站，都能在 Fiddler 中看到几十个会话，看得眼花缭乱。最好的办法是过滤掉一些会话，比如过滤掉图片的会话. Fiddler 中有过滤的功能, 在右边的 Filters 页签中 比较会话 选中 2 个会话，右键然后点击 Compare，就可以用 WinDiff 来比较两个会话的不同了(在此之前需要先设置并安装 WinDiff) 设置 WinDiff 比较 查询会话 用快捷键 Ctrl+F 打开 Find Sessions 的对话框，输入关键字查询你要的会话。查询到的会话会用黄色显示 保存会话 有些时候我们需要把会话保存下来，以便发给别人或者以后去分析。选中你想保存的会话，然后点击 File --> Save --> Selected Sessions Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/Fiddler/Fiddler手机抓包.html":{"url":"附录/Fiddler/Fiddler手机抓包.html","title":"Fiddler 手机抓包","keywords":"","body":"Fiddler 手机抓包 Fiddler 配置 需要配置 Fiddler 允许远程连接，点击 Tools --> Fiddler Options --> Connections，勾选 allow remote computers to connect，默认监听端口为 8888，若端口被占用可以设置成其他的，配置好后要重新启动 Fiddler，如下图： iOS 系统抓包 设置网络代理 打开 iPhone, 找到你的网络连接，打开 HTTP 代理，输入 Fiddler 所在机器的 IP 地址以及 Fiddler 的端口号 8888 安装 Fiddler 证书 这一步是为了让 Fiddler 能捕获 HTTPS 请求。如果你只需要截获 HTTP 请求，可以忽略这一步 首先要知道 Fiddler 所在的机器的 IP 地址，例如我安装了 Fiddler 的机器的 IP 地址是：192.168.0.103 打开 iPhone 的 Safari，访问 http://192.168.0.103:8888，点击 FiddlerRoot certificate 然后安装证书 开启 Fiddler 证书 iOS 10.3 以后，安装了的证书不是默认启用的，而是需要手动开启。设置 --> 通用 -> 关于本机 -> 证书信息设置 抓包效果图 注意事项 用完了，需要把 iPhone 上的 Fiddler 代理关闭，否则无法上网。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/rabbitmq.html":{"url":"附录/rabbitmq.html","title":"RabbitMQ","keywords":"","body":"RabbitMQ 消息队列的流派 Actor 模型 RabbitMQ 简介 RabbitMQ 安装 RabbitMQ WEB-UI RabbitMQ 创建生产者 RabbitMQ 创建消费者 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/rabbitmq/消息队列的流派.html":{"url":"附录/rabbitmq/消息队列的流派.html","title":"消息队列的流派","keywords":"","body":"消息队列的流派 什么是 MQ Message Queue（MQ），消息队列中间件。很多人都说：MQ 通过将消息的发送和接收分离来实现应用程序的异步和解偶，这个给人的直觉是——MQ 是异步的，用来解耦的，但是这个只是 MQ 的效果而不是目的。MQ 真正的目的是为了通讯，屏蔽底层复杂的通讯协议，定义了一套应用层的、更加简单的通讯协议。一个分布式系统中两个模块之间通讯要么是 HTTP，要么是自己开发的 TCP，但是这两种协议其实都是原始的协议。HTTP 协议很难实现两端通讯——模块 A 可以调用 B，B 也可以主动调用 A，如果要做到这个两端都要背上 WebServer，而且还不支持长连接（HTTP 2.0 的库根本找不到）。TCP 就更加原始了，粘包、心跳、私有的协议，想一想头皮就发麻。MQ 所要做的就是在这些协议之上构建一个简单的“协议”——生产者/消费者模型。MQ 带给我的“协议”不是具体的通讯协议，而是更高层次通讯模型。它定义了两个对象——发送数据的叫生产者；接收数据的叫消费者， 提供一个 SDK 让我们可以定义自己的生产者和消费者实现消息通讯而无视底层通讯协议 有 Broker 的 MQ 这个流派通常有一台服务器作为 Broker，所有的消息都通过它中转。生产者把消息发送给它就结束自己的任务了，Broker 则把消息主动推送给消费者（或者消费者主动轮询） 重 Topic kafka、JMS（ActiveMQ）就属于这个流派，生产者会发送 key 和数据到 Broker，由 Broker 比较 key 之后决定给哪个消费者。这种模式是我们最常见的模式，是我们对 MQ 最多的印象。在这种模式下一个 topic 往往是一个比较大的概念，甚至一个系统中就可能只有一个 topic，topic 某种意义上就是 queue，生产者发送 key 相当于说：“hi，把数据放到 key 的队列中” 如上图所示，Broker 定义了三个队列，key1，key2，key3，生产者发送数据的时候会发送 key1 和 data，Broker 在推送数据的时候则推送 data（也可能把 key 带上）。 虽然架构一样但是 kafka 的性能要比 jms 的性能不知道高到多少倍，所以基本这种类型的 MQ 只有 kafka 一种备选方案。如果你需要一条暴力的数据流（在乎性能而非灵活性）那么 kafka 是最好的选择 轻 Topic 这种的代表是 RabbitMQ（或者说是 AMQP）。生产者发送 key 和数据，消费者定义订阅的队列，Broker 收到数据之后会通过一定的逻辑计算出 key 对应的队列，然后把数据交给队列 这种模式下解耦了 key 和 queue，在这种架构中 queue 是非常轻量级的（在 RabbitMQ 中它的上限取决于你的内存），消费者关心的只是自己的 queue；生产者不必关心数据最终给谁只要指定 key 就行了，中间的那层映射在 AMQP 中叫 exchange（交换机）。 AMQP 中有四种 exchange Direct exchange：key 就等于 queue Fanout exchange：无视 key，给所有的 queue 都来一份 Topic exchange：key 可以用“宽字符”模糊匹配 queue Headers exchange：无视 key，通过查看消息的头部元数据来决定发给那个 queue（AMQP 头部元数据非常丰富而且可以自定义） 这种结构的架构给通讯带来了很大的灵活性，我们能想到的通讯方式都可以用这四种 exchange 表达出来。如果你需要一个企业数据总线（在乎灵活性）那么 RabbitMQ 绝对的值得一用 无 Broker 的 MQ 无 Broker 的 MQ 的代表是 ZeroMQ。该作者非常睿智，他非常敏锐的意识到——MQ 是更高级的 Socket，它是解决通讯问题的。所以 ZeroMQ 被设计成了一个“库”而不是一个中间件，这种实现也可以达到——没有 Broker 的目的 节点之间通讯的消息都是发送到彼此的队列中，每个节点都既是生产者又是消费者。ZeroMQ 做的事情就是封装出一套类似于 Socket 的 API 可以完成发送数据，读取数据 ZeroMQ 其实就是一个跨语言的、重量级的 Actor 模型邮箱库。你可以把自己的程序想象成一个 Actor，ZeroMQ 就是提供邮箱功能的库；ZeroMQ 可以实现同一台机器的 RPC 通讯也可以实现不同机器的 TCP、UDP 通讯，如果你需要一个强大的、灵活、野蛮的通讯能力，别犹豫 ZeroMQ Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/rabbitmq/Actor模型.html":{"url":"附录/rabbitmq/Actor模型.html","title":"Actor 模型","keywords":"","body":"Actor 模型 什么是 Actor 模型 Actor 模式是一个解决分布式计算的数学模型，其中 Actor 是基础，它能回应接收到消息，能够自我决策，创建更多的 Actor，发送更多的消息，决定如何回应下一个接收到的消息。Actor 认为一切皆是 Actor，类似于面向对象认为一切皆 Object 一样。OO 的执行是顺序的，Actor 模型内在设计就是并行的 Actor 是异步的 Actor 是计算实体，它回复接收到的消息，能够并行的： 发生有限的消息给其他 Actor 创建有限数目的新 Actor 指定一个消息到达时的行为 这些操作并没有顺序要求，它们能够并行地实施。由于没有对消息的时序做规定，Actor 模式是一种异步模型，发送到 Actor 不等待消息被接收而继续执行。Actor 之间不共享状态，如果想获取其他 Actor 的状态，只能通过消息请求的方式 Actor 在消息内部指定接收消息的 Actor 地址。Actor 可以用自己的地址发送消息，相当于自己接收到自己发送的消息，可以驱动自己的状态 所谓真正的 Actor 模型 Actor 可以被认为是在用户空间实现的并发实体，所以它应该是应用级别的线程。如果认同这个观点那么 Actor 要满足的要求 = 操作系统对进程/线程 提出的要求一样 内存结构 每个并发实体都是要有一个固定的数据结构，必须有一个容器可以保存当前所有的并发实体。这一点基本上很容易满足，Akka 中 Actor 就是一个类，所以它的结构就是这个类的数据结构，大小也就是这个类的大小。Akka 中的 Dispatcher 保存有所有 Actor 的列表 并发原语 操作系统的是通过临界区，锁来定义多线程共享数据模型的。在 Actor 中是通过消息来共享数据的。基于消息传递要求“数据只读”，你发送出去的数据再修改肯定就不对了。但是这一点在 Java 里面无论如何都是做不到的，你不修改变量的引用但是还可以修改变量里面的值，调用对象的方法。 调度 这是最重要的：没有调度，并发实体根本不能称之为并发实体。操作系统中 CPU 是由内核管理的，调度算法是基于时间片来调任务的，内核随时可以剥夺一个任务的 CPU 使用权这就是“抢占”。这一点非常重要，没有这个功能就意味着调度是不公平的。一个任务耗费大量 CPU 会把另个一任务给饿死。但是在用户空间（应用层）很难实现这一点，毕竟 CPU 是不受应用程序的控制的，没有把办法剥夺。抢占看似可有可无，但是没有它就没有“公平调度”，也就谈不上并发。（有任务撑死，有任务饿死） 所谓“公平调度” 比如写两个 Actor，使用无限循环输出字符串（while(true)）会疯狂的吃 CPU，如果是可抢占的公平调度，则 actor1 和 actor2 应该是比较有规律的交替（大家得到的 CPU 时间差不多） Java 中的 Akka test1 test1 test1 ... test2 test2 test2 ... test1 ... ErLang test1 test2 test1 test2 test1 test2 test1 test2 ... ErLang 非常均匀的任务切换，实现了“可抢占的公平” Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/rabbitmq/RabbitMQ简介.html":{"url":"附录/rabbitmq/RabbitMQ简介.html","title":"RabbitMQ 简介","keywords":"","body":"RabbitMQ 简介 RabbitMQ 的优点 基于 ErLang 语言开发具有高可用高并发的优点，适合集群服务器 健壮、稳定、易用、跨平台、支持多种语言、文档齐全 有消息确认机制和持久化机制，可靠性高 开源 RabbitMQ 的概念 生产者和消费者 Producer：消息的生产者 Consumer：消息的消费者 Queue 消息队列，提供了 FIFO 的处理机制，具有缓存消息的能力。RabbitMQ 中，队列消息可以设置为持久化，临时或者自动删除。 设置为持久化的队列，Queue 中的消息会在 Server 本地硬盘存储一份，防止系统 Crash，数据丢失 设置为临时队列，Queue 中的数据在系统重启之后就会丢失 设置为自动删除的队列，当不存在用户连接到 Server，队列中的数据会被自动删除 ExChange Exchange 类似于数据通信网络中的交换机，提供消息路由策略。RabbitMQ 中，Producer 不是通过信道直接将消息发送给 Queue，而是先发送给 ExChange。一个 ExChange 可以和多个 Queue 进行绑定，Producer 在传递消息的时候，会传递一个 ROUTING_KEY，ExChange 会根据这个 ROUTING_KEY 按照特定的路由算法，将消息路由给指定的 Queue。和 Queue 一样，ExChange 也可设置为持久化，临时或者自动删除 ExChange 的 4 种类型 direct（默认）：直接交换器，工作方式类似于单播，ExChange 会将消息发送完全匹配 ROUTING_KEY 的 Queue（key 就等于 queue） fanout：广播是式交换器，不管消息的 ROUTING_KEY 设置为什么，ExChange 都会将消息转发给所有绑定的 Queue（无视 key，给所有的 queue 都来一份） topic：主题交换器，工作方式类似于组播，ExChange 会将消息转发和 ROUTING_KEY 匹配模式相同的所有队列（key 可以用“宽字符”模糊匹配 queue），比如，ROUTING_KEY 为 user.stock 的 Message 会转发给绑定匹配模式为 * .stock,user.stock， * . * 和 #.user.stock.# 的队列。（ * 表是匹配一个任意词组，# 表示匹配 0 个或多个词组） headers：消息体的 header 匹配，无视 key，通过查看消息的头部元数据来决定发给那个 queue（AMQP 头部元数据非常丰富而且可以自定义） Binding 所谓绑定就是将一个特定的 ExChange 和一个特定的 Queue 绑定起来。ExChange 和 Queue 的绑定可以是多对多的关系 Virtual Host 在 RabbitMQ Server 上可以创建多个虚拟的 Message Broker，又叫做 Virtual Hosts (vhosts)。每一个 vhost 本质上是一个 mini-rabbitmq server，分别管理各自的 ExChange，和 bindings。vhost 相当于物理的 Server，可以为不同 app 提供边界隔离，使得应用安全的运行在不同的 vhost 实例上，相互之间不会干扰。Producer 和 Consumer 连接 rabbit server 需要指定一个 vhost RabbitMQ 的使用过程 客户端连接到消息队列服务器，打开一个 Channel。 客户端声明一个 ExChange，并设置相关属性。 客户端声明一个 Queue，并设置相关属性。 客户端使用 Routing Key，在 ExChange 和 Queue 之间建立好绑定关系。 客户端投递消息到 ExChange。 ExChange 接收到消息后，就根据消息的 key 和已经设置的 binding，进行消息路由，将消息投递到一个或多个队列里 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/rabbitmq/RabbitMQ安装.html":{"url":"附录/rabbitmq/RabbitMQ安装.html","title":"RabbitMQ 安装","keywords":"","body":"RabbitMQ 安装 docker-compose.yml version: '3.1' services: rabbitmq: restart: always image: rabbitmq:management container_name: rabbitmq ports: - 5672:5672 - 15672:15672 environment: TZ: Asia/Shanghai RABBITMQ_DEFAULT_USER: rabbit RABBITMQ_DEFAULT_PASS: 123456 volumes: - /usr/local/docker/rabbitmq/data:/var/lib/rabbitmq Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/rabbitmq/RabbitMQ-WEB-UI.html":{"url":"附录/rabbitmq/RabbitMQ-WEB-UI.html","title":"RabbitMQ WEB-UI","keywords":"","body":"RabbitMQ WebUI 访问地址 http://ip:15672 首页 Global counts Connections：连接数 Channels：频道数 Exchanges：交换机数 Queues：队列数 Consumers：消费者数 交换机页面 队列页面 Name：消息队列的名称，这里是通过程序创建的 Features：消息队列的类型，durable:true为会持久化消息 Ready：准备好的消息 Unacked：未确认的消息 Total：全部消息 备注：如果都为 0 则说明全部消息处理完成 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/rabbitmq/RabbitMQ创建生产者.html":{"url":"附录/rabbitmq/RabbitMQ创建生产者.html","title":"RabbitMQ 创建生产者","keywords":"","body":"RabbitMQ 创建生产者 创建生产者项目 spring-boot-amqp-provider application.yml spring: application: name: spring-boot-amqp rabbitmq: host: 192.168.75.133 port: 5672 username: rabbit password: 123456 创建队列配置 package com.lusifer.spring.boot.amqp.config; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * 队列配置 * Title: RabbitMQConfiguration * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/5/1 22:39 */ @Configuration public class RabbitMQConfiguration { @Bean public Queue queue() { return new Queue(\"helloRabbit\"); } } 创建消息提供者 package com.lusifer.spring.boot.amqp.provider; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.util.Date; /** * 提供者 * Title: HelloRabbitProvider * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/5/1 22:39 */ @Component public class HelloRabbitProvider { @Autowired private AmqpTemplate amqpTemplate; public void send() { String context = \"hello\" + new Date(); System.out.println(\"Provider: \" + context); amqpTemplate.convertAndSend(\"helloRabbit\", context); } } 创建测试用例 package com.lusifer.spring.boot.amqp.test; import com.lusifer.spring.boot.amqp.Application; import com.lusifer.spring.boot.amqp.provider.HelloRabbitProvider; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest(classes = Application.class) public class AmqpTest { @Autowired private HelloRabbitProvider helloRabbitProvider; @Test public void testSender() { for (int i = 0; i Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/rabbitmq/RabbitMQ创建消费者.html":{"url":"附录/rabbitmq/RabbitMQ创建消费者.html","title":"RabbitMQ 创建消费者","keywords":"","body":"RabbitMQ 创建消费者 创建消费者项目 spring-boot-amqp-consumer application.yml spring: application: name: spring-boot-amqp-consumer rabbitmq: host: 192.168.75.133 port: 5672 username: rabbit password: 123456 创建消息消费者 package com.lusifer.spring.boot.amqp.consumer; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = \"helloRabbit\") public class HelloRabbitConsumer { @RabbitHandler public void process(String message) { System.out.println(\"Consumer: \" + message); } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/单点登录.html":{"url":"附录/单点登录.html","title":"单点登录","keywords":"","body":"单点登录 单点登录系统机制 多系统登录的复杂性 单点登录系统流程 部署图及实现原理 单点登录实战 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/单点登录/单点登录系统机制.html":{"url":"附录/单点登录/单点登录系统机制.html","title":"单点登录系统机制","keywords":"","body":"单点登录系统机制 HTTP 无状态协议 web 应用采用 browser/server 架构，http 作为通信协议。http 是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系 但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然 http 协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制 会话机制 浏览器第一次请求服务器，服务器创建一个会话，并将会话的 id 作为响应的一部分发送给浏览器，浏览器存储会话 id，并在后续第二次和第三次请求中带上会话 id，服务器取得请求中的会话 id 就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联 服务器在内存中保存会话的两种方式 请求参数 Cookie 将会话 id 作为每一个请求的参数，服务器接收请求自然能解析参数获得会话 id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话 id 吧，每次发送 http 请求时浏览器自动发送会话 id，cookie 机制正好用来做这件事。cookie 是浏览器用来存储少量数据的一种机制，数据以 key/value 形式存储，浏览器发送 http 请求时自动附带 cookie 信息 tomcat 会话机制当然也实现了 cookie，访问 tomcat 服务器时，浏览器中可以看到一个名为 JSESSIONID 的 cookie，这就是 tomcat 会话机制维护的会话 id，使用了 cookie 的请求响应过程如下图 登录状态 有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat 在会话对象中设置登录状态如下 HttpSession session = request.getSession(); session.setAttribute(\"isLogin\", true); 用户再次访问时，tomcat 在会话对象中查看登录状态 HttpSession session = request.getSession(); session.getAttribute(\"isLogin\"); 实现了登录状态的浏览器请求服务器模型如下图描述 每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/单点登录/多系统登录的复杂性.html":{"url":"附录/单点登录/多系统登录的复杂性.html","title":"多系统登录的复杂性","keywords":"","body":"多系统登录的复杂性 web 系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样 web 系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论 web 系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问 web 系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了 虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？ 单系统登录解决方案的核心是 cookie，cookie 携带会话 id 在浏览器与服务器之间维护会话状态。但 cookie 是有限制的，这个限制就是 cookie 的域（通常对应网站的域名），浏览器发送 http 请求时会自动携带与该域匹配的 cookie，而不是所有 cookie 既然这样，为什么不将 web 应用群中所有子系统的域名统一在一个顶级域名下，例如 *.baidu.com，然后将它们的 cookie 域设置为 baidu.com，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享 cookie 的方式。 然而，可行并不代表好，共享 cookie 的方式存在众多局限。 首先，应用群域名得统一； 其次，应用群各系统使用的技术（至少是 web 服务器）要相同，不然 cookie 的 key 值（tomcat 为 JSESSIONID）不同，无法维持会话，共享 cookie 的方式是无法实现跨语言技术平台登录的，比如java、php、python 系统之间； 第三，cookie 本身不安全。 因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是 单点登录 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/单点登录/单点登录系统流程.html":{"url":"附录/单点登录/单点登录系统流程.html","title":"单点登录系统流程","keywords":"","body":"单点登录系统流程 什么是单点登录 什么是单点登录？单点登录全称 Single Sign On（以下简称 SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分 单点登录 相比于单系统登录，sso 需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso 认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明 下面对上图简要描述 用户访问系统 1 的受保护资源，系统1发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数 sso 认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌 sso 认证中心带着令牌跳转会最初的请求地址（系统1） 系统1拿到令牌，去 sso 认证中心校验令牌是否有效 sso 认证中心校验令牌，返回有效，注册系统 1 系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源 用户访问系统 2 的受保护资源 系统2发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数 sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌 系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效 sso 认证中心校验令牌，返回有效，注册系统 2 系统 2 使用该令牌创建与用户的局部会话，返回受保护资源 用户登录成功之后，会与 sso 认证中心及各个子系统建立会话，用户与 sso 认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过 sso 认证中心，全局会话与局部会话有如下约束关系 局部会话存在，全局会话一定存在 全局会话存在，局部会话不一定存在 全局会话销毁，局部会话必须销毁 单点注销 单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明 sso 认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作 用户向系统 1 发起注销请求 系统1根据用户与系统1建立的会话 id 拿到令牌，向 sso 认证中心发起注销请求 sso 认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址 sso 认证中心向所有注册系统发起注销请求 各注册系统接收 sso 认证中心的注销请求，销毁局部会话 sso 认证中心引导用户至登录页面 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/单点登录/部署图及实现原理.html":{"url":"附录/单点登录/部署图及实现原理.html","title":"部署图及实现原理","keywords":"","body":"部署图及实现原理 部署图 单点登录涉及 sso 认证中心与众子系统，子系统与 sso 认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成 sso 的客户端，sso 认证中心则是 sso 服务端，整个单点登录过程实质是 sso 客户端与服务端通信的过程，用下图描述 sso 认证中心与 sso 客户端通信方式有多种，HttpClient，WebService、rpc、restful api 都可以 实现原理 SSO Client 拦截子系统未登录用户请求，跳转至 sso 认证中心 接收并存储 sso 认证中心发送的令牌 与 SSO Server 通信，校验令牌的有效性 建立局部会话 拦截用户注销请求，向 sso 认证中心发送注销请求 接收 sso 认证中心发出的注销请求，销毁局部会话 SSO Server 验证用户的登录信息 创建全局会话 创建授权令牌 与 SSO Client 通信发送令牌 校验 SSO Client 令牌有效性 系统注册 接收 SSO Client 注销请求，注销所有会话 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/单点登录/单点登录实战.html":{"url":"附录/单点登录/单点登录实战.html","title":"单点登录实战","keywords":"","body":"单点登录实战 所需工具类 CookieUtils package com.lusifer.leeshop.common.utils; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.UnsupportedEncodingException; import java.net.URLDecoder; import java.net.URLEncoder; /** * Cookie 工具类 * Title: CookieUtils * Description: * * @author Lusifer * @version 1.0.0 * @date 2017/12/10 22:00 */ public final class CookieUtils { /** * 得到Cookie的值, 不编码 * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName) { return getCookieValue(request, cookieName, false); } /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) { Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) { return null; } String retValue = null; try { for (int i = 0; i 0) cookie.setMaxAge(cookieMaxage); if (null != request) {// 设置域名的cookie String domainName = getDomainName(request); System.out.println(domainName); if (!\"localhost\".equals(domainName)) { cookie.setDomain(domainName); } } cookie.setPath(\"/\"); response.addCookie(cookie); } catch (Exception e) { e.printStackTrace(); } } /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) { try { if (cookieValue == null) { cookieValue = \"\"; } else { cookieValue = URLEncoder.encode(cookieValue, encodeString); } Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage > 0) cookie.setMaxAge(cookieMaxage); if (null != request) {// 设置域名的cookie String domainName = getDomainName(request); System.out.println(domainName); if (!\"localhost\".equals(domainName)) { cookie.setDomain(domainName); } } cookie.setPath(\"/\"); response.addCookie(cookie); } catch (Exception e) { e.printStackTrace(); } } /** * 得到cookie的域名 */ private static final String getDomainName(HttpServletRequest request) { String domainName = null; String serverName = request.getRequestURL().toString(); if (serverName == null || serverName.equals(\"\")) { domainName = \"\"; } else { serverName = serverName.toLowerCase(); serverName = serverName.substring(7); final int end = serverName.indexOf(\"/\"); serverName = serverName.substring(0, end); final String[] domains = serverName.split(\"\\\\.\"); int len = domains.length; if (len > 3) { // www.xxx.com.cn domainName = \".\" + domains[len - 3] + \".\" + domains[len - 2] + \".\" + domains[len - 1]; } else if (len 1) { // xxx.com or xxx.cn domainName = \".\" + domains[len - 2] + \".\" + domains[len - 1]; } else { domainName = serverName; } } if (domainName != null && domainName.indexOf(\":\") > 0) { String[] ary = domainName.split(\"\\\\:\"); domainName = ary[0]; } return domainName; } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/JRebel.html":{"url":"附录/JRebel.html","title":"IDEA 插件 JRebel","keywords":"","body":"IDEA 插件 JRebel JRebel 简介 IDEA 安装 JRebel 插件 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/JRebel/JRebel简介.html":{"url":"附录/JRebel/JRebel简介.html","title":"JRebel 简介","keywords":"","body":"JRebel 简介 JRebel 是一款 JAVA 虚拟机插件，它使得 JAVA 程序员能在不进行重部署的情况下，即时看到代码的改变对一个应用程序带来的影响。JRebel 使你能即时分别看到代码、类和资源的变化，你可以一个个地上传而不是一次性全部部署。当程序员在开发环境中对任何一个类或者资源作出修改的时候，这个变化会直接反应在部署好的应用程序上，从而跳过了构建和部署的过程。 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/JRebel/IDEA安装JRebel插件.html":{"url":"附录/JRebel/IDEA安装JRebel插件.html","title":"IDEA 安装 JRebel 插件","keywords":"","body":"IDEA 安装 JRebel 插件 安装 IDEA 中以此点击 File --> Settings --> Plugins 搜索并安装即可 激活 确保你可以访问国外网站 http://www.facebook.com，并确保你有一个 Facebook 账号或者 Twitter 账号 访问 https://my.jrebel.com，使用自己的 Facebook 账号登录 将激活码复制到 Intellij IDEA JRebel 激活 查看当前 JRebel 状态，绿色图标表示激活状态 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/Lombok.html":{"url":"附录/Lombok.html","title":"IDEA 插件 Lombok","keywords":"","body":"IDEA 插件 Lombok Lombok 简介 IDEA 安装 Lombok 插件 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/Lombok/Lombok简介.html":{"url":"附录/Lombok/Lombok简介.html","title":"Lombok 简介","keywords":"","body":"Lombok 简介 Lombok 是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得很臃肿的 Java 代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。 官网地址：https://projectlombok.org/ GitHub：https://github.com/rzwitserloot/lombok Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/Lombok/IDEA安装Lombok插件.html":{"url":"附录/Lombok/IDEA安装Lombok插件.html","title":"IDEA 安装 Lombok 插件","keywords":"","body":"IDEA 安装 Lombok 插件 安装 点击：File --> Settings --> Plugins 搜索：Lombok 安装完成后重启 IDEA 查看是否安装成功 使用 引入 Lombok 依赖 org.projectlombok lombok 1.16.18 使用 @Data 注解简化 POJO @Data 包含了 @ToString，@EqualsAndHashCode，@Getter/@Setter 和 @RequiredArgsConstructor 的功能 其他相关注解请自行查阅：http://jnb.ociweb.com/jnb/jnbJan2010.html 使用案例 @Data public class ItemCatNode implements Serializable { @JsonProperty(value = \"u\") private String url; @JsonProperty(value = \"n\") private String name; @JsonProperty(value = \"i\") private List item; } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/趣头条分析.html":{"url":"附录/趣头条分析.html","title":"趣头条分析","keywords":"","body":"趣头条分析 产品分析报告 数据结构分析-配置相关 数据结构分析-头条模块 数据库设计 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/趣头条分析/产品分析报告.html":{"url":"附录/趣头条分析/产品分析报告.html","title":"产品分析报告","keywords":"","body":"产品分析报告 产品简介 Slogan：让阅读更有价值 产品定位：「趣头条」作为一款新生代内容资讯 APP ，团队致力于让用户的阅读更有价值，通过大数据算法和云计算等技术，为用户提供感兴趣、有价值的个性化内容及服务。 核心功能：通过算法为用户推荐文章和阅读或评论获得金币回报 盈利模式：信息流广告以及商品导购 市场概况 进入 2016 年以来，中国移动资讯用户规模增速放缓，2016 年第四季度中国移动资讯用户达到 6.0 亿人。目前的移动资讯市场主力军为 80 后群体，这些用户的阅读习惯行为基本固化，增长空间有限。90 后群体，特别是尚未形成下载新闻资讯 APP 习惯的 95 后一代，是移动资讯规模未来发展的新动力。对于资讯平台而言，探索 90 后的阅读习惯，迎合其消费需求是提升市场份额的后续动力。 2016 年中国移动资讯用户主流的阅读偏好方式仍是图文并茂，但随着短视频的兴起，短视频方式已成为用户第二选择。短视频在过去一年迅速崛起，用户在短视频的阅读时长仍将持续上升。 用户场景 2016 年中国移动资讯用户阅读场景在睡前、上下班途中、饭点时间占比最大，分别占 52.2%、45.3% 及 43.2%。移动资讯阅读用户极少有留有专门时间用于浏览，更多的是利用碎片化时间。用户在不同场景下感兴趣的内容有差异，通过“技术 + 人工”智能识别并推荐用户在不同场景下的资讯，能满足用户个性化资讯浏览。探索资讯阅读全场景，是资讯平台未来个性化阅读的发力方向。 产品功能结构图 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/趣头条分析/数据结构分析-配置相关.html":{"url":"附录/趣头条分析/数据结构分析-配置相关.html","title":"数据结构分析-配置相关","keywords":"","body":"数据结构分析-配置相关 测试请求 启动配置 内容配置 广告配置 心跳包 位置信息 测试请求 HTTP 请求方式 GET URL https://api.1sapp.com/app/ts 参数说明 无 结果集 { \"code\": 0, \"message\": \"成功\", \"showErr\": 0, \"currentTime\": 1517297021, \"data\": {} } 启动配置 HTTP 请求方式 GET URL https://api.1sapp.com/app/start?OSVersion=11.2.5&client_version=2.6.0&device=iPhone%207&deviceCode=C74D6BE3-B6EB-60BC-78EB-F5E910E8583B&dtu=100&network=WIFI&sign=17b842f8cf6c8d34de70ac9aa5638d72&time=1517283057&tk=G1LIYGWaC-BM4Wy9onlqZbV0o656xRnHNa1DsvJfNVo&token=9b6a_HE2gsyDBlOzMJaBnIQJJ6DYD9aMijE9cFp08xSeMqiLr_g9emCHXTV4lUZ0wyL6RGloNhhvXjTWkQ&uuid=B8295D59-B4BE-4361-9C79-EE470B2DD87D&version=20600&versionName=2.6.0.1106.1150 参数说明 参数 是否必须 例子 说明 OSVersion 未知 11.2.5 操作系统版本号 client_version 未知 2.6.0 客户端版本号 device 未知 iPhone 7 设备 deviceCode 未知 设备码 dtu 是 100 network 未知 WIFI 网络模式 sign 是 fe3fcb1d0be0a43c28310ee06c605e52 校验码 time 未知 1517283056 tk 未知 token 是 令牌 uuid 未知 version 未知 20600 versionName 未知 2.6.0.1106.1150 结果集 { \"code\": 0, \"message\": \"成功\", \"showErr\": 0, \"currentTime\": 1517297647, \"data\": { \"h5_url\": { \"regProtocol\": \"http://h5ssl.1sapp.com/qukan_new2/dest/pages/pages/protocol.html\", \"invite\": \"http://h5ssl.1sapp.com/qukan_new2/dest/yq/inapp/yq/index.html\", \"mission\": \"http://h5ssl.1sapp.com/qukan_new2/dest/qd/inapp/qd/index.html\", \"registerInviteCode\": \"http://h5ssl.1sapp.com/qukan_new2/dest/yqcode/inapp/yqcode/index.html\", \"mall\": \"http://h5ssl.1sapp.com/qukan_new2/dest/mall2/inapp/mall2/index.html\", \"about\": \"http://h5ssl.1sapp.com/qukan_new2/dest/pages/pages/about.html\", \"howToRich\": \"https://h5ssl.1sapp.com/activity_dest/faq/index.html#/\", \"help\": \"http://h5ssl.1sapp.com/qukan/help.html\", \"feedback\": \"http://h5ssl.1sapp.com/qukan_new2/dest/feedback/html/feedback/index.html?r=3\", \"message\": \"http://h5ssl.1sapp.com/qukan_new2/dest/message/inapp/message/index.html?clientPage=message\", \"report\": \"http://h5ssl.1sapp.com/qukan_new2/dest/ts/inapp/ts/index.html\", \"fsdemo\": \"http://h5ssl.1sapp.com/qukan/fontsize_demo.html?r=1\", \"coin_details\": \"http://h5ssl.1sapp.com/qukan_new2/dest/incomes/inapp/incomes/index.html?tab=1\", \"balance_details\": \"http://h5ssl.1sapp.com/qukan_new2/dest/incomes/inapp/incomes/index.html?tab=2\", \"wemedia_rank\": \"http://h5ssl.1sapp.com/qukan_new2/dest/zmt_top/inapp/zmt_top/index.html\", \"wemedia_author_share\": \"http://h5ssl3.1sapp.com/qukan_new2/dest/zmt_home/read/zmt_home/index.html\" }, \"global_config\": { \"show_search\": 1, \"show_rss\": 1, \"wemedia_rank_switch\": 1, \"wemedia_jump_switch\": 1, \"read_config\": { \"touch_second\": 3, \"read_second\": 12, \"read_area_percent\": 0.9 }, \"share_way\": [ { \"id\": 1, \"name\": \"朋友圈\", \"is_show\": 0 }, { \"id\": 2, \"name\": \"微信好友\", \"is_show\": 0 }, { \"id\": 3, \"name\": \"QQ好友\", \"is_show\": 1 }, { \"id\": 4, \"name\": \"QQ空间\", \"is_show\": 1 }, { \"id\": 5, \"name\": \"复制链接\", \"is_show\": 1 }, { \"id\": 6, \"name\": \"微博\", \"is_show\": 1 } ], \"index_content_type\": \"1,2,4,3\", \"comment_another_tips\": \"请文明发言,遵守评论规则。被选为优质评论有额外奖励哦~\", \"force_message_push\": false, \"content_type_color\": { \"1\": \"#FF3333\", \"2\": \"#45C018\", \"3\": \"#4A90E2\", \"4\": \"#F6AA2C\", \"5\": \"#4A90E2\", \"6\": \"#FF3333\" }, \"mine_auth\": 1, \"interest_collect\": 0, \"navigation_bar\": { \"icon_zip\": \"http://static.1sapp.com/image/ico/icov250.zip\", \"navigation\": [ { \"name\": \"头条\", \"key\": \"content\", \"icon_normal\": \"\", \"icon_selected\": \"\", \"icon_normal_name\": \"tab_home_normal\", \"icon_selected_name\": \"tab_home_select\", \"sort\": 0, \"show\": 1, \"url\": \"\" }, { \"name\": \"视频\", \"key\": \"video\", \"icon_normal\": \"\", \"icon_selected\": \"\", \"icon_normal_name\": \"tab_video_normal\", \"icon_selected_name\": \"tab_video_select\", \"sort\": 1, \"show\": 1, \"url\": \"\" }, { \"name\": \"关注\", \"key\": \"wemedia\", \"icon_normal\": \"\", \"icon_selected\": \"\", \"icon_normal_name\": \"tab_wemedia_normal\", \"icon_selected_name\": \"tab_wemedia_select\", \"sort\": 2, \"show\": 0, \"url\": \"\" }, { \"name\": \"我的\", \"key\": \"my\", \"icon_normal\": \"\", \"icon_selected\": \"\", \"icon_normal_name\": \"tab_user_normal\", \"icon_selected_name\": \"tab_user_select\", \"sort\": 4, \"show\": 1, \"url\": \"\" } ] }, \"private_domains\": [ \"html3.1sapp.com\", \"html.1sapp.com\", \"h5ssl.1sapp.com\", \"h5ssl2.1sapp.com\", \"html2.qktoutiao.com\", \"html3.qktoutiao.com\" ], \"tingYun_disabled\": 0, \"dns_services\": [ \"119.29.29.29\", \"114.114.114.114\" ], \"app_store_grade_warn\": 1, \"cdn_services\": [], \"ios_content_native\": 0, \"h5_content_jump_reload\": 0, \"push_remind_recent\": 3, \"push_remind_long\": 7, \"cpc_switch\": 1, \"native_video_switch\": 1, \"native_article_switch\": 1, \"native_video_switch_v2\": 1, \"open_shumei\": 1, \"content_cache_time\": 600, \"ios_push_tips\": \"\", \"ios_next_push_tips\": \"\", \"channel_cache_time\": 300, \"enable_cache\": 0, \"app_store_score_remind\": { \"enable\": 1, \"day_after_install\": 2, \"interval_day\": 7 }, \"qt_app_score_remind\": { \"enable\": 0, \"active_day\": 5 }, \"https\": [ { \"host\": \"api.1sapp.com\", \"path\": \"/app/ts\" }, { \"host\": \"h5ssl.1sapp.com\", \"path\": \"/ts.json\" }, { \"host\": \"h5ssl2.1sapp.com\", \"path\": \"/ts.json\" }, { \"host\": \"static.1sapp.com\", \"path\": \"/ts.json\" }, { \"host\": \"html.1sapp.com\", \"path\": \"/ts.json\" }, { \"host\": \"html2.qktoutiao.com\", \"path\": \"/ts.json\" }, { \"host\": \"html3.qktoutiao.com\", \"path\": \"/ts.json\" } ] }, \"weixin_key\": [ { \"app_id\": \"wxe0135baa2b2554e8\", \"app_secret\": \"a5b4bc16873341c53cff98af2a58f32b\" } ], \"update\": {}, \"ad\": { \"openScreen\": { \"enable\": \"0\", \"slotId\": \"1028285\", \"countdown\": 3, \"push_skip\": \"0\", \"ad_source\": 2, \"request_countdown\": 3, \"background_interval\": 1800 }, \"video_ending_ads_info\": { \"enable\": \"0\", \"slotId\": \"1028596\", \"countdown\": \"5\", \"ad_source\": 2, \"skip_enable\": 1 } }, \"need_active_notice\": false, \"share_content\": { \"android_way\": \"sys\", \"android_appid\": \"wxe0135baa2b2554e8\", \"ios_way\": \"sys\", \"ios_appid\": \"wx3220732ac2a4175e\", \"android_share_config\": { \"android_way\": \"sys\", \"android\": [ { \"android_appid\": \"wxf0a80d0ac2e82aa7\", \"android_share_package\": \"com.tencent.mobileqq\" }, { \"android_appid\": \"wx64f9cf5b17af074d\", \"android_share_package\": \"com.tencent.mtt\" } ] } }, \"is_ios_review\": 0, \"is_ios_high_risk\": 0, \"is_android_high_risk\": 0, \"local_template\": { \"templateUrl\": \"http://inapp.1sapp.com/qukan_new2/dest/art2/read/art2/template.html\", \"templateMD5\": \"xxxxxx\", \"urlRule\": \"qktoutiao.com/detail/\", \"findText\": \"/art2/script/index.es6.js\", \"collect_rate\": 10 }, \"policy_app_my_menu\": 0, \"open_screen_image\": {}, \"video_read_reward\": { \"qdp\": [ { \"video_length_min\": 0, \"video_length_max\": 15, \"play_time\": 0 }, { \"video_length_min\": 15, \"video_length_max\": 30, \"play_time\": 1 }, { \"video_length_min\": 30, \"video_length_max\": 60, \"play_time\": 0.8 }, { \"video_length_min\": 60, \"video_length_max\": 80, \"play_time\": 0.6 }, { \"video_length_min\": 80, \"video_length_max\": 100, \"play_time\": 0.5 }, { \"video_length_min\": 100, \"video_length_max\": 120, \"play_time\": 0.4 }, { \"video_length_min\": 120, \"video_length_max\": 140, \"play_time\": 0.35 }, { \"video_length_min\": 140, \"video_length_max\": 160, \"play_time\": 0.3 }, { \"video_length_min\": 160, \"video_length_max\": 200, \"play_time\": 0.25 }, { \"video_length_min\": 200, \"video_length_max\": 250, \"play_time\": 0.2 }, { \"video_length_min\": 250, \"video_length_max\": 300, \"play_time\": 0.16 }, { \"video_length_min\": 300, \"video_length_max\": 400, \"play_time\": 0.13 }, { \"video_length_min\": 400, \"play_time\": 0.1 } ], \"qtg\": [ { \"video_length_min\": 0, \"video_length_max\": 15, \"play_time\": 0 }, { \"video_length_min\": 15, \"video_length_max\": 30, \"play_time\": 1 }, { \"video_length_min\": 30, \"video_length_max\": 60, \"play_time\": 0.8 }, { \"video_length_min\": 60, \"video_length_max\": 80, \"play_time\": 0.6 }, { \"video_length_min\": 80, \"video_length_max\": 100, \"play_time\": 0.5 }, { \"video_length_min\": 100, \"video_length_max\": 120, \"play_time\": 0.4 }, { \"video_length_min\": 120, \"video_length_max\": 140, \"play_time\": 0.35 }, { \"video_length_min\": 140, \"video_length_max\": 160, \"play_time\": 0.3 }, { \"video_length_min\": 160, \"video_length_max\": 200, \"play_time\": 0.25 }, { \"video_length_min\": 200, \"video_length_max\": 250, \"play_time\": 0.2 }, { \"video_length_min\": 250, \"video_length_max\": 300, \"play_time\": 0.16 }, { \"video_length_min\": 300, \"video_length_max\": 400, \"play_time\": 0.13 }, { \"video_length_min\": 400, \"play_time\": 0.1 } ], \"mp4\": [ { \"video_length_min\": 0, \"video_length_max\": 15, \"play_time\": 0 }, { \"video_length_min\": 15, \"video_length_max\": 30, \"play_time\": 1 }, { \"video_length_min\": 30, \"play_time\": 0.8 } ] }, \"show_self_start_flag\": 0, \"switch_push_info\": { \"android_first_title\": \"开启推送通知\", \"android_first\": \"开启后即可获得额外金币收益\", \"android_next\": \"开启后即可获得额外金币收益\", \"ios_first_title\": \"开启推送通知\", \"ios_first\": \"开启后即可获得额外金币收益\", \"ios_next\": \"开启后即可获得额外金币收益\", \"android_first_enable\": 1, \"android_url\": \"http://h5ssl.1sapp.com/qukan_new2/dest/open_notice/inapp/open_notice/index.html\", \"notify_mode\": 1 } } } 内容配置 HTTP 请求方式 GET URL https://api.1sapp.com/app/coldStart?OSVersion=11.2.5&client_version=2.6.0&device=iPhone%207&deviceCode=C74D6BE3-B6EB-60BC-78EB-F5E910E8583B&dtu=100&network=WIFI&sign=17b842f8cf6c8d34de70ac9aa5638d72&time=1517283057&tk=G1LIYGWaC-BM4Wy9onlqZbV0o656xRnHNa1DsvJfNVo&token=9b6a_HE2gsyDBlOzMJaBnIQJJ6DYD9aMijE9cFp08xSeMqiLr_g9emCHXTV4lUZ0wyL6RGloNhhvXjTWkQ&uuid=B8295D59-B4BE-4361-9C79-EE470B2DD87D&version=20600&versionName=2.6.0.1106.1150 参数说明 参数 是否必须 例子 说明 OSVersion 未知 11.2.5 操作系统版本号 client_version 未知 2.6.0 客户端版本号 device 未知 iPhone 7 设备 deviceCode 未知 设备码 dtu 是 100 network 未知 WIFI 网络模式 sign 是 fe3fcb1d0be0a43c28310ee06c605e52 校验码 time 未知 1517283056 tk 未知 token 是 令牌 uuid 未知 version 未知 20600 versionName 未知 2.6.0.1106.1150 结果集 { \"code\": 0, \"message\": \"成功\", \"showErr\": 0, \"currentTime\": 1517299099, \"data\": { \"is_first\": 0, \"share_invite\": { \"title\": \"在这里看资讯可以赚零花钱，我用了一段时间了非常棒！推荐你试试，哈哈\", \"desc\": \"趣头条专注有趣新鲜事 - 有用，有趣，有回报！\", \"url\": \"http://reg.cseyzx.com/notem/zczc.html\", \"icon\": \"http://static.1sapp.com/image/p/2016/07/21/14690921282556490000.png\", \"background\": \"http://static.1sapp.com/image/p/2016/08/15/14712444512883910000.png\", \"xysize\": \"222,651,196\", \"android_way\": \"sys\", \"ios_way\": \"sdk\", \"ios_appid\": \"\", \"android_appid\": \"\", \"android\": [] }, \"app_install\": [ \"com.dhbgchfa.qukanzhushou\", \"com.microvirt.guide\", \"com.microvirt.market\", \"com.microvirt.memuime\", \"com.haimawan.push\", \"me.haima.androidassist\", \"com.vphone.helper\", \"com.vphone.lanucher\", \"com.kop.zkop\", \"com.tiantian.ime\", \"cn.itools.vm.launcher\", \"cn.itools.vm.softkeyboard\", \"com.cootek.smartdialer\", \"com.ss.android.article.news\", \"com.hipu.yidian\", \"com.yidian.xiaomi\", \"com.oppo.news\", \"com.xxAssistant\" ], \"extend_report\": { \"enable\": true, \"start_time\": 1465315200 }, \"member_tags\": [ \"广东省\", \"ban_广州市\", \"ban_xm_all\", \"广州市\", \"with_draw_notification\" ], \"member_city\": \"广州市\", \"h5_url_cache\": [ \"1sapp.com/qukan_new2/dest/yq/inapp/yq/index.html\", \"1sapp.com/qukan_new2/dest/old_yq/inapp/old_yq/qd.html\", \"1sapp.com/qukan_new2/dest/qd/inapp/qd/index.html\", \"1sapp.com/qukan_new2/dest/guide/inapp/guide/index.html\", \"1sapp.com/qukan_new2/dest/mall2/inapp/mall2/index.html\", \"1sapp.com/qukan_new2/dest/mall/inapp/mall/detail.html\", \"1sapp.com/qukan_new2/dest/incomes/inapp/incomes/index.html\", \"1sapp.com/qukan_new2/dest/message/inapp/message/index.html\", \"1sapp.com/qukan_new2/dest/game_center2/inapp/game_center2/index.html\" ], \"need_active_notice_img\": \"http://static.1sapp.com/image/hongbao/pupilhongbao2.png\", \"cold_global_config\": { \"wemedia_jump_switch\": 1, \"ad_report_rate\": 100, \"register_button\": \"注册即送1元红包\", \"login_warning\": \"联系客服\", \"unlike\": [ \"重复、旧闻\", \"血腥、暴力\" ], \"person_top_img\": { \"title_bg\": \"\", \"user_bg\": \"\" }, \"show_like\": { \"article\": 0, \"video\": 0 }, \"status_bar\": { \"refresh_time\": 3600, \"switch\": 1 }, \"track_point\": { \"switch\": 0, \"first_refresh_time\": 10, \"first_refresh_num\": 10, \"next_refresh_time\": 10, \"next_refresh_num\": 2 }, \"adopen_in_webview\": 0, \"comment_tips\": \"我来说两句...\", \"license_force\": 1, \"animation\": { \"enable\": false, \"url\": \"http://static.1sapp.com/image/p/2017/01/06/133443443.jpg\", \"id\": 1, \"count\": 100, \"freq\": [ { \"interval\": 240, \"count\": 1 } ], \"start\": \"2017-02-04 00:00:01\", \"end\": \"2017-02-04 23:59:59\", \"md5\": \"1D1B45003A63A370A7E7AFB99788928F\" }, \"need_report_running_app\": false, \"app_restart_time\": 60, \"inno_switch\": 1, \"shumeng_switch\": 0, \"video_quality\": \"hd\", \"hobbyTips\": \"完善资料,有助于提供更好的内容服务\", \"video_auto_next_time\": 3, \"video_auto_enable\": 1 }, \"ad_cache_config\": { \"no_cache_ad\": [], \"expire\": 300 }, \"msg_box_tips\": {}, \"unlike_article_list\": [ { \"value\": 1, \"reason\": \"看过了\" }, { \"value\": 2, \"reason\": \"不喜欢该作者内容\" }, { \"value\": 3, \"reason\": \"不喜欢该类型文章\" } ], \"unlike_article_detail\": [ { \"value\": 2, \"reason\": \"不喜欢该作者内容\" }, { \"value\": 3, \"reason\": \"不喜欢该类型文章\" }, { \"value\": 4, \"reason\": \"标题与内容不符\" }, { \"value\": 5, \"reason\": \"内容质量太水\" } ], \"unlike_video_list\": [ { \"value\": 1, \"reason\": \"看过了\" }, { \"value\": 2, \"reason\": \"不喜欢该作者的内容\" }, { \"value\": 3, \"reason\": \"不喜欢该类型视频\" }, { \"value\": 4, \"reason\": \"视频不清晰\" } ], \"unlike_video_detail\": [ { \"value\": 2, \"reason\": \"不喜欢该作者的内容\" }, { \"value\": 3, \"reason\": \"不喜欢该类型视频\" }, { \"value\": 5, \"reason\": \"标题太夸张\" }, { \"value\": 6, \"reason\": \"内容质量太水\" } ], \"invite_config\": { \"top_img\": \"http://static.1sapp.com/image/invite/invite.png\", \"input_placeholder\": \"请输入邀请码（选填项）\", \"middle_word\": \"朋友介绍的，邀请码可向朋友索取\", \"button_word\": \"领取\", \"bottom_word\": \"没有邀请码，稍后再领取>>>\" }, \"quick_login_config\": { \"show_index\": 2 }, \"deepLinkWList\": [ \"openapp.jdmobile://\", \"openApp.jdMobile://\", \"taobao://\", \"tmall://\", \"tbopen://\", \"weixin://\", \"mqq://\", \"mqqapi://\", \"mqqwpa://\", \"mqqopensdkapi://\", \"dianping://\" ], \"notify_setting_config\": { \"enable_launch\": 0, \"enable_notice\": 0, \"launch_name\": \"允许自启动\", \"launch_desc\": \"可获得额外收益\", \"notice_name\": \"通知栏设置\", \"notice_desc\": \"设置后每天多拿300金币\", \"toast\": \"开启通知，可参与瓜分10亿金币\" }, \"read_time\": { \"article_time\": [ 12, 60 ], \"video_time\": [ 5, 0 ], \"enable\": 1, \"icon\": \"\", \"text\": \"今日阅读(分钟)\", \"gift_time\": [], \"url\": \"\" }, \"box_location\": { \"input_invitation_code\": [ \"content\", \"video\", \"my\" ], \"recall_card\": [ \"root\" ], \"normal_card\": [ \"my\" ], \"content_push\": [ \"content\", \"video\", \"my\" ] } } } 广告配置 HTTP 请求方式 GET URL https://api.1sapp.com/app/getAdConfig?OSVersion=11.2.5&cid=255&content_type=1%2C2%2C4%2C3&deviceCode=C74D6BE3-B6EB-60BC-78EB-F5E910E8583B&dtu=100&network=WIFI&sign=746155cadc508b15bf83635ae5e19853&time=1517283057&tk=G1LIYGWaC-BM4Wy9onlqZbV0o656xRnHNa1DsvJfNVo&token=9b6a_HE2gsyDBlOzMJaBnIQJJ6DYD9aMijE9cFp08xSeMqiLr_g9emCHXTV4lUZ0wyL6RGloNhhvXjTWkQ&uuid=B8295D59-B4BE-4361-9C79-EE470B2DD87D&version=20600&versionName=2.6.0.1106.1150 参数说明 参数 是否必须 例子 说明 OSVersion 未知 11.2.5 操作系统版本号 cid 未知 255 content_type 未知 1,2,4,3 deviceCode 未知 设备码 dtu 是 100 network 未知 WIFI 网络模式 sign 是 fe3fcb1d0be0a43c28310ee06c605e52 校验码 time 未知 1517283056 tk 未知 token 是 令牌 uuid 未知 version 未知 20600 versionName 未知 2.6.0.1106.1150 结果集 { \"code\": 0, \"message\": \"成功\", \"showErr\": 0, \"currentTime\": 1517300122, \"data\": { \"cid\": \"255\", \"content_type\": \"1,2,4,3\", \"setting\": { \"appId\": \"dd588a44\", \"imageType\": 1 }, \"slot_id\": [ 1026480, 1027836, 1028586, 1028588 ] } } 心跳包 HTTP 请求方式 GET URL https://api.1sapp.com/heart/getHeart?OSVersion=11.2.5&deviceCode=C74D6BE3-B6EB-60BC-78EB-F5E910E8583B&dtu=100&network=WIFI&sign=65a93932675efb454fcc59cd078cb61f&time=1517283057&tk=G1LIYGWaC-BM4Wy9onlqZbV0o656xRnHNa1DsvJfNVo&token=9b6a_HE2gsyDBlOzMJaBnIQJJ6DYD9aMijE9cFp08xSeMqiLr_g9emCHXTV4lUZ0wyL6RGloNhhvXjTWkQ&uuid=B8295D59-B4BE-4361-9C79-EE470B2DD87D&version=20600&versionName=2.6.0.1106.1150 参数说明 参数 是否必须 例子 说明 OSVersion 未知 11.2.5 操作系统版本号 deviceCode 未知 设备码 dtu 是 100 network 未知 WIFI 网络模式 sign 是 fe3fcb1d0be0a43c28310ee06c605e52 校验码 time 未知 1517283056 tk 未知 token 是 令牌 uuid 未知 version 未知 20600 versionName 未知 2.6.0.1106.1150 结果集 { \"code\": 0, \"currentTime\": 1517300218, \"data\": { \"ad\": { \"openScreen\": { \"ad_source\": 2, \"countdown\": 3, \"enable\": \"0\", \"push_skip\": \"0\", \"slotId\": \"1028285\" } }, \"gallery_cfg\": { \"duration\": 1, \"percent\": 0.8 }, \"h5_url\": { \"about\": \"http://h5ssl.1sapp.com/qukan_new2/dest/pages/pages/about.html\", \"balance_details\": \"http://h5ssl.1sapp.com/qukan_new2/dest/incomes/inapp/incomes/index.html?tab=2\", \"coin_details\": \"http://h5ssl.1sapp.com/qukan_new2/dest/incomes/inapp/incomes/index.html?tab=1\", \"feedback\": \"http://h5ssl.1sapp.com/qukan_new2/dest/feedback/html/feedback/index.html?r=3\", \"fsdemo\": \"http://h5ssl.1sapp.com/qukan/fontsize_demo.html?r=1\", \"help\": \"http://h5ssl.1sapp.com/qukan/help.html\", \"howToRich\": \"https://h5ssl.1sapp.com/activity_dest/faq/index.html#/\", \"invite\": \"http://h5ssl.1sapp.com/qukan_new2/dest/yq/inapp/yq/index.html\", \"mall\": \"http://h5ssl.1sapp.com/qukan_new2/dest/mall2/inapp/mall2/index.html\", \"message\": \"http://h5ssl.1sapp.com/qukan_new2/dest/message/inapp/message/index.html?clientPage=message\", \"mission\": \"http://h5ssl.1sapp.com/qukan_new2/dest/qd/inapp/qd/index.html\", \"regProtocol\": \"http://h5ssl.1sapp.com/qukan_new2/dest/pages/pages/protocol.html\", \"registerInviteCode\": \"http://h5ssl.1sapp.com/qukan_new2/dest/yqcode/inapp/yqcode/index.html\", \"report\": \"http://h5ssl.1sapp.com/qukan_new2/dest/ts/inapp/ts/index.html\", \"wemedia_author_share\": \"http://h5ssl3.1sapp.com/qukan_new2/dest/zmt_home/read/zmt_home/index.html\", \"wemedia_rank\": \"http://h5ssl.1sapp.com/qukan_new2/dest/zmt_top/inapp/zmt_top/index.html\" }, \"menu\": [], \"pop_msg\": {}, \"pull_act\": false, \"push_time_android\": 0, \"push_time_ios\": 1517299200, \"red_spot\": { \"has_new_pupil\": false, \"member_info\": true, \"message\": true, \"mission\": true, \"share\": false }, \"share_content\": { \"android_appid\": \"wxe0135baa2b2554e8\", \"android_share_config\": { \"android\": [ { \"android_appid\": \"wxf0a80d0ac2e82aa7\", \"android_share_package\": \"com.tencent.mobileqq\" }, { \"android_appid\": \"wx64f9cf5b17af074d\", \"android_share_package\": \"com.tencent.mtt\" } ], \"android_way\": \"sdk\" }, \"android_way\": \"sys\", \"ios_appid\": \"wx3220732ac2a4175e\", \"ios_way\": \"sys\" }, \"share_invite\": { \"background\": \"http://static.1sapp.com/image/p/2016/08/15/14712444512883910000.png\", \"desc\": \"趣头条专注有趣新鲜事 - 有用，有趣，有回报！\", \"icon\": \"http://static.1sapp.com/image/p/2016/07/21/14690921282556490000.png\", \"title\": \"在这里看资讯可以赚零花钱，我用了一段时间了非常棒！推荐你试试，哈哈\", \"url\": \"http://reg.cseyzx.com/notem/zczc.html\", \"xysize\": \"222,651,196\" }, \"share_v2\": null, \"share_way\": [ { \"id\": 1, \"is_show\": 0, \"name\": \"朋友圈\" }, { \"id\": 2, \"is_show\": 0, \"name\": \"微信好友\" }, { \"id\": 3, \"is_show\": 1, \"name\": \"QQ好友\" }, { \"id\": 4, \"is_show\": 1, \"name\": \"QQ空间\" }, { \"id\": 5, \"is_show\": 1, \"name\": \"复制链接\" }, { \"id\": 6, \"is_show\": 1, \"name\": \"微博\" } ] }, \"message\": \"success\" } 位置信息 HTTP 请求方式 POST URL https://api.1sapp.com/app/positioning 参数说明 参数 是否必须 例子 说明 OSVersion 未知 11.2.5 操作系统版本号 data 是 JSON 位置信息 deviceCode 未知 设备码 dtu 是 100 lat 未知 23.1782441238093 纬度 lon 未知 113.3350407030644 经度 network 未知 WIFI 网络模式 sign 是 fe3fcb1d0be0a43c28310ee06c605e52 校验码 time 未知 1517283056 tk 未知 token 是 令牌 uuid 未知 version 未知 20600 versionName 未知 2.6.0.1106.1150 data { \"district\": \"天河区\", \"country\": \"中国\", \"province\": \"广东省\", \"city\": \"广州市\", \"street\": \"元岗路307号\", \"address\": \"中国广东省广州市天河区元岗路307号\" } 结果集 { \"code\": 0, \"message\": \"成功\", \"showErr\": 0, \"currentTime\": 1517304463, \"data\": { \"member_tags\": [\"广东省\", \"ban_广州市\", \"ban_xm_all\", \"广州市\", \"with_draw_notification\"] } } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/趣头条分析/数据结构分析-头条模块.html":{"url":"附录/趣头条分析/数据结构分析-头条模块.html","title":"数据结构分析-头条模块","keywords":"","body":"数据结构分析-头条模块 24 小时热文 文章列表 默认频道列表 自定义频道列表 24小时热文 HTTP 请求方式 GET URL https://api.1sapp.com/app/msgBox?OSVersion=11.2.5&deviceCode=C74D6BE3-B6EB-60BC-78EB-F5E910E8583B&dtu=100&network=WIFI&sign=fe3fcb1d0be0a43c28310ee06c605e52&time=1517283056&tk=G1LIYGWaC-BM4Wy9onlqZbV0o656xRnHNa1DsvJfNVo&token=9b6a_HE2gsyDBlOzMJaBnIQJJ6DYD9aMijE9cFp08xSeMqiLr_g9emCHXTV4lUZ0wyL6RGloNhhvXjTWkQ&uuid=B8295D59-B4BE-4361-9C79-EE470B2DD87D&version=20600&versionName=2.6.0.1106.1150 参数说明 参数 是否必须 例子 说明 OSVersion 未知 11.2.5 操作系统版本号 deviceCode 未知 设备码 dtu 是 100 network 未知 WIFI 网络模式 sign 是 fe3fcb1d0be0a43c28310ee06c605e52 校验码 time 未知 1517283056 tk 未知 token 是 令牌 uuid 未知 version 未知 20600 versionName 未知 2.6.0.1106.1150 结果集 { \"code\": 0, \"message\": \"成功\", \"showErr\": 0, \"currentTime\": 1517283234, \"data\": [ { \"id\": \"11117283\", \"source\": \"\", \"source_name\": \"廊坊城事\", \"source_id\": \"\", \"title\": \"医院院长跳楼自杀 留遗书称“我在地狱里等着你”\", \"type\": \"1\", \"read_count\": \"167156\", \"share_count\": \"289\", \"comment_count\": \"18\", \"url\": \"http://html2.qktoutiao.com/detail/2018/01/30/11117283.html?content_id=11117283&key=0184Ms7m_K-O9aPYRn1YJ9MtSbF44kvFEOt0QXcNufChx8tybfm2XSsszWNyPK6idjNgvxx2CsIgMXM-_cXTJug-gfhkK1SC7srfyn0amIdy6yuQwJ6QDx5rtJp4dzPX-yQoAXq3cb286yMt_g&pv_id=%7BD32F22C2-5F98-C077-1E17-9CCD53A8AC60%7D&cid=1&cat=1&rss_source=&fr=16&hj=0&mod_id=12&fqc_flag=0&skip_ad=0\", \"is_hot\": \"0\", \"is_top\": \"0\", \"introduction\": \"2018年1月27日上午，河北廊坊城南医院发生一起坠楼事件。廊坊城南医院院长张某于当日上午11时许从其办公室窗户坠楼自杀死亡。目前，廊坊市安次区警方在接警后立即就此事展开调查，现将最新情况进行通报：为\", \"tag\": [], \"cover\": [ \"http://static.1sapp.com/image/sp/2018/01/30/5a6fd749a59f5.png?imageView2/2/w/200/h/150/q/70/format/jpeg\" ], \"cover_show_type\": \"1\", \"share_type\": \"0\", \"can_comment\": \"1\", \"publish_time\": \"1517278741660\", \"content_type\": \"1\", \"unlike_enable\": 1, \"show_comment\": 0, \"unlike_num\": \"5\", \"like_num\": 0, \"tips\": \"热门\", \"font_color\": \"\", \"font_bold\": \"0\", \"tips_color\": \"#FF5555\", \"share_url\": \"http://emyo.guaiguai009.com//detail/2018/01/30/11117283.html?content_id=11117283&key=555e2_R39gZvfJ4CdMDm39zJpmTbZCXPF-ZzPCcmuX1q7VdZwFOZlxjs_8aB9OZJ1T8NJCQf8i2pWWPextlAOZwXc3Z3krsTszS0Ig_z8ovtBj3A2z-pJsRBp7wJKXe5VKcTrQNayPNBO5e4dQ&pv_id=%7BD32F22C2-5F98-C077-1E17-9CCD53A8AC60%7D&cid=1&fr=16&i=2032168094\", \"like_num_show\": \"0\", \"unlike_num_show\": \"5\", \"iNative\": 1, \"show_time\": 1517278741, \"skip_ad\": \"0\", \"is_h5\": 0, \"is_favorite\": false, \"content_id\": 11117283, \"time\": 1517283000 } ] } 文章列表 HTTP 请求方式 GET URL https://api.1sapp.com/content/getList?OSVersion=11.2.5&cid=255&content_type=1%2C2%2C4%2C3&deviceCode=C74D6BE3-B6EB-60BC-78EB-F5E910E8583B&dtu=100&lat=23.17829340096483&lon=113.3350630361613&max_time=0&network=WIFI&op=2&page=1&sign=d40bfff3b433c28327efe2194dc89f27&time=1517304181&tk=G1LIYGWaC-BM4Wy9onlqZbV0o656xRnHNa1DsvJfNVo&token=9b6a_HE2gsyDBlOzMJaBnIQJJ6DYD9aMijE9cFp08xSeMqiLr_g9emCHXTV4lUZ0wyL6RGloNhhvXjTWkQ&uuid=B8295D59-B4BE-4361-9C79-EE470B2DD87D&version=20600&versionName=2.6.0.1106.1150 参数说明 参数 是否必须 例子 说明 OSVersion 未知 11.2.5 操作系统版本号 cid 是 255 分类ID（频道） content_type 未知 1,2,4,3 内容类型（如：视频、文章） deviceCode 未知 设备码 dtu 是 100 lat 未知 23.1782441238093 纬度 lon 未知 113.3350407030644 经度 max_time 未知 0 network 未知 WIFI 网络模式 op 未知 2 page 是 1 分页 sign 是 fe3fcb1d0be0a43c28310ee06c605e52 校验码 time 未知 1517283056 tk 未知 token 是 令牌 uuid 未知 version 未知 20600 versionName 未知 2.6.0.1106.1150 结果集 { \"code\": 0, \"message\": \"成功\", \"showErr\": 0, \"currentTime\": 1517304556, \"data\": { \"cid\": \"255\", \"pv_id\": \"{1EFAC30B-7B3B-95AB-6726-609303398092}\", \"count\": 8, \"op\": \"2\", \"page\": 1, \"min_time\": 1516785912858, \"max_time\": 1517304095026, \"show_time\": 1517304546, \"data\": [ { \"id\": \"10306768\", \"source\": \"精彩趣投稿\", \"source_name\": \"星座有料坊\", \"source_id\": \"\", \"title\": \"刷爆朋友圈的旅行青蛙！12星座中谁跟它一样佛系？\", \"type\": \"18\", \"read_count\": \"27610\", \"share_count\": \"94\", \"comment_count\": \"78\", \"url\": \"http://html2.qktoutiao.com/detail/2018/01/24/10306768.html?content_id=10306768&key=2911dRxC3t3MphddtZ_ONeexK7_3dcsOjqPB1YRGp4FBVdItL7RzceiHQMO7XqMZJeimuP28Yx-LFikP3yp9bw49gsN17zCdlwzTQSjjwucPw1NXqVVI2fIul6YQqWJmw80hLoRS2ppGKY7w6g&pv_id=%7B1EFAC30B-7B3B-95AB-6726-609303398092%7D&cid=255&cat=18&rss_source=&fr=11&hj=0&mod_id=12&o=2&p=1&fqc_flag=0&skip_ad=0\", \"is_hot\": \"2\", \"is_top\": \"0\", \"introduction\": \"这两天身边女孩玩得最多的游戏，除了《恋与制作人》就是《旅行青蛙》（旅かえる）了。这款游戏在朋友圈疯狂传播，它被称之为“佛性游戏”。“佛系”指的是一种怎样都可以，一切都随心所欲，不太走心，以一切随缘为指\", \"tag\": [ \"佛系\", \"双子\", \"巨蟹\", \"水瓶\" ], \"cover\": [ \"http://static.1sapp.com/qupost/image/sp/2018/01/24/1516785881632.jpeg?imageView2/2/w/200/h/150/q/70\", \"http://static.1sapp.com/qupost/image/sp/2018/01/24/1516785881743.jpeg?imageView2/2/w/200/h/150/q/70\", \"http://static.1sapp.com/qupost/image/sp/2018/01/24/1516785881675.jpeg?imageView2/2/w/200/h/150/q/70\" ], \"cover_show_type\": \"3\", \"share_type\": \"-1\", \"can_comment\": \"1\", \"publish_time\": \"1516785912858\", \"content_type\": \"1\", \"unlike_enable\": 1, \"show_comment\": 0, \"unlike_num\": \"4\", \"like_num\": 0, \"tips\": \"\", \"font_color\": \"\", \"font_bold\": \"\", \"share_url\": \"http://vlqm.gujixiaoyou.com//detail/2018/01/24/10306768.html?content_id=10306768&key=2e1190quM1W4OkhJ0CftRlVqt7llEtQ39cWYIJCprJzrWCqT69WeRi9yqBK3CxLuBAe-nSvFAFqgYnFRSVmIZ1n2mROxGQ_iUEw_NYUKmibr74pZyq9b0r1jkWZ1O-OnMZLwb5_-P0SEoLMUSA&pv_id=%7B1EFAC30B-7B3B-95AB-6726-609303398092%7D&cid=255&fr=11&i=3658703915\", \"like_num_show\": \"0\", \"unlike_num_show\": \"4\", \"iNative\": 1, \"show_time\": 1517304546, \"skip_ad\": 0, \"is_h5\": 0, \"is_favorite\": false, \"is_wemedia\": 1, \"avatar\": \"http://static.1sapp.com/qupost/avatar/2017/12/06/a60c6e66613f016aefd6ec91e40f4b0b.jpg?imageView2/1/h/120/w/120/q/90\", \"nickname\": \"星座有料坊\", \"article_num\": \"1\", \"video_num\": \"0\", \"extend\": \"{\\\"media_type\\\":\\\"1\\\",\\\"company_name\\\":\\\"上海星家网络科技有限公司\\\",\\\"identity_front\\\":\\\"2017\\\\/12\\\\/06\\\\/bb0f16aaa31d9414293b0362b390bdd4.jpg\\\",\\\"identity_negative\\\":\\\"2017\\\\/12\\\\/06\\\\/07490af2d9043ceee5fabeec077d8a74.jpg\\\",\\\"certificate\\\":\\\"\\\",\\\"company_pic\\\":\\\"2017\\\\/12\\\\/06\\\\/ffcf97afe5e9aa8fd1165b3e23ab6715.jpg\\\",\\\"company_book\\\":\\\"2017\\\\/12\\\\/06\\\\/ec986e0ab2474e9b0bf800f753701052.jpg\\\",\\\"company_code\\\":\\\"913101143508639733\\\",\\\"company_grade\\\":\\\"\\\",\\\"address\\\":\\\"陈翔路88号7幢3楼A区3245室\\\",\\\"notes\\\":\\\"微信公众号：http:\\\\/\\\\/mp.weixin.qq.com\\\\/s\\\\/ljmP_2yHlGMPRSIm262j8A\\\\n企鹅号：http:\\\\/\\\\/kuaibao.qq.com\\\\/s\\\\/20171204A0LG1X00\\\\n头条号：https:\\\\/\\\\/www.toutiao.com\\\\/i6494140252884582926\\\\/\\\",\\\"other_contact\\\":\\\"\\\",\\\"wx_public_number\\\":\\\"xzhome_com\\\",\\\"wx_public_nickname\\\":\\\"星座有料坊\\\",\\\"wx_public_info\\\":\\\"听说你不信星座？ 那你的生活怕是错过了些许幸福！ 关注我们，用快乐去认识自己，拥抱世界。 这里可不算命、更不信命， 而是去学习快乐的迎接成长、面对人生。\\\",\\\"wx_public_is_show\\\":1}\", \"last_content_type\": \"1\", \"author_id\": \"222454\", \"is_follow\": 0, \"has_article\": 1, \"has_video\": 0, \"show_article\": 1, \"wx_public_number\": \"xzhome_com\", \"wx_public_nickname\": \"星座有料坊\", \"wx_public_info\": \"听说你不信星座？ 那你的生活怕是错过了些许幸福！ 关注我们，用快乐去认识自己，拥抱世界。 这里可不算命、更不信命， 而是去学习快乐的迎接成长、面对人生。\", \"algorithm_id\": 1013 }, { \"flag\": 1, \"imageType\": 1, \"times\": 1, \"type\": \"ad\", \"ad_source\": 2, \"slotId\": 1027836, \"cid\": \"255\", \"op\": \"2\", \"page\": 1, \"index\": 5, \"tips\": \"广告\", \"appId\": \"dd588a44\" } ], \"top\": [ { \"id\": \"11132705\", \"source\": \"\", \"source_name\": \"中国国际电视台\", \"source_id\": \"\", \"title\": \"不忘初心：是什么造就了今天的习近平？\", \"type\": \"40\", \"read_count\": \"359810\", \"share_count\": \"4061\", \"comment_count\": \"35\", \"url\": \"http://html2.qktoutiao.com/detail/2018/01/30/11132705.html?content_id=11132705&key=1098N-ECaxEjSygdkRDK9UuoHmGzjx3QYHWm5fH0mC-iPwCnKum-iCRnlRsOK8r_0LGkU6dIFXIICZqPTU36dtm0R5LbEzCpIvzr_WoTz51OvEUpup-Y42C5DBlhRrlHWtEpIrV0WiJOVusZ1g&pv_id=%7B1EFAC30B-7B3B-95AB-6726-609303398092%7D&cid=255&cat=40&rss_source=&fr=13&hj=0&mod_id=12&o=2&p=1&fqc_flag=0&skip_ad=1\", \"is_hot\": \"0\", \"is_top\": \"0\", \"introduction\": \"原标题：不忘初心：是什么造就了今天的习近平？ “My seven years of rural life in northern Shaanxi Province gave me som\", \"tag\": [], \"cover\": [], \"cover_show_type\": \"6\", \"share_type\": \"0\", \"can_comment\": \"1\", \"publish_time\": \"1517286110938\", \"content_type\": \"1\", \"unlike_enable\": 1, \"show_comment\": 0, \"unlike_num\": \"749\", \"like_num\": 0, \"tips\": \"\", \"font_color\": \"\", \"font_bold\": \"0\", \"share_url\": \"http://vlqm.gujixiaoyou.com//detail/2018/01/30/11132705.html?content_id=11132705&key=87bb7SSdKVvtmCpDw3cMG-J5V5NWJeb75a84WJ3nU_qeuhTUIPQzDygfM_e_biyZv7uPtoHaL1j-uq0pTkUWJtct2hpMvReYcLZcI6h0m6xBintN2MLYvCsLkcWH7_5k9P5UKqLKx443-ucheA&pv_id=%7B1EFAC30B-7B3B-95AB-6726-609303398092%7D&cid=255&fr=13&i=3658703915\", \"like_num_show\": \"0\", \"unlike_num_show\": \"749\", \"iNative\": 1, \"show_time\": 1517286110, \"skip_ad\": \"1\", \"is_h5\": 0, \"is_favorite\": false }, { \"id\": \"11131167\", \"source\": \"\", \"source_name\": \"趣头条\", \"source_id\": \"\", \"title\": \"【劲爆好消息】每邀请一位好友即赚5元现金！上不封顶\", \"type\": \"255\", \"read_count\": \"355246\", \"share_count\": \"3442\", \"comment_count\": \"839\", \"url\": \"http://html2.qktoutiao.com/detail/2018/01/30/11131167.html?content_id=11131167&key=55668Nbqvgt2q7_uTWjPMXNqIg_Pk8BEZ2vHPM-AjoBWrgkBl_ToifNec_d40TTFbUH1Ve0NYEdJhm2AF4XnPjtURP-kPyB5GV0DVZjb1ooB7Saq5nmNBqLVtQIe8ygcJSjTADbZd_fujHT4Ng&pv_id=%7B1EFAC30B-7B3B-95AB-6726-609303398092%7D&cid=255&cat=255&rss_source=&fr=13&hj=0&mod_id=12&o=2&p=1&fqc_flag=0&skip_ad=1\", \"is_hot\": \"0\", \"is_top\": \"0\", \"introduction\": \"转眼2018年已经过了一个月了，前阵子咱们趣头条举办的“新年小目标”、“全民阅读节”等送钱小活动，各位趣友们都参加了吗？领到了多少现金奖励呢？如果你错过了前面这些活动，别急，相信小编，你们的“散财童子\", \"tag\": [], \"cover\": [ \"http://static.1sapp.com/image/sp/2018/01/30/5a6fefd8b77a1.png?imageView2/2/w/690/h/150/q/70/format/jpeg\" ], \"cover_show_type\": \"5\", \"share_type\": \"0\", \"can_comment\": \"1\", \"publish_time\": \"1517285337225\", \"content_type\": \"1\", \"unlike_enable\": 1, \"show_comment\": 0, \"unlike_num\": \"428\", \"like_num\": 0, \"tips\": \"\", \"font_color\": \"\", \"font_bold\": \"0\", \"share_url\": \"http://vlqm.gujixiaoyou.com//detail/2018/01/30/11131167.html?content_id=11131167&key=4abdxmn44ZlDttorTAc0WSSLVFJDrcJt1PqdxJZCrNvovn5pwf9evLp1345PDvoPLY1mc5NYSs-yFg6m-kn0WM9yOkrCGZWlcCDIFsBtz8JRGd2zYBDDCKjRo2d_6TOwBt4eVqcHrZQySFKFZg&pv_id=%7B1EFAC30B-7B3B-95AB-6726-609303398092%7D&cid=255&fr=13&i=3658703915\", \"like_num_show\": \"0\", \"unlike_num_show\": \"428\", \"iNative\": 1, \"show_time\": 1517285337, \"skip_ad\": \"1\", \"is_h5\": 0, \"is_favorite\": false } ], \"bottom\": { \"slotId\": \"1026553\", \"appId\": \"dd588a44\", \"ad_source\": 2 } } } 默认频道列表 HTTP 请求方式 GET URL https://api.1sapp.com/content/getDefaultChannelList?OSVersion=11.2.5&deviceCode=C74D6BE3-B6EB-60BC-78EB-F5E910E8583B&dtu=100&lat=23.17820994054544&lon=113.3350480986407&network=WIFI&sign=045e88ea47fe80039709d5f449962b81&time=1517283058&tk=G1LIYGWaC-BM4Wy9onlqZbV0o656xRnHNa1DsvJfNVo&token=9b6a_HE2gsyDBlOzMJaBnIQJJ6DYD9aMijE9cFp08xSeMqiLr_g9emCHXTV4lUZ0wyL6RGloNhhvXjTWkQ&uuid=B8295D59-B4BE-4361-9C79-EE470B2DD87D&version=20600&versionName=2.6.0.1106.1150 参数说明 参数 是否必须 例子 说明 OSVersion 未知 11.2.5 操作系统版本号 deviceCode 未知 设备码 dtu 是 100 lat 未知 23.1782441238093 纬度 lon 未知 113.3350407030644 经度 network 未知 WIFI 网络模式 sign 是 fe3fcb1d0be0a43c28310ee06c605e52 校验码 time 未知 1517283056 tk 未知 token 是 令牌 uuid 未知 version 未知 20600 versionName 未知 2.6.0.1106.1150 结果集 { \"code\": 0, \"message\": \"成功\", \"showErr\": 0, \"currentTime\": 1517333319, \"data\": [ { \"id\": 255, \"name\": \"推荐\" }, { \"id\": 40, \"name\": \"新时代\" }, { \"id\": 37, \"name\": \"视频\" }, { \"id\": \"440100\", \"name\": \"广州\" }, { \"id\": 1, \"name\": \"热点\" }, { \"id\": 6, \"name\": \"娱乐\" }, { \"id\": 5, \"name\": \"养生\" }, { \"id\": 2, \"name\": \"搞笑\" }, { \"id\": 3, \"name\": \"奇闻\" }, { \"id\": 4, \"name\": \"励志\" }, { \"id\": 7, \"name\": \"科技\" }, { \"id\": 8, \"name\": \"生活\" }, { \"id\": 10, \"name\": \"财经\" }, { \"id\": 9, \"name\": \"汽车\" }, { \"id\": 11, \"name\": \"情感\" }, { \"id\": 18, \"name\": \"星座\" }, { \"id\": 12, \"name\": \"美食\" }, { \"id\": 14, \"name\": \"时尚\" }, { \"id\": 16, \"name\": \"旅行\" }, { \"id\": 17, \"name\": \"育儿\" }, { \"id\": 13, \"name\": \"体育\" }, { \"id\": 15, \"name\": \"军事\" }, { \"id\": 23, \"name\": \"历史\" }, { \"id\": 27, \"name\": \"三农\" }, { \"id\": 29, \"name\": \"故事\" }, { \"id\": 30, \"name\": \"收藏\" }, { \"id\": 19, \"name\": \"游戏\" } ] } 自定义频道列表 HTTP 请求方式 GET URL https://api.1sapp.com/content/getChannelList?OSVersion=11.2.5&deviceCode=C74D6BE3-B6EB-60BC-78EB-F5E910E8583B&dtu=100&lat=23.17820994054544&lon=113.3350480986407&network=WIFI&sign=0b4357e7ac559cd48d521d7aa966f5da&time=1517283059&tk=G1LIYGWaC-BM4Wy9onlqZbV0o656xRnHNa1DsvJfNVo&token=9b6a_HE2gsyDBlOzMJaBnIQJJ6DYD9aMijE9cFp08xSeMqiLr_g9emCHXTV4lUZ0wyL6RGloNhhvXjTWkQ&uuid=B8295D59-B4BE-4361-9C79-EE470B2DD87D&version=20600&versionName=2.6.0.1106.1150 参数说明 参数 是否必须 例子 说明 OSVersion 未知 11.2.5 操作系统版本号 deviceCode 未知 设备码 dtu 是 100 lat 未知 23.1782441238093 纬度 lon 未知 113.3350407030644 经度 network 未知 WIFI 网络模式 sign 是 fe3fcb1d0be0a43c28310ee06c605e52 校验码 time 未知 1517283056 tk 未知 token 是 令牌 uuid 未知 version 未知 20600 versionName 未知 2.6.0.1106.1150 结果集 { \"code\": 0, \"message\": \"成功\", \"showErr\": 0, \"currentTime\": 1517333319, \"data\": [ { \"id\": 255, \"name\": \"推荐\" }, { \"id\": 40, \"name\": \"新时代\" }, { \"id\": 37, \"name\": \"视频\" }, { \"id\": \"440100\", \"name\": \"广州\" }, { \"id\": 1, \"name\": \"热点\" }, { \"id\": 6, \"name\": \"娱乐\" }, { \"id\": 5, \"name\": \"养生\" }, { \"id\": 2, \"name\": \"搞笑\" }, { \"id\": 3, \"name\": \"奇闻\" }, { \"id\": 4, \"name\": \"励志\" }, { \"id\": 7, \"name\": \"科技\" }, { \"id\": 8, \"name\": \"生活\" }, { \"id\": 10, \"name\": \"财经\" }, { \"id\": 9, \"name\": \"汽车\" }, { \"id\": 11, \"name\": \"情感\" }, { \"id\": 18, \"name\": \"星座\" }, { \"id\": 12, \"name\": \"美食\" }, { \"id\": 14, \"name\": \"时尚\" }, { \"id\": 16, \"name\": \"旅行\" }, { \"id\": 17, \"name\": \"育儿\" }, { \"id\": 13, \"name\": \"体育\" }, { \"id\": 15, \"name\": \"军事\" }, { \"id\": 23, \"name\": \"历史\" }, { \"id\": 27, \"name\": \"三农\" }, { \"id\": 29, \"name\": \"故事\" }, { \"id\": 30, \"name\": \"收藏\" }, { \"id\": 19, \"name\": \"游戏\" } ] } Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "},"附录/趣头条分析/数据库设计.html":{"url":"附录/趣头条分析/数据库设计.html","title":"数据库设计","keywords":"","body":"数据库设计 字典表 频道表 文章表 字典表 .tg {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;} .tg .tg-yw4l{vertical-align:top} 表名 dict 字段 类型 主键 可空 默认值 说明 id bigint 是 否 主键 value varchar(100) 否 是 默认为空 数据值 label varchar(100) 否 是 默认为空 标签名 type varchar(100) 否 是 默认为空 类型 description varchar(100) 否 是 默认为空 描述 sort int 否 是 0 排序 pid bigint 否 是 0 父级标签 is_parent char(1) 否 是 0 是否为父级标签 create_by bigint 否 是 默认为空 创建者 create_date datatime 否 是 默认now() 创建时间 update_by bigint 否 是 默认为空 更新者 update_date datetime 否 是 默认now() 更新时间 remark varchar(255) 否 是 默认为空 备注 del_flag char(1) 否 是 0 删除标记 频道表 .tg {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;} .tg .tg-yw4l{vertical-align:top} 表名 channel 字段 类型 主键 可空 默认值 说明 id bigint 是 否 主键 name varchar(20) 否 是 默认值空 频道名称 pid bigint 否 是 0 父级频道 is_parent char(1) 否 是 0 是否为父级频道 sort int 否 是 0 排序 create_by bigint 否 是 默认为空 创建者 create_date datatime 否 是 默认now() 创建时间 update_by bigint 否 是 默认为空 更新者 update_date datetime 否 是 默认now() 更新时间 remark varchar(255) 否 是 默认为空 备注 del_flag char(1) 否 是 0 删除标记 文章表 .tg {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;} .tg .tg-yw4l{vertical-align:top} 表名 article 字段 类型 主键 可空 默认值 说明 id bigint 是 否 主键 source varchar(20) 否 是 默认为空 文章来源 source_name varchar(20) 否 是 默认为空 投稿人 source_id varchar(32) 否 是 默认为空 文章来源ID title varchar(50) 否 是 默认为空 文章标题 type char(1) 否 是 0 文章类型 read_count int 否 是 0 阅读数量 share_count int 否 是 0 分享数量 comment_count int 否 是 0 评论数量 url varchar(1000) 否 是 默认为空 文章链接 is_hot char(1) 否 是 1 是否热门 is_top char(1) 否 是 1 是否置顶 introduction varchar(255) 否 是 默认为空 简介 tag varchar(255) 否 是 默认为空 标签 cover varchar(1000) 否 是 默认为空 相册 cover_show_type char(1) 否 是 0 图片位置 share_type char(1) 否 是 0 分享类型 can_comment char(1) 否 是 0 允许评论 content_type char(1) 否 是 0 文章类型 unlike_enable char(1) 否 是 0 允许踩 show_comment char(1) 否 是 0 显示评论 unlike_num int 否 是 0 踩数量 like_num int 否 是 0 赞数量 tips varchar(255) 否 是 默认为空 小提示 font_color varchar(20) 否 是 默认为空 标题颜色 font_bold varchar(20) 否 是 默认为空 标题加粗 share_url varchar(1000) 否 是 默认为空 分享链接 like_num_show char(1) 否 是 0 显示赞 unlike_num_show char(1) 否 是 0 显示踩 iNative char(1) 否 是 0 平台原创 skip_ad char(1) 否 是 1 允许跳过广告 is_h5 char(1) 否 是 1 是否H5 extend text 否 是 默认为空 扩展字段 author_id bigint 否 是 0 作者ID show_article char(1) 否 是 0 是否显示 create_by bigint 否 是 默认为空 创建者 create_date datatime 否 是 默认now() 创建时间 update_by bigint 否 是 默认为空 更新者 update_date datetime 否 是 默认now() 更新时间 remark varchar(255) 否 是 默认为空 备注 del_flag char(1) 否 是 0 删除标记 Copyright 2021 all right reserved，powered by Gitbook该文件修订时间： 2018-05-03 01:12:15 "}}